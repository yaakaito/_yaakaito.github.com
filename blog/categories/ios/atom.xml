<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | yaakaito.org]]></title>
  <link href="http://yaakaito.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yaakaito.github.com/"/>
  <updated>2013-01-06T13:22:36+09:00</updated>
  <id>http://yaakaito.github.com/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CSSライクにUIKitをスタイルできるNUIがおもしろい！]]></title>
    <link href="http://yaakaito.github.com/blog/2012/12/06/adv-nui-css-like-uikit/"/>
    <updated>2012-12-06T22:01:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/12/06/adv-nui-css-like-uikit</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
<a href="http://qiita.com/advent-calendar/2012/objective-c">Objective-Cアドベントカレンダー2012</a> 6日目の記事です。
AppCodeのことを書こうと思っていたのですが、今日 <a href="https://github.com/tombenner/nui">NUI</a> というライブラリを見つけて、今僕の中でアツいので紹介しようと思います。
サンプルも書いていたのですが、アドベントにカレンダーできなさそうなので、今回は紹介だけです。</p>

<h2>NUIって何</h2>

<p>NUIはCSSライクにUIKitのスタイルを指定できるライブラリです。
READMEからの引用ですが、こんな感じに定義することができます。</p>

<p>```objective-c
@primaryFontName: HelveticaNeue;
@secondaryFontName: HelveticaNeue-Light;
@primaryFontColor: #333333;
@primaryBackgroundColor: #E6E6E6;</p>

<p>Button {</p>

<pre><code>background-color: @primaryBackgroundColor;
border-color: #A2A2A2;
border-width: @primaryBorderWidth;
font-color: @primaryFontColor;
font-color-highlighted: #999999;
font-name: @primaryFontName;
font-size: 18;
corner-radius: 7;
</code></pre>

<p>}
NavigationBar {</p>

<pre><code>background-tint-color: @primaryBackgroundColor;
font-name: @secondaryFontName;
font-size: 20;
font-color: @primaryFontColor;
text-shadow-color: #666666;
text-shadow-offset: 1,1;
</code></pre>

<p>}
```</p>

<p><img src="/images/adv_nui.png" width="320"></p>

<p>(<a href="https://github.com/tombenner/nui/blob/master/README.md">README</a>より引用)</p>

<p>実際にCSSが書けるわけではなくて、あくまでUIKitに対応するプロパティをCSSライクに設定できるライブラリです。
昔CSSをそのまま使えたら幸せじゃね、と考えてみたことはあったのですが、さすがにしんどくて挫折しました。
そういう意味では NUI みたいな感じになっていても、十分良さそうに思えますね。</p>

<h2>簡単な使い方</h2>

<p>僕自身もまだちゃんと使えている訳ではないのですが、起動後にNUIを有効にしてあげて、</p>

<p><code>objective-c
[NUIAppearance init];
</code></p>

<p>で、NUIをセットアップします。</p>

<p>あとは適用したいUIクラスをNUIButtonなどのサブクラスで定義して、</p>

<p>```objective-c
- (void)initNUI {</p>

<pre><code>[super initNUI];
self.nuiClass = @"Button:MyButton";
</code></pre>

<p>}
```</p>

<p>とかしてあげると、プロジェクトに含まれいる<code>NUIStyle.nss</code>を元にスタイリングしてくれるようです。
自信はそんなにないですが。</p>

<h2>設定できるプロパティとか</h2>

<p><a href="https://github.com/tombenner/nui/blob/master/README.md#style-classes">READMEのStyleClasses</a>に書いてありますが、一通りは設定できる様子。</p>

<h2>楽しみですね</h2>

<p>ログをみたらまだできたばかりのプロダクトでした。今後どうなるか楽しみですね！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOSアプリのテストを１週してみて思ったこと]]></title>
    <link href="http://yaakaito.github.com/blog/2012/11/12/ios-testing-cycle-1/"/>
    <updated>2012-11-12T21:57:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/11/12/ios-testing-cycle-1</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
iOSアプリのテストのことをそろそろ１年くらい考えていて、１周した感じもするので、
ここら辺で一旦の区切りの意味でもなんとなく考えをまとめてみる。
ちなみにテストというのは主に単体テストにフォーカスした内容です。</p>

<p>こういう系のエントリを書くと、僕はわりと誤解を生みやすい書き方をしてしまうので先に断っておくと、</p>

<ul>
<li>なんらかのアプリ開発手法や、テスト手法をDisっているわけではないです。</li>
<li>フレームワークがいろいろ登場したりしますが、それらをDisっている訳ではないですし、それぞれ素晴らしいものだと思っています。</li>
<li>同じくそのフレームワークを使っているプロジェクトも登場しますが、それらをDisっている訳でもありません。</li>
<li>もちろん特定個人をDisる内容でもありません。</li>
</ul>


<p>という感じで、何かをDisってる記事ではないので、ご了承ください。</p>

<p>長めです。結局何がよかったの、っていう人は下の方から見てください。</p>

<h2>テストフレームワークの変遷</h2>

<h3>はじめの一歩</h3>

<p>皆さんご存知SenTestingKitです。
ほかにどんなフレームワークあるのか知らんし、とりあえずこれで書けなきゃどっちにしろ無理だろ、という感じでした。セットでOCMockも使っていました。
記憶が正しければ、Xcodeは4.1で、iOS4.x~を対象にしたアプリを作っていた記憶です。
ぶっちゃけこのころはSenTestingKitがどうしようもない感じで、状況によっては <code>STAssertTrue(YES)</code> が落ちたりしていました。
それでもある程度のテストを書くことはできました。モデルのテストは十分に書ける感じ。ビュー関連に関しては完全に諦めモードでしたが・・・。
この頃はアプリ全体をテストしていたのと、あんまり慣れていないところもあって、テストケースが冗長だったり、テストが思ったのと違う動きをしたり、いろいろありました。</p>

<h3>安定を求めてGHUnitへ</h3>

<p>まじなんとかならんの、とか思っていたときに良さげだなーとなったのがGHUnit。
GHUnitはそれ自体がアプリとして動いて、その上でテストコードを実行するというもの。
SenTestingKitと比較して圧倒的に安定しているのと、SenTestingKitと互換性があるのがプラス点。
さらには<code>GHVerifyView</code>というビューを画像の一致率でテストできるものもあったり、非同期テスト標準であったりと、盛りだくさん。
この時期に作っていたもので公開しているものでは、NLTHTTPStubServerはテストがGHUnitで書かれています。
アプリ開発をしつつも、アプリのコア部分をフレームワーク化する、ということもやっていたし、
特にフレームワーク側はちゃんとテスト固めないとなぁという意味でも、安定しているGHUnitを選択しました。
アサーションもSenTestingKitよりも断然豊富で、iOSのテストに慣れてきたのもあって、
テストケースはわりと綺麗に書けるようになっていった気がします。(どうしようもないところもありますが。)</p>

<p>使いはじめの時点ではほとんど問題なく、これでいいや、という感じでしたが、GHUnitは使い続けるうちに問題がでてきました。
GHUnitの問題点は、GHUnit自体がiOSアプリとして動くものなので、ターゲットを切り替えたりでどうしてもテスト実行とかがスムーズにできないところ。
GHUnitを2つのチームで使ってみましたが、保守できたのは片方だけだったので、思いの他このコストは高かったみたいです。
実行されないテストに価値はないし、実行時に障害があるのは問題外。同じアプリで動くタイプでBDDスタイルなCedarもこの段階で却下。
あとはテストログの表示がイケてないなーと思うところもありました。この辺りはちょっと弄ってあげればすむ話ではありますが、それでもコストが高め。</p>

<h3>BDD系への転向</h3>

<p>次に触ってみたのはObjective-C版RspecことKiwiです。
GHUnitの時と同じくこの時期に作っていたNLTQuickCheckにはテストにKiwiが使われています。
これはこの段階ではアプリのテストにはまったく利用していなくて、NLTQuickCheckみたいなObjective-C製のライブラリ開発に利用していました。
ライブラリを書いている分にはKiwiはめちゃくちゃいいです。QuickCheckみたいに、ビューが絡まない中で一旦非同期処理などもあまり考えずに済むというのは、テストを書いていく上では快適でした。
ただKiwiはすぐに問題にぶちあたることになります。単純にGHUnitの<code>GHVerifyView</code>がアプリ開発で便利すぎたので、
どうしてもアプリを作ろうと考えるとGHUnitの方が良さそうに思えました。</p>

<h3>ビューテストをするためにGHUnitへ戻る</h3>

<p>そしてGHUnitへ戻ることになります。
結構複雑なビューをもつアプリを作っていたこともあって、ビューをコンポーネント単位で視覚的に動作確認できるのは、ものすごく便利でした。
ただやっぱりXUnit形式で書くのがもはやしんどい感じになっていて、ダルぽよ〜〜〜という状態でした。</p>

<h3>もう一度BDD系へ戻る</h3>

<p>Kiwiに戻ってきました。このあたりできれいなBDD、に対する回答を求めてTheRSpecBookなんかを読み始めました。
TheRSpecBookは非常によい本で、BDDってなんじゃ、みたいなところから実際にこんな感じで進めるといいよ、ということが書いてあって参考になりました。
ただ、じゃあそれiOSアプリ開発でObjective-C使って実践できんの、といわれるとそういう訳ではなく。
最初の方はとにかくSpecを全部書ききってから実装する、みたいなことも試してみましたが、あんまりしっくりこない。(ノッてるとうまくいっていると錯覚はする。)
BDDやるならビヘイビアにドリブンなデベロップしないと意味ないよねー、後付けのBDDとか何の意味があるんや！！！ってことで、OH！やっぱり今回も駄目だったよ。状態に。</p>

<h3>さらにBDD系を突き詰めてみる</h3>

<p>けどここで引き下がるのも勿体ないので、注目度があがってきたSpectaに乗り換えてもう一度チャレンジしてみることに。
<code>theValue</code>を書かなくともよくなった分、やりやすさはあがった気がします。ヤッホーイ！
だいたいモデル層はめちゃくちゃ綺麗にいけるようになってきたんですが・・・・え？View・・・？・・・
とりあえずビューはFrankでカバーするかーという感じになったのですが、結局のところ作ってみてだいたいこんな感じやろ、
という調整が多くなるビューでいちいちテストとか書いてられるか！！！という感じになった。</p>

<h3>原点回帰</h3>

<p>という訳でSenTestingKitまで戻ってきました。KiwiやSpectaが普段の開発で困らない分には動くってことは生でも動くってことです。
僕はあんまり思ってなかったんですが、Blocks使うとスタックトレースが追いにくくなるとかも、ちょいちょい聞くので素直にSenTestingKitがよくね？ということに。
それでもアサーションとかは不足しているので、OCHamcrestとかで補いつつ、非同期テストケースとかもサンプルがたくさんあるし、Githubなんかで拾ってこれば十分かなぁと。
普段はTDDで開発して、ビューは先に動きのプロトタイプを作ってしまって、あとからそれを補強していく、というので全然問題ないと思う。
GHUnitはやっぱり実行コストが高いし、SenTestingKitでいけるならそれでいいじゃない。Cmd+Uがないとテスト書く気起きないっていうか・・・。</p>

<h3>変遷まとめ</h3>

<p>とりあえずまとめておくと僕はこんな感じで使ってきました。
SenTestingKit -> GHUnit -> Kiwi -> GHUnit -> Kiwi -> Specta -> SenTestingKit</p>

<h2>iOS開発でよくあることを踏まえたい</h2>

<p>ここから割とエンジニアリングとは逆方向な内容になります。
ただ僕もエンジニアなので、ディレクターとかデザイナー目線でみると違うかもしれません。</p>

<h3>ビューを優先して組み立てるべき</h3>

<p>お客さんがみたいのはビューですし、ディレクターがみたいのもビューなら、みなさんがアプリ作りたいと思ったとき最初に頭に浮かぶのもビューです。
iOSアプリ作ってていつも思うのが、いくらモデル層をきれいに分離して、きれいなAPIを設計で綺麗なテストができたとしても、
アプリのファーストビューを表示するためにAPIを3つも4つも呼んでその上計算までしなきゃいけない、
とかだとハイパフォーマンスなアプリとは到底言えないですよね。ということ。
「本当の気持ちなんて伝えられるわけないのよ、だって私は、綺麗な世界とは違う世界をいきているんだもの！！！RESTfullとかしらないわよ！！！全部まとめて返してよ！！！」
という感じです。別にiOS限った話ではないですが、クライアントはだいたいそんな感じだと思ってます。(しつこいですがDisったりしてる意図ないです)</p>

<h3>やっぱさ、新しい機能とか試してみたいじゃん？</h3>

<p>ですよね、僕もそう思います。そういうのってスピードが大事じゃないですか。
テスト書いてる暇とかないわ、というのは嘘かサボりだと思いますが、プロトにいちいちテスト書いててもキリがないというのはあると思います。
OS自体のアップデートも早いし、界隈の流行り廃りもまだまだ早いので、保守にあまりにもコストを掛けすぎるのはあまりチャレンジングではないと思います。</p>

<h3>なんか思ってたのと違うんだけど</h3>

<p>よくあることです。諦めてください。
テスト書きまくって苦労しました、みたいなアホな状態になってたら悪いのはちゃんとプロト見せたりしなかった開発者です。</p>

<h3>テストってさ？コストかかるんでしょ？</h3>

<p>開発をサポートするテストは書いても書かなくても開発速度にそこまで差はないと思います。
長期的にみたらテストは書いた方がいいですが。</p>

<h3>人海戦術でなんとかなるっしょ？</h3>

<p>アホか。</p>

<p>と言いたいところですが、そういう場面があることは確かです。</p>

<h3>よくあることまとめ</h3>

<p>まあ、iOS開発に限ったことじゃないですが(2回目ですね)、巻き戻しとか、もっといいの目指そう！とかそういうのはあるし、
それが正しい場面もあるので、あんまり過剰にやりすぎないようにしないとトータルとしてのパフォーマンスが下がるので、それでは意味がない。</p>

<h2>とりあえず１週目の結論として</h2>

<p>普通にアプリ作る分には単体テストはSenTestingKit+拡張マッチャでモデル中心に大丈夫と思えるところまで書け。ということになりました。割と普通です。
カバレッジを100%にあげるとかはかなりしんどいですし、多分リターンは思ったより少ないです。iOSアプリ、試作とかでわりと中変えたりすること多いし。
なのであるリリースラインに向けて、開発者（とディレクター）がよし行ける！と思える分のテストが書ければそれでよいと思います。
もちろん高いことに超したことはないです。例えば何かのSDK作るとかって場面ではカバレッジは意識した方が良いに決まっています。
けれど、無理にカバレッジをあげるよりも、大丈夫！というラインで意識する方が、いろいろ進めやすいと思います。
勘違いのないように言っておきますが、テスト書かなくともいいやろ、という事ではありません。
テストを書くのが目的にならないように、ということです。本質はそこではありません。
設計上テストが楽になるライブラリとかもあればガンガン使えばいいと思います。(CoreDataで言えばMagicalRecodeとか)</p>

<p>そして、いわゆる単体テストでビュー全体の遷移とかをカバーしようとすると相当しんどいです。
このあたりにはFrankやKIFなどのドライバー系のツールをうまく使うとよいと思います。
TheRSpecBookなんかにも出てくる二重のテストイテレーションを真似ましょう。
ただFrankやKIFについてはまだなんか話せるほど知識がないので２週目にご期待くださいということで。</p>

<p>普通に、と言ったのにはちょっと意味があって、テストフレームワークに関して言えば、アプリによって変えるべきです。
ここでいう普通のアプリは例えばユーティリティアプリだったり、何かのサービスのクライアントだったり、という感じです。
iOSでガッツリ動くゲームとか、もっと大規模なものを作りたいなら、いまのところはまだGHUnitの方がよいと思います。
逆にビューの存在しないライブラリを書くのであればBDD系のフレームワークでBDDしても全然OKだと思います。</p>

<h2>まとめ</h2>

<p>こんなこと書いてて僕が言うのもあれなんですが、テスト書くの目的にしちゃうと絶対に終わらないです。
ここのテストしんどそうだなーと思ったら、それはしんどいんだと思います。
時には人海戦術でパターン入れてみる、というのも必要だと思いますし、
結局のところ人が触らないと分からないところも多いですが、それもテストです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KiwiとSpectaの比較]]></title>
    <link href="http://yaakaito.github.com/blog/2012/10/22/kiwi-vs-specta/"/>
    <updated>2012-10-22T00:48:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/10/22/kiwi-vs-specta</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
前まではiOSのテストには主にKiwiを使っていたのですが、最近Spectaが良い感じなので使っています。
結局のところ好みになってしまうのですが、簡単に比較というか感想を。(コードはそれぞれのREADMEみてください)
どちらもRSpecに代表されるBDDスタイルの記述ができます。</p>

<ul>
<li><a href="https://github.com/allending/Kiwi">Kiwi</a></li>
<li><a href="https://github.com/petejkim/specta">Specta</a></li>
</ul>


<h2>そもそもの違い</h2>

<p>どちらも似た感じでテストを書くことができますが、そもそもとしてSpectaは自身がマッチャーなどは提供していません。
主にExpectaを使うことになると思いますが、他のものを使うことができます。
対してKiwiはモックから何からそろったフルセットのフレームワークです。</p>

<p>Spectaの方がモジュール単位に分割されているので、ライブラリとして見たときは扱い易いです。
ただ、好みのライブラリとか特にないって場合はKiwiを使った方がスムーズにいける印象です。</p>

<h2>導入のしやすさ</h2>

<p>SenTestingKitで動かすならどっちも同じくらい簡単にセットアップできます。
ただしSpectaは分割している分、importとdefineが多くなってすこし見た目が悪いです。</p>

<h2>アサーション</h2>

<p>Sepcta使う最大の理由がほぼここにあって、Expectaががんばっているんですが、Objective-Cではありがちなプリミティブに対するラッパーが必要ないこと。
Kiwiの場合は<code>theValue</code>マクロが用意されていて、これを使わなきゃいけないのでちょっとだるい。</p>

<p><code>
expect(1).to.equal(1); // Specta
[[theValue(1) should] equal:theValue(1)]; // Kiwi
</code></p>

<p>あとはObjective-Cっぽく書くか、マクロで書くかの違いくらい。僕はKiwiっぽい記述の方が好きなんですが、どうしても<code>theValue</code>書きたくないでござる症候群が・・・。
マッチャーの豊富さはどちらも同じくらいです。beNonZeroとかが分かりやすく書けるのはちょっとKiwiの方がいいかな。
あとはBooleanがExpectaは<code>beTruthy</code> <code>beFalsy</code>ですが、Kiwiが<code>beTrue</code> <code>beFalse</code> なので気をつけましょう。</p>

<h2>モックとか</h2>

<p>Kiwiは組み込みのモック、SpectaはOCMockやLRMockyが推奨されているようです。
メソッドをモックしたりとか基本的なところは一緒ですが、ちょっとずつ特徴があります。</p>

<p>Kiwiの組み込みとLRMockyは、メッセージエクスペクテーションとして<code>recieve</code>がちゃんと使えるのがよいところ。
OCMockはこのあたりがちょっとめんどくさくて、mockしてverifyしてね、という形式。notはない。</p>

<p>逆にOCMockのいいところは<code>andDo:block</code>と<code>andCall:selector</code>が非常に使いやすいところ。
Kiwiなんかは、特にBlocksが絡むとテスト用に拡張したオブジェクトに頼ったりする場面があるけど、OCMockはそれがほとんど必要ないのが良い。</p>

<p>個人的にはBlocksを結構使うので、OCMockが使いやすいですね。</p>

<h2>選ぶ基準</h2>

<p>そもそもObjective-CでBDDフレームワーク使ったことないならKiwi使っとくのが無難です。
元々GHUnitで書いていて、やっぱLRMocky使いたいわー＞＜とかならSpecta使うといいと思います。</p>

<p>ちなみに最近ホットなReactiveCocoaはSpecta使ってますね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS6のNSAttributedStringで色とか付ける]]></title>
    <link href="http://yaakaito.github.com/blog/2012/09/25/ios6-attributed-string/"/>
    <updated>2012-09-25T13:53:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/09/25/ios6-attributed-string</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
いままでは外部のライブラリを使わないとかなり面倒だった、UILabelとかに色付きの文字列の描画が、iOS6から標準サポートになりました！
便利なので使ってみましょう！！！！</p>

<h2>サンプル</h2>

<p>適当に色を付ける文章を探します、今回はgithubから「yaakaito pushed to master at yaakaito/Specs」という文章を抜き出してきました。
このうち yaakaito と yaakaito/Specs を青色にしてみようと思います。</p>

<p>コードはいつも通りgithubにあげてあります。</p>

<ul>
<li><a href="https://github.com/yaakaito/AttributedStringExample">AttributedStringExample</a></li>
</ul>


<h2>NSAttributedStringを作る</h2>

<p>実際のところ結構だるいのであんまり使ったことがない人も多いと思うのでまずはAttributedStringの作り方から。</p>

<p>作り方は大きく分けて二通りあって、</p>

<ul>
<li>小さいNSAttributedStringを複数つくって最後に繋げる</li>
<li>最初に全文でNSAttributedStringを作ってRangeで指定する</li>
</ul>


<p>という具合なのですが、多分前者の方が扱いやすいです。この記事では前者を使っています。</p>

<p>今回は色を付ける場所が二箇所＋プレーンなものが間に一つなので、全部で三つのNSAttributedStringを作って繋げます。</p>

<p>まず yaakaito の部分を作ります。</p>

<p>```objective-c
NSAttributedString *name = [[NSAttributedString alloc] initWithString:@"yaakaito"</p>

<pre><code>                                                       attributes:@{NSForegroundColorAttributeName : [UIColor blueColor]}];
</code></pre>

<p>```</p>

<p><code>NSString</code>と同じような要領で、<code>initWithString:</code>してあげて、二個目の引数に<code>attributes</code>を取ります。
この<code>attributes</code>は<code>NSDictionary</code>で、今回の例だと文字の色だけ指定しています。
他にも背景色や、フォント、アンダーラインを付けたり、影を付けたりとか、いろいろできるようです。
よく使いそうなのは <code>NSForegroundColorAttributedName</code>(文字の色) と <code>NSFontAttributeName</code>(フォント) あたりですかね。</p>

<p>せっかくなので次はフォントも指定してみましょう。 yaakaito/Specs の部分を作ります。</p>

<p>```objective-c
NSAttributedString *repository = [[NSAttributedString alloc] initWithString:@"yaakaito/Specs"</p>

<pre><code>                                                             attributes:@{ NSForegroundColorAttributeName : [UIColor blueColor],
                                                                           NSFontAttributeName : [UIFont boldSystemFontOfSize:16]} ];
</code></pre>

<p>```</p>

<p>最後に真ん中の部分を作って、連結します。</p>

<p>```objective-c
NSAttributedString *others = [[NSAttributedString alloc] initWithString:@" pushed to master at "];</p>

<p>NSMutableAttributedString *message = [[NSMutableAttributedString alloc] initWithAttributedString:name];
[message appendAttributedString:others];
[message appendAttributedString:repository];
```</p>

<p>これで、NSAttributedStringの完成です。</p>

<h2>UILabelに表示する</h2>

<p>こっちは笑えるほど簡単で、いままでは <code>label.text</code> にNSStringを入れていたものを、 <code>label.attributedText</code> にNSAttributedStringを入れるだけです。</p>

<p><code>objective-c
UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 320, 320)];
[self.view addSubview:label];
label.attributedText = message;
</code></p>

<p>こうするとさっき作ったNSAttributedStringが表示されます、便利ですね！！！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ビューテストで便利なAlertNinjaを作りました]]></title>
    <link href="http://yaakaito.github.com/blog/2012/09/05/release-alert-ninja/"/>
    <updated>2012-09-05T19:45:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/09/05/release-alert-ninja</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！前回ふざけてましたが、今回は真面目にライブラリを作りました。
といっても、毎回書くのはめんどくさいのでまとめとくか程度です。</p>

<p>みなさん！iOSのテスト書いてますか？？？
ViewControllerなんかのテストを書いてるときに、例えばGHUnitなんかを使ってたりすると、
UIAlertViewがカジュアルに飛び出てきてウザイですよね＾ー＾ー＾ー＾</p>

<p>僕はUIAlertViewは、適当なラッパークラスを作って、そこを差し替えて出ないようにすることが多いんですが、
テストの為のクラスを作ってる様なものになってしまう上に、毎回書くのがだるポヨ・・・。</p>

<p>なのでついでだしテストも出来るようにしよう、ってことで、UIAlertViewを非表示にしつつ、スパイするライブラリを作りました。</p>

<ul>
<li><a href="https://github.com/yaakaito/AlertNinja">AlertNinja</a></li>
</ul>


<h2>AlertNinjaの機能</h2>

<p>さっきも書きましたが、UIAlertViewを非表示にする、とスパイするの２つの機能を持っています。
この二つの機能はほとんど同時に使う事が多くなると思います。</p>

<p>使い方はこんな感じ、適当なViewControllerがこんな感じでshowDialogというメソッドを持っていたとすると、
```objective-c
- (void)showDialog {<br/>
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Ninja"</p>

<pre><code>                                              message:@"doron"
                                             delegate:nil
                                    cancelButtonTitle:@"YES"
                                    otherButtonTitles:nil];
</code></pre>

<p>  [alert show];
}
```</p>

<p>テストを書くときにどこかからこれを読んでいると、アラートが表示されてしまいますね。
なのでAlertNinjaを使って、アラートがでる可能性のあるところを囲みます。</p>

<p>```objective-c
- (void)testDialog
{</p>

<pre><code>[[UIAlertView ninja] spy];
[viewController showDialog];
[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<p><code>spy</code>でスタートして、<code>complete</code>で終了です、なんか忍者っぽい感じにしたかったんです！！！
こうすると、まずアラートの表示をなかった事にできます。</p>

<p>次はどんなアラートか出たか知りたいですよね、出てないかもしれません。
これは<code>report</code>というものを取得することで検証できます。</p>

<p><code>objective-c
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];
STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
</code></p>

<p><code>showedAlerts</code>は<code>spy</code>されてから表示されたUIAlertViewのリストです。(今のところこの機能しかないです。)
なので、これの<code>count</code>が0だったらアラートはなかったことになりますし、そうでなければ、その中身を検証できます。
今回の例では<code>title</code>が<code>Ninja</code>なアラートが表示されるはず、というテストになっていますね。</p>

<p>つなげるとこんな感じです。</p>

<p>```objective-c
- (void)testDialog
{</p>

<pre><code>[[UIAlertView ninja] spy];
[viewController showDialog];
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];
STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<h3>confirmもできるよ！</h3>

<p>ボタンを何個か設定して、ここを押したい、みたいなテストにも対応できます。</p>

<p>```objective-c
- (void)showConfirm {</p>

<pre><code>UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Ninja"
                                                message:@"Are you Ninja ?"
                                               delegate:self
                                      cancelButtonTitle:@"NO"
                                      otherButtonTitles:@"YES", @"I'm Kunoichi", nil];
[alert show];
</code></pre>

<p>}</p>

<ul>
<li>(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex {
  self.calledClickedButtonAtIndex = YES;
  if(buttonIndex == 0) {

<pre><code>  self.result = @"NO";
</code></pre>

  }
  else if(buttonIndex == 1) {

<pre><code>  self.result = @"YES";
</code></pre>

  }
  else if(buttonIndex == 2) {

<pre><code>  self.result = @"Kunoichi";
</code></pre>

<p>  }
}
```</p></li>
</ul>


<p>こうなってるやつに・・・</p>

<p>```objective-c
- (void)testConfirm
{</p>

<pre><code>[[[UIAlertView ninja] spy] andSelectIndexAt:2];
[viewController showConfirm];
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];

STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
STAssertEqualObjects(@"Kunoichi", viewController.result, @"result is 'Kunoichi'");

[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<p>こんな感じで、<code>spy</code>に続けて<code>andSelectIndexAt</code>でどのインデックスのボタンを押すかを指定することができます。何も設定しないとキャンセルボタン扱いになります。
もちろんDelegateも呼ばれていて、さっきのViewControllerにはさらにこんなのが続いていて、</p>

<p>```objective-c
- (void)willPresentAlertView:(UIAlertView *)alertView {</p>

<pre><code>self.calledWillPresent = YES;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)didPresentAlertView:(UIAlertView *)alertView {
  self.calledDidPresent = YES;
}</p></li>
<li><p>(void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex {
  self.calledWillDismiss = YES;
}</p></li>
<li><p>(void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex {
  self.calledDidDismiss = YES;
}
```</p></li>
</ul>


<p>全体でこんなテストが通るようになっています。
```objective-c
- (void)testConfirm
{</p>

<pre><code>[[[UIAlertView ninja] spy] andSelectIndexAt:2];
[viewController showConfirm];
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];

STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
STAssertTrue(viewController.calledWillPresent, @"called will present delegate method");
STAssertTrue(viewController.calledDidPresent, @"called did present delegate method");
STAssertTrue(viewController.calledWillDismiss, @"called will dismiss delegate method");
STAssertTrue(viewController.calledDidDismiss, @"called did dismiss delegate method");
STAssertTrue(viewController.calledClickedButtonAtIndex, @"called did clicked button at Index");
STAssertEqualObjects(@"Kunoichi", viewController.result, @"result is 'Kunoichi'");

[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<h2>流れがテストできる</h2>

<p>UIAlertViewを含んだテストができるようになったので、全体としてフィーチャーのテストがし易くなりました。
例えば <a href="https://github.com/yaakaito/NLTHTTPStubServer">NLTHTTPStubServer</a> と組み合わせると、
「APIにアクセスしたけど、404だったから"そんなものはない"というアラートだす」みたいなテストを結構スマートに書く事ができますね！！！(宣伝)
テストの為の何かをほとんどプロダクトコードに埋め込まなくとも良いのも特徴です。</p>

<h2>TODO</h2>

<p>今はこれだけで、以下には対応してない＆やろうと思っているので乞うご期待！</p>

<ul>
<li>UIActionSheetも使えるようになる</li>
<li>UIAlertViewStyleのサポート</li>
</ul>


<p>他にもこれ必要じゃね、というのがあればIssueなどに投げてください！！！</p>

<h2>というわけで</h2>

<p>よろしくお願いします！</p>

<ul>
<li><a href="https://github.com/yaakaito/AlertNinja">AlertNinja</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
