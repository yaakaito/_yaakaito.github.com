<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | yaakaito.org]]></title>
  <link href="http://yaakaito.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yaakaito.github.com/"/>
  <updated>2012-09-26T16:02:33+09:00</updated>
  <id>http://yaakaito.github.com/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS6のNSAttributedStringで色とか付ける]]></title>
    <link href="http://yaakaito.github.com/blog/2012/09/25/ios6-attributed-string/"/>
    <updated>2012-09-25T13:53:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/09/25/ios6-attributed-string</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
いままでは外部のライブラリを使わないとかなり面倒だった、UILabelとかに色付きの文字列の描画が、iOS6から標準サポートになりました！
便利なので使ってみましょう！！！！</p>

<h2>サンプル</h2>

<p>適当に色を付ける文章を探します、今回はgithubから「yaakaito pushed to master at yaakaito/Specs」という文章を抜き出してきました。
このうち yaakaito と yaakaito/Specs を青色にしてみようと思います。</p>

<p>コードはいつも通りgithubにあげてあります。</p>

<ul>
<li><a href="https://github.com/yaakaito/AttributedStringExample">AttributedStringExample</a></li>
</ul>


<h2>NSAttributedStringを作る</h2>

<p>実際のところ結構だるいのであんまり使ったことがない人も多いと思うのでまずはAttributedStringの作り方から。</p>

<p>作り方は大きく分けて二通りあって、</p>

<ul>
<li>小さいNSAttributedStringを複数つくって最後に繋げる</li>
<li>最初に全文でNSAttributedStringを作ってRangeで指定する</li>
</ul>


<p>という具合なのですが、多分前者の方が扱いやすいです。この記事では前者を使っています。</p>

<p>今回は色を付ける場所が二箇所＋プレーンなものが間に一つなので、全部で三つのNSAttributedStringを作って繋げます。</p>

<p>まず yaakaito の部分を作ります。</p>

<p>```objective-c
NSAttributedString *name = [[NSAttributedString alloc] initWithString:@"yaakaito"</p>

<pre><code>                                                       attributes:@{NSForegroundColorAttributeName : [UIColor blueColor]}];
</code></pre>

<p>```</p>

<p><code>NSString</code>と同じような要領で、<code>initWithString:</code>してあげて、二個目の引数に<code>attributes</code>を取ります。
この<code>attributes</code>は<code>NSDictionary</code>で、今回の例だと文字の色だけ指定しています。
他にも背景色や、フォント、アンダーラインを付けたり、影を付けたりとか、いろいろできるようです。
よく使いそうなのは <code>NSForegroundColorAttributedName</code>(文字の色) と <code>NSFontAttributeName</code>(フォント) あたりですかね。</p>

<p>せっかくなので次はフォントも指定してみましょう。 yaakaito/Specs の部分を作ります。</p>

<p>```objective-c
NSAttributedString *repository = [[NSAttributedString alloc] initWithString:@"yaakaito/Specs"</p>

<pre><code>                                                             attributes:@{ NSForegroundColorAttributeName : [UIColor blueColor],
                                                                           NSFontAttributeName : [UIFont boldSystemFontOfSize:16]} ];
</code></pre>

<p>```</p>

<p>最後に真ん中の部分を作って、連結します。</p>

<p>```objective-c
NSAttributedString *others = [[NSAttributedString alloc] initWithString:@" pushed to master at "];</p>

<p>NSMutableAttributedString *message = [[NSMutableAttributedString alloc] initWithAttributedString:name];
[message appendAttributedString:others];
[message appendAttributedString:repository];
```</p>

<p>これで、NSAttributedStringの完成です。</p>

<h2>UILabelに表示する</h2>

<p>こっちは笑えるほど簡単で、いままでは <code>label.text</code> にNSStringを入れていたものを、 <code>label.attributedText</code> にNSAttributedStringを入れるだけです。</p>

<p><code>objective-c
UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 320, 320)];
[self.view addSubview:label];
label.attributedText = message;
</code></p>

<p>こうするとさっき作ったNSAttributedStringが表示されます、便利ですね！！！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ビューテストで便利なAlertNinjaを作りました]]></title>
    <link href="http://yaakaito.github.com/blog/2012/09/05/release-alert-ninja/"/>
    <updated>2012-09-05T19:45:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/09/05/release-alert-ninja</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！前回ふざけてましたが、今回は真面目にライブラリを作りました。
といっても、毎回書くのはめんどくさいのでまとめとくか程度です。</p>

<p>みなさん！iOSのテスト書いてますか？？？
ViewControllerなんかのテストを書いてるときに、例えばGHUnitなんかを使ってたりすると、
UIAlertViewがカジュアルに飛び出てきてウザイですよね＾ー＾ー＾ー＾</p>

<p>僕はUIAlertViewは、適当なラッパークラスを作って、そこを差し替えて出ないようにすることが多いんですが、
テストの為のクラスを作ってる様なものになってしまう上に、毎回書くのがだるポヨ・・・。</p>

<p>なのでついでだしテストも出来るようにしよう、ってことで、UIAlertViewを非表示にしつつ、スパイするライブラリを作りました。</p>

<ul>
<li><a href="https://github.com/yaakaito/AlertNinja">AlertNinja</a></li>
</ul>


<h2>AlertNinjaの機能</h2>

<p>さっきも書きましたが、UIAlertViewを非表示にする、とスパイするの２つの機能を持っています。
この二つの機能はほとんど同時に使う事が多くなると思います。</p>

<p>使い方はこんな感じ、適当なViewControllerがこんな感じでshowDialogというメソッドを持っていたとすると、
```objective-c
- (void)showDialog {<br/>
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Ninja"</p>

<pre><code>                                              message:@"doron"
                                             delegate:nil
                                    cancelButtonTitle:@"YES"
                                    otherButtonTitles:nil];
</code></pre>

<p>  [alert show];
}
```</p>

<p>テストを書くときにどこかからこれを読んでいると、アラートが表示されてしまいますね。
なのでAlertNinjaを使って、アラートがでる可能性のあるところを囲みます。</p>

<p>```objective-c
- (void)testDialog
{</p>

<pre><code>[[UIAlertView ninja] spy];
[viewController showDialog];
[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<p><code>spy</code>でスタートして、<code>complete</code>で終了です、なんか忍者っぽい感じにしたかったんです！！！
こうすると、まずアラートの表示をなかった事にできます。</p>

<p>次はどんなアラートか出たか知りたいですよね、出てないかもしれません。
これは<code>report</code>というものを取得することで検証できます。</p>

<p><code>objective-c
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];
STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
</code></p>

<p><code>showedAlerts</code>は<code>spy</code>されてから表示されたUIAlertViewのリストです。(今のところこの機能しかないです。)
なので、これの<code>count</code>が0だったらアラートはなかったことになりますし、そうでなければ、その中身を検証できます。
今回の例では<code>title</code>が<code>Ninja</code>なアラートが表示されるはず、というテストになっていますね。</p>

<p>つなげるとこんな感じです。</p>

<p>```objective-c
- (void)testDialog
{</p>

<pre><code>[[UIAlertView ninja] spy];
[viewController showDialog];
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];
STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<h3>confirmもできるよ！</h3>

<p>ボタンを何個か設定して、ここを押したい、みたいなテストにも対応できます。</p>

<p>```objective-c
- (void)showConfirm {</p>

<pre><code>UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Ninja"
                                                message:@"Are you Ninja ?"
                                               delegate:self
                                      cancelButtonTitle:@"NO"
                                      otherButtonTitles:@"YES", @"I'm Kunoichi", nil];
[alert show];
</code></pre>

<p>}</p>

<ul>
<li>(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex {
  self.calledClickedButtonAtIndex = YES;
  if(buttonIndex == 0) {

<pre><code>  self.result = @"NO";
</code></pre>

  }
  else if(buttonIndex == 1) {

<pre><code>  self.result = @"YES";
</code></pre>

  }
  else if(buttonIndex == 2) {

<pre><code>  self.result = @"Kunoichi";
</code></pre>

<p>  }
}
```</p></li>
</ul>


<p>こうなってるやつに・・・</p>

<p>```objective-c
- (void)testConfirm
{</p>

<pre><code>[[[UIAlertView ninja] spy] andSelectIndexAt:2];
[viewController showConfirm];
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];

STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
STAssertEqualObjects(@"Kunoichi", viewController.result, @"result is 'Kunoichi'");

[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<p>こんな感じで、<code>spy</code>に続けて<code>andSelectIndexAt</code>でどのインデックスのボタンを押すかを指定することができます。何も設定しないとキャンセルボタン扱いになります。
もちろんDelegateも呼ばれていて、さっきのViewControllerにはさらにこんなのが続いていて、</p>

<p>```objective-c
- (void)willPresentAlertView:(UIAlertView *)alertView {</p>

<pre><code>self.calledWillPresent = YES;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)didPresentAlertView:(UIAlertView *)alertView {
  self.calledDidPresent = YES;
}</p></li>
<li><p>(void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex {
  self.calledWillDismiss = YES;
}</p></li>
<li><p>(void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex {
  self.calledDidDismiss = YES;
}
```</p></li>
</ul>


<p>全体でこんなテストが通るようになっています。
```objective-c
- (void)testConfirm
{</p>

<pre><code>[[[UIAlertView ninja] spy] andSelectIndexAt:2];
[viewController showConfirm];
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];

STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
STAssertTrue(viewController.calledWillPresent, @"called will present delegate method");
STAssertTrue(viewController.calledDidPresent, @"called did present delegate method");
STAssertTrue(viewController.calledWillDismiss, @"called will dismiss delegate method");
STAssertTrue(viewController.calledDidDismiss, @"called did dismiss delegate method");
STAssertTrue(viewController.calledClickedButtonAtIndex, @"called did clicked button at Index");
STAssertEqualObjects(@"Kunoichi", viewController.result, @"result is 'Kunoichi'");

[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<h2>流れがテストできる</h2>

<p>UIAlertViewを含んだテストができるようになったので、全体としてフィーチャーのテストがし易くなりました。
例えば <a href="https://github.com/yaakaito/NLTHTTPStubServer">NLTHTTPStubServer</a> と組み合わせると、
「APIにアクセスしたけど、404だったから"そんなものはない"というアラートだす」みたいなテストを結構スマートに書く事ができますね！！！(宣伝)
テストの為の何かをほとんどプロダクトコードに埋め込まなくとも良いのも特徴です。</p>

<h2>TODO</h2>

<p>今はこれだけで、以下には対応してない＆やろうと思っているので乞うご期待！</p>

<ul>
<li>UIActionSheetも使えるようになる</li>
<li>UIAlertViewStyleのサポート</li>
</ul>


<p>他にもこれ必要じゃね、というのがあればIssueなどに投げてください！！！</p>

<h2>というわけで</h2>

<p>よろしくお願いします！</p>

<ul>
<li><a href="https://github.com/yaakaito/AlertNinja">AlertNinja</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOSアプリからGithubOAuth使うの見直している]]></title>
    <link href="http://yaakaito.github.com/blog/2012/09/03/re-github-oauth/"/>
    <updated>2012-09-03T04:53:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/09/03/re-github-oauth</id>
    <content type="html"><![CDATA[<p>こんばんは！うきょーです、非常に眠いです。
<a href="http://yaakaito.github.com/blog/2012/09/01/github-oauth/">前回</a>わりとカジュアルな感じでOAuthしたんですが、
<a href="https://twitter.com/azu_re/status/241853336964444160">こういうツイート</a>をみて、<code>state</code>のこと書いてなかったからそのことかなーと思ったんですが、
よくよく考えてみれば、起動スキーマ直接叩かれたらなんか起こりそうだよなーとかいろいろ気になってきたのでずっとOAuth2でググったりしてた。</p>

<h2>そもそも</h2>

<p>前回の感じになったのが単純に、メールとかパスワード入力するのがだるいしあんまりさせたくないなー、OAuthあったなーいけんじゃねー、という感じの理由。
<a href="http://developer.github.com/v3/oauth/">OAuth | GitHub API</a>を見てて、非Webアプリケーション向けの最初はBasic認証使って〜がやりたくなった感じですね。
で、本来はBasic認証一回使ってーの方がいいと思うんですが、いろいろクライアントなライブラリを見ていると、<code>Client Secret</code>を引数に取ったりしてて、
じゃあこっちでもいいのかなーとなった。</p>

<h2>本当か？</h2>

<p>で、気になって何個かGithubOAuth使ってそうなアプリを探してみたんだけど、hojokiなんかは<code>UIWebView</code>使ってやってるっぽいしやっぱこっちでいいんかなーと。
けど<code>UIWebView</code>の作り上URLとか自分で出さないといけない訳ですが、それすら偽装してかなりそれっぽく見せる事は可能なので、
僕が使う側だったらあんまり使いたくないなーと思ってしまった。一緒に変なJSとか走らされてもやだなーと思ったり。(他の人がどう思ってるのかは知らないですが)
それだったらSafariに飛ばせばいいじゃん、でcallbackにカスタムスキームでー、でできたわけ。で、そこに弱そうなところがあるなら一旦塞ぐかーという感じで作ったのを適当にアップデート。</p>

<ul>
<li><a href="https://github.com/yaakaito/GithubOAuthExample">GithubOAuthExample</a></li>
</ul>


<p>やったのは、（今回はダミーだけど）<code>state</code>の付加と、OAuthしている時以外は起動スキーマを無効化した。（今は単純にabortしてるだけ）
あとは本番では起動スキーマが使える時間とかも短くしぼったり、もやろうかなと思っていて、
これでよっぽどな感じじゃない限りはインジェクションとかは大丈夫そうな感じがする。
起動スキーマ持って行かれたときもまあ<code>Client Secret</code>バレなきゃだいじょ・・・そもそも<code>Secret</code>持っていいの？
一応すごいがんばりをすれば秘密じゃなくなる気がする。</p>

<h2>ライブラリにみるOAuth</h2>

<p>さっきも書いたけどOAuthClientと名を打ってるライブラリは<code>Client ID</code>と<code>Client Secret</code>を要求していることが多いし、
プラスアルファでアカウントとパスワードも要求してたりする。
クライアント仲間ってことでJSも何個か見てみたんですが、
カジュアルにSecretむき出し・・・秘密とは・・・みたいな感じになってて何を信じればいいのか分からなくなってきた。（まあTitaniumとかで使ってねってことだとは思うんだけど・・・）</p>

<h2>Implicit Flow</h2>

<p>さまよってるうちに「<a href="http://www.sakimura.org/2012/02/1487/">単なる OAuth 2.0 を認証に使うと、車が通れるほどのどでかいセキュリティー・ホールができる</a>」
というのに出会った、関係ありそうなので読んでみたんだけど、アプリケーションの認証として使うから駄目なのであって、
クライアントとして認可される場合にはまあ大丈夫か、ってことでいいのかな。
一旦は置いておいて良さそうだけど、あとで自分で見直したときのメモ。</p>

<h2>で</h2>

<p>正直どうやるのが理想なのかよくわからなくなってきたね、ずばっと教えてエロい人！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOSアプリでGithubにOAuthする]]></title>
    <link href="http://yaakaito.github.com/blog/2012/09/01/github-oauth/"/>
    <updated>2012-09-01T19:12:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/09/01/github-oauth</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
Githubと連動したアプリを作りたくなったので、GithubのOAuthをiOSアプリでやってみました。</p>

<ul>
<li><a href="http://developer.github.com/v3/oauth/">OAuth | GitHub API</a></li>
<li><a href="https://github.com/yaakaito/GithubOAuthExample">GithubOAuthExample</a></li>
</ul>


<h2>アプリケーションを登録</h2>

<p>[AccountSettings]-> [Applications] -> [Register new application]からアプリケーションを登録します。
この時にCallback URLにカスタムスキームを入れる事ができるので、</p>

<p><code>
yourapp://oauth
</code></p>

<p>みたいなコールバックを指定します。そうするとIDがもらえるのでこれで登録は終わりです。</p>

<h2>Githubへログインしてもらう</h2>

<p>OAuthなので、Safariを開いてacceptしてもらいましょう。パスワード入力してもらってJS使って押すとか、やめましょうね。
発行されたIDのうちClient IDをくっつけて</p>

<p><code>
NSString *scope = @"public_repo,gist";
NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@"https://github.com/login/oauth/authorize?client_id=%@&amp;scope=%@",kClientId, scope]];
[[UIApplication sharedApplication] openURL:url];
</code></p>

<p>みたいな具合で、Safariを起動します。
別にUIWebViewでもいいと思いますが、専用のビュー作るのもめんどくさいし、ちゃんとGithubなことを証明するのもだるいので、Safariでいいと思います。</p>

<h2>コールバックを拾ってアクセストークンをリクエスト</h2>

<p>カスタムスキームからの起動で<code>code</code>がやってくるので、これを持って</p>

<p><code>
/login/oauth/access_token
</code></p>

<p>へPOSTします。</p>

<p>あとはkey-value形式でトークンが返ってくるので、それを使うだけです。簡単ですね。トークンはちゃんとキーチェインとかに入れてあげましょう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[便利なライブラリHullToRefresh作った]]></title>
    <link href="http://yaakaito.github.com/blog/2012/08/31/hull-to-refresh/"/>
    <updated>2012-08-31T06:31:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/08/31/hull-to-refresh</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！みなさんPullToRefresh使ってますか？便利ですよね。
けど、引っ張って更新、そろそろ飽きてきませんか？てゆーか、なんでわざわざ引っ張らなきゃいけないんですか？</p>

<p>それを解決するために、HullToRefreshというライブラリを作りました。名前はギャグっぽいですがマジメです。</p>

<ul>
<li><a href="https://github.com/yaakaito/HullToRefresh">HullToRefresh</a></li>
</ul>


<p>振るとRefreshはその名の通り、iPhoneを大きく振るとイベントが飛んでくるライブラリです、すごく、すごく便利ですね。
なんてったって画面に触る必要がありません、指を動かす必要もありません。更新したいな、と思ったときにはiPhoneでフリフリシェイクすればいいのです、楽しいですね。
電車に乗っているときは自動で揺れを検知し、空気を読んで更新をしてくれます。なんて便利なんでしょう、指による入力なんて、もはや時代遅れなのです。
このすばらしいアイデアの使い方はすごく簡単で、initしてフルフルNotificationを登録するだけです！！！</p>

<p>```objective-c
[HullToRefresh sharedHullHull];
[[NSNotificationCenter defaultCenter] addObserver:self</p>

<pre><code>                                     selector:@selector(callback)
                                         name:kDidHullHullNotification
                                       object:nil];
</code></pre>

<p>```</p>

<p>ね？簡単でしょう？サンプルについてくるアプリはこんな感じになります。</p>

<p><img src="/images/hullhull.png"></p>

<p>すばらしいライブラリなので、是非使ってみてください！使いどころとしては、空気を読まないアプリケーション作るときに便利です。</p>

<h3>まとめ</h3>

<p>完全にギャグです。タイポしたときとかに出るように割と悪意を持って作っていますが、ただのギャクです。</p>
]]></content>
  </entry>
  
</feed>
