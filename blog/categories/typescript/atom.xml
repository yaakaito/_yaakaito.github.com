<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TypeScript | yaakaito.org]]></title>
  <link href="http://yaakaito.org/blog/categories/typescript/atom.xml" rel="self"/>
  <link href="http://yaakaito.org/"/>
  <updated>2013-05-21T00:47:05+09:00</updated>
  <id>http://yaakaito.org/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TypeScriptでのコンストラクタ関数の扱い]]></title>
    <link href="http://yaakaito.org/blog/2013/05/20/typescript-constructor-function/"/>
    <updated>2013-05-20T16:44:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/20/typescript-constructor-function</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
JavaScriptでコンストラクタ関数を</p>

<p><code>javascript
var Hoge = function(){ }
var Fuga = Hoge;
var fuga = new Fuga();
</code></p>

<p>こういう感じに使うのって割とやると思うんだけど、TypeScriptだとどういう扱いになってるのか試してみる。</p>

<p>tscは<code>0.9 alpha</code></p>

<h2>とりあえず</h2>

<p>こんな感じにしてみる</p>

<p>```javascript
class Hoge {</p>

<pre><code>constructor() { }
method() { }
</code></pre>

<p>}</p>

<p>var Hoge2 = Hoge;
```</p>

<p>これは普通に通って、JavaScriptだとこうなる、普通。</p>

<p>```javascript
var Hoge = (function () {</p>

<pre><code>function Hoge() {
}
Hoge.prototype.method = function () {
};
return Hoge;
</code></pre>

<p>})();</p>

<p>var Hoge2 = Hoge;
```</p>

<p>ここで<code>Hoge2</code>がどういう型になっているかというと、こうなっている。</p>

<p><code>
new() =&gt; Hoge
</code></p>

<p>コンストラクタで引数を取るようにするとこうなる</p>

<p>```javascript
class Hoge {</p>

<pre><code>constructor(public fuga: string) { }
</code></pre>

<p>}
```</p>

<p><code>javascript
new(fuga: string) =&gt; Hoge
</code></p>

<p>これは普通に型として使えるので、厳密に書くと、</p>

<p><code>javascript
var Hoge2:new(fuga: string) =&gt; Hoge = Hoge;
</code></p>

<p>こういう感じになる。とりあえず問題なく扱える感じがする。</p>

<h2>Genericsとの組み合わせとか</h2>

<p>結構感動したのがこれ。</p>

<p>```javascript
class Hoge {</p>

<pre><code>constructor() { }
</code></pre>

<p>}</p>

<p>class Fuga<T> {</p>

<pre><code>constructor(public TT: new() =&gt; T) { } 
public create(): T {
    return new this.TT();
}
</code></pre>

<p>}
```</p>

<p>こういう感じにすることができる。
で、これは、</p>

<p><code>javascript
var fuga = new Fuga(Hoge);
</code></p>

<p>という感じにすると推論される。コンストラクタの形の違うクラスを使ってみると、</p>

<p>```javascript
class Foo {</p>

<pre><code>constructor(public fuga: string) { }   
</code></pre>

<p>}</p>

<p>var fuga2 = new Fuga(Foo);
```</p>

<p><code>
error TS2081: Supplied parameters do not match any signature of call target.
</code></p>

<p>すごいぞTypeScript。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptのGenerics試してみる]]></title>
    <link href="http://yaakaito.org/blog/2013/05/16/typescript-generics/"/>
    <updated>2013-05-16T06:34:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/16/typescript-generics</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！TypeScript0.9alpha使える環境作ったのでジェネリクス試すよ！
<a href="https://github.com/yaakaito/typescript-dddbase">typescript-dddbase</a>というのをはじめていたので、これを0.9対応することを見越して、<code>Identity</code> <code>Entity</code> <code>Repository</code>をジェネリクス使って考えてみる。</p>

<h2>使い方</h2>

<p><code>class</code>か<code>interface</code>で名前与えられたものと、<code>string</code> <code>number</code> なんかを使う事が出来ます。
シンタックスはよくある感じで、特に違和感もない。</p>

<p>```javascript
interface Identity<T> {</p>

<pre><code>value: T;
</code></pre>

<p>}</p>

<p>class NumberIdentity implements Identity<number> {</p>

<pre><code>constructor(public value: number) { }
</code></pre>

<p>}</p>

<p>class StringIdentity implements Identity<string> {</p>

<pre><code>constructor(public value: string) { }
</code></pre>

<p>}</p>

<p>var numberIdentity = new NumberIdentity(1);
var stringIdentity = new StringIdentity("A");
```</p>

<p>クラスのときはこんな感じ。</p>

<p>```javascript
class Entity<T extends Identity> {</p>

<pre><code>constructor(public identity: T) { }
</code></pre>

<p>}
```</p>

<h2>推論</h2>

<p>上の<code>Entity</code>みたいなやつの場合、コンストラクタで推論してくれる。
さっき作った<code>numberIdentity</code>を使ってみる。</p>

<p><code>javascript
var entity = new Entity(numberIdentity);
</code></p>

<p>これの<code>identity</code>を<code>stringIdentity</code>で上書きしようとすると、</p>

<p><code>javascript
var entity = new Entity(numberIdentity);
entity.identity = stringIdentity;
</code></p>

<p>こうなる</p>

<p><code>
error TS2012: Cannot convert 'StringIdentity' to 'NumberIdentity':
  Types of property 'value' of types 'StringIdentity' and 'NumberIdentity' are incompatible.
</code></p>

<p>やりましたね！</p>

<p>もちろんですが、こういう風にも書けます。</p>

<p><code>javascript
var entity = new Entity&lt;NumberIdentity&gt;(numberIdentity);
</code></p>

<p>推論できない場合には明示的に書く必要があります。</p>

<h2>ネスト</h2>

<p>ネストも出来ます。<code>Repository</code>を考えたときに、これは<code>Entity&lt;T&gt;</code>の集合なので、</p>

<p><code>javascript
class Repository&lt;E extends Entity&lt;I&gt;, I extends Identity&gt; {
}
</code></p>

<p>こう書けます。
本体もとりあえず書いてみる。(めんどくさいし説明用なので、ただ<code>value</code>にいれて返すだけにした)</p>

<p>```javascript
class Repository<E extends Entity<I>, I extends Identity> {</p>

<pre><code>public value: E = null;

store(entity: E) {
    this.value = entity;
}

findByIdentity(identity: I): E {
    return this.value;
}
</code></pre>

<p>}
```</p>

<p>これの場合は推論できないので、このクラスを直接使う場合は、</p>

<p><code>javascript
var repository = new Repository&lt;Entity&lt;NumberIdentity&gt;, NumberIdentity&gt;();
repository.store(entity);
</code></p>

<p>こんな感じになります。</p>

<h2>もうちょっと書いてみる</h2>

<p>ここまでのを元に<code>Person</code>モデルと<code>PersonRepository</code>を作ってみる、実装はない。</p>

<p>```javascript
class Person extends Entity<NumberIdentity> {</p>

<pre><code>constructor(public identity: NumberIdentity) {
    super(identity);
}
</code></pre>

<p>}</p>

<p>class PersonRepository extends Repository&lt;Person, NumberIdentity> {
}</p>

<p>var person = new Person(numberIdentity);
var personRepository = new PersonRepository();
repository.store(person);
```</p>

<p>こんな感じ。</p>

<h2>関数</h2>

<p>引数の前に書く。</p>

<p><code>
&lt;T&gt;(x: T) =&gt; x
</code></p>

<p>みたいな</p>

<h2>ところで・・・</h2>

<p>試してて途中で気づいたんだけど、</p>

<p>```javascript
class Hoge {</p>

<pre><code>public a: string;
</code></pre>

<p>}
class Fuga {</p>

<pre><code>public a: string;
</code></pre>

<p>}</p>

<p>var hoge: Hoge = new Fuga();
```</p>

<p>これが通るようになってた。で、2時間くらいハマってた。空のクラス定義にすると<code>Array&lt;Hoge&gt;</code>に<code>array.push("ばーか")</code>とかできるよ、やりましたね。
試したのは<code>release-0.9.0-alpha</code>と<code>develop@c3835ab</code>で、どっちも通った。</p>

<p>これって<code>0.8.x</code>だと<code>Cannot convert 'Fuga' to 'Hoge'</code>とかで通らなくて、やりたいなら<code>Interface</code>通してね、
みたいな感じになってたと思うんだけど、変更あったんだろうか？
いくらか探してみたんだけど、それっぽいものを見つけられなくて、よくわかっていない。
眠いし見落としてる可能性もあるので、知ってる人いたら教えてほしい。
挙動は分からんでもないし、バグかなーと思ったんだけど、さすがにテストでこけるんじゃぁ・・・的な。ツッコミなければ投げるつもり。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScript0.9alphaをMac+Gruntで使うよ]]></title>
    <link href="http://yaakaito.org/blog/2013/05/16/using-typescript-09-on-mac-and-grunt/"/>
    <updated>2013-05-16T00:52:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/16/using-typescript-09-on-mac-and-grunt</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScript0.9alphaがちょっと前に出ましたね。
npm経由でインストールできなくてだるいので使ってなかったんですが、0.9の機能試したくなったのでがんばって使えるようにすることにしました。</p>

<h2>TypeScriptのコンパイル</h2>

<p>developをコンパイルすると大体いい感じだと思うのでそうしましょう。
この辺は<a href="http://typescript.codeplex.com/wikipage?title=Build%20The%20Source&amp;referringTitle=Home">本家にも載ってますね</a>。リポジトリでけぇ。
<code>jake</code>が必要なのでいれます。</p>

<p><code>
$ npm install -g jake
$ git clone https://git01.codeplex.com/typescript
$ cd typescript
$ git checkout develop
$ jake local
$ chmod +x bin/tsc
</code></p>

<p>これで <code>typescript/bin/tsc</code> が使えるようになります。</p>

<p>```
$ ./bin/tsc
Version 0.9.0.0
Syntax:   tsc [options] [file ..]</p>

<p>Examples: tsc hello.ts</p>

<pre><code>      tsc --out foo.js foo.ts
      tsc @args.txt
</code></pre>

<p>// ...
```</p>

<p>やったー！！</p>

<h2>grunt-typescript</h2>

<p>普段のビルドは<code>grunt-typesript</code>を使っているので、これが動くと便利な訳です。
どういう指定になってるのかなーと見てみたら、</p>

<p>```javascript
resolveTypeScriptBinPath = function (currentPath, depth) {</p>

<pre><code>var targetPath = path.resolve(__dirname,
    (new Array(depth + 1)).join("../../"),
    "../node_modules/typescript/bin");
if (path.resolve(currentPath, "node_modules/typescript/bin").length &gt; targetPath.length) {
    return;
}
if (fs.existsSync(path.resolve(targetPath, "typescript.js"))) {
    return targetPath;
}

return resolveTypeScriptBinPath(currentPath, ++depth);
</code></pre>

<p>}
```</p>

<p>なるほど？
つまりはこいつのnode_moduleに入ってるtypescriptを丸ごと置き換えちゃえば動くんじゃないかなーーーーーーーーやっちゃえーーーーーー＾ー＾</p>

<p><code>
$ rm /path/to/grunt-typescript/node_modules/typescript
$ cp -r typescript /path/to/grunt-typescript/node_modules
</code></p>

<p>動いた気がする、これはひどい。</p>

<p>適当なファイルをコンパイルしてみる。</p>

<p>```
Running "typescript:compile" (typescript) task
Warning: Object module Hoge {</p>

<pre><code>export class Fuga {
    constructor(public a: string) { }
}
</code></pre>

<p>} has no method 'contents' Use --force to continue.</p>

<p>Aborted due to warnings.
```</p>

<p>うーん、なんか駄目っぽい。
普通に<code>tsc</code>でコンパイルする分にはいけるので、追う意味あんまりないし、<code>tsc</code>でコンパイルしよう。</p>

<h2>grunt-exec</h2>

<p><code>
$ npm install grunt-exec --save-dev
</code></p>

<p>Gruntfileはこんな感じで</p>

<p>```coffeescript
tsc = "path/to/tsc"</p>

<p>module.exports = (grunt) -></p>

<pre><code>grunt.initConfig
    pkg: grunt.file.readJSON 'package.json'
    exec:
        compile:
            cmd: -&gt; "#{tsc} --out compiled/src --declaration src/*.ts"
        test:
            cmd: -&gt; "#{tsc} --out compiled/test test/*.ts"

grunt.loadNpmTasks 'grunt-exec'
</code></pre>

<p>```</p>

<p>コンパイルできた！</p>

<p>あとはgruntのエイリアスよしなにして、とりあえずこれで使えそう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptのコーディング規約を考える]]></title>
    <link href="http://yaakaito.org/blog/2013/05/05/typescript-codeconventions/"/>
    <updated>2013-05-05T19:30:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/05/typescript-codeconventions</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScript書いてますか？？？おすすめです！！！
ところでTypeScriptのコーディング規約がよくわからなかったので、コンパイラをみてきました。
JavaScriptほどあーだーこーだというものでもないと思うので、ほんとにコーディング規約みたいな感じです。</p>

<h2>基本的なところ</h2>

<h3>インデント</h3>

<ul>
<li>ソフトインデントで4個</li>
</ul>


<h3>1行の文字数</h3>

<p>これはコンパイラの方は結構自由に感じた・・・。
ので、JavaScriptよりはJavaとか参考にした方がいいだろうってことで <a href="http://www.oracle.com/technetwork/java/javase/documentation/codeconventions-136091.html#313">Oracle</a> のを参考にすることに。</p>

<ul>
<li><s>1行は80文字</s></li>
</ul>


<h4>追記</h4>

<p>いまどき80文字じゃなくてよくない？というツッコミがあったので考え直した。</p>

<p>僕は、80文字で結構いけるんじゃないかなーと思っている。なのであんまり80文字なってる理由については深追いしてない。
というのも、80文字あったら結構書けるよなーと思うので、オーバーするなら分割する基準になるんでは、というところが大きい。
ただ、シンタックス上長くなっちゃうよねーというのも、もちろんあると思う。(下の方で85文字のがある。)
その都度柔軟に変えばよいというのも、その通りだけど、自分が書いていくのにある程度基準がほしいなーとは思う。</p>

<p>元々は80文字しか表示できないから系(表現あれだけど)の理由らしいんだけど、じゃあ今だとどうなのかなと考えてみた。
で、僕はGithubをよく使う方だと思うので(エンタープライズ含め)、そこで横スクロールしちゃうのはやだなーと思った。
というわけでGithubの100%表示で何文字入るのか数えてみた、122文字らしい。</p>

<p>なので個人で書く範囲では</p>

<ul>
<li>1行は120文字</li>
</ul>


<p>ということにしようかなと思う。</p>

<p>改行ルールとかもこっちを参考にして、</p>

<ul>
<li>コンマのあと</li>
<li>オペレーターの前</li>
<li>改行するときは8個インデント</li>
</ul>


<h3>型の為のコロンの位置</h3>

<ul>
<li>変数名にくっつけてスペースを一つ入れる</li>
</ul>


<p>```javascript
(name: string) => { }</p>

<p>var name: string = Names.at(0);</p>

<p>name: string = null;
```</p>

<h3>関数の返り値</h3>

<ul>
<li>voidの時は宣言しない</li>
</ul>


<p>```
voidFunction() {</p>

<p>}</p>

<p>stringFunction(): string {</p>

<pre><code>return "hoge";
</code></pre>

<p>}
```</p>

<h2>命名規則</h2>

<ul>
<li>変数/関数/メソッドはキャメルケール</li>
</ul>


<h3>クラスとモジュールの命名規則</h3>

<ul>
<li>アッパーキャメルケース</li>
</ul>


<p>```javascript
module Hoge {</p>

<pre><code>class HogeClass {
    // ...
}
</code></pre>

<p>}
```</p>

<h3>Enumの命名規則</h3>

<ul>
<li>アッパーキャメルケース</li>
</ul>


<p>```javascript
enum Fruit {</p>

<pre><code>Apple,
Orange,
KiwiFruit
</code></pre>

<p>}
```</p>

<h3>定数の命名規則</h3>

<ul>
<li>大文字スネークケース</li>
</ul>


<p><code>javascript
var HOGE_FUGA = 'a';
</code></p>

<h3>インターフェイスの命名規則</h3>

<ul>
<li>頭に <code>I</code> をつける</li>
</ul>


<p>```javascript
interface IHoge {</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<h2>varの型宣言</h2>

<ul>
<li>基本的には宣言しない</li>
<li>anyとして返されるものに対してには宣言する</li>
</ul>


<p><code>
var name = 'yaakaito';
var name: string = names[0];
</code></p>

<h2>即時関数</h2>

<p>よくわからなかった。JavaScriptのまんま書いてある感じもする。</p>

<p>```javascript
(function(x) {</p>

<pre><code>return x * x
</code></pre>

<p>})(10);
```</p>

<p>TypeScript的にはこんな感じなんだろうか？</p>

<p><code>javascript
(x =&gt; x * x)(10)
</code></p>

<h2>コンストラクタでのプロパティの宣言</h2>

<ul>
<li>コンストラクタに渡された値をそのまま利用する場合はコンストラクタの引数で宣言する</li>
</ul>


<p>```
class Person {</p>

<pre><code>fullName: string;

constructor(public firstName: string, public lastName: string, private age: number) {
    this.fullName = [firstName, lastName].join(" ");
}
</code></pre>

<p>}
```</p>

<h2>追加</h2>

<ul>
<li>プロパティやメソッドが<code>public</code>である場合、<code>public</code>を明記しない。

<ul>
<li>コンストラクタでのプロパティ宣言は明記する。</li>
</ul>
</li>
</ul>


<p>これは書いても書かなくともよくて(省略された場合は自動的に<code>public</code>)、好みだと思うんだけど、最近Scalaを書くようになって、あっちが<code>public</code>はない、というルールなので、それに合わせる事に。</p>

<p>```javascript
class Person {</p>

<pre><code>fullName: string;
private room: Room = null;
constructor(public firstName: string, public lastName: string, private age: number) {
    this.fullName = [firstName, lastName].join(" ");
}
openDoor() { }
private lookDoor() { }
</code></pre>

<p>}
```</p>

<h2>こんな感じかなぁ</h2>

<p>追加あれば書く。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptのInterfaceとStructural Subtyping]]></title>
    <link href="http://yaakaito.org/blog/2013/05/02/typescript-subtyping/"/>
    <updated>2013-05-02T02:58:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/02/typescript-subtyping</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScriptにはInterfaceとStructural Subtypingがあるのでそれについて書こうと思います。まだ0.8.x系です。</p>

<h2>Interface</h2>

<p>JavaやC#でいうinterfaceと似ていますが、ある形をしたオブジェクトに対する別名というのが正しいと思います。</p>

<p>```javascript
interface Rider {</p>

<pre><code>name: string;
henshin: () =&gt; void;
</code></pre>

<p>}</p>

<p>var wizard: Rider = {</p>

<pre><code>name: '仮面ライダーウィザード',
henshin: () =&gt; {
    console.log('ｼｬﾊﾞﾄﾞｭﾋﾞﾀｯﾁﾍﾝｼｰﾝ!');
}
</code></pre>

<p>}
```</p>

<p>こうすると <code>wizard</code> は <code>Rider</code> であることになります。
JavaScriptには存在しないシンタックスなので、コンパイルするとinterfaceは当然ですが消えます。</p>

<p>```javascript
var wizard = {</p>

<pre><code>name: '仮面ライダーウィザード',
henshin: function () {
    console.log('ｼｬﾊﾞﾄﾞｭﾋﾞﾀｯﾁﾍﾝｼｰﾝ!');
}
</code></pre>

<p>};
```</p>

<p>同じように <code>beast</code> も作ってみます。</p>

<p>```javascript
var beast: Rider = {</p>

<pre><code>name: '仮面ライダービースト',
henshin: () =&gt; {
    console.log('L・I・O・N!ﾗｲｵｰﾝ!');
}
</code></pre>

<p>}
```</p>

<p>やりましたね。</p>

<p>このinterfaceはそのまま型のように扱うことが出来るので、</p>

<p>```javascript
var please = function(rider: Rider) {</p>

<pre><code>rider.henshin();
</code></pre>

<p>}</p>

<p>please(wizard);
please(beast);
```</p>

<p>こういう風に使う事も出来ます。便利ですね。</p>

<p>もちろんclassにimplementsすることも出来ます。</p>

<p>```javascript
class WizardInfinity implements Rider {</p>

<pre><code>public name: string = '仮面ライダーウィザード インフィニティ';

public henshin(): void {
    console.log('ﾋｰｽｲﾌｰﾄﾞｰﾎﾞｰｻﾞﾊﾞﾋﾞｭｰﾄﾞｺﾞｰﾝ!');
}
</code></pre>

<p>}
```</p>

<p>実装が欠けている場合は、こういう感じのエラーになります。</p>

<p><code>
Class 'WizardInfinity' declares interface 'Rider' but does not implement it: Type 'WizardInfinity' is missing property 'name' from type 'Rider'
Class 'WizardInfinity' declares interface 'Rider' but does not implement it: Type 'WizardInfinity' is missing property 'henshin' from type 'Rider'
</code></p>

<p>Functionにも適用することができて、</p>

<p>```javascript
class Ring {</p>

<pre><code>public name: string = 'ドライバーオンウィザードリング';
</code></pre>

<p>}</p>

<p>interface DriverOn {</p>

<pre><code>(ring: Ring): void;
</code></pre>

<p>}</p>

<p>var driverOn: DriverOn = function(ring: Ring) {</p>

<pre><code>if (ring.name === 'ドライバーオンウィザードリング') {
    console.log('ﾄﾞﾗｲﾊﾞｰｵｰﾝｯ!ﾌﾟﾘｨｨｨｽﾞ!');
}
</code></pre>

<p>}
```</p>

<p>こういう感じに書けます。これだけだと別に利点が分からなくて、</p>

<p>```javascript
var driverOn = (ring: Ring): void => {</p>

<pre><code>if (ring.name === 'ドライバーオンウィザードリング') {
    console.log('ﾄﾞﾗｲﾊﾞｰｵｰﾝｯ!ﾌﾟﾘｨｨｨｽﾞ!');
}
</code></pre>

<p>}
```</p>

<p>これで別によくね、となるんですが、いうならオーバーロードみたいなことが出来るのでちょっと便利です。こういう感じで書く事が出来るので、</p>

<p>```javascript
interface DriverOn {</p>

<pre><code>(ring: Ring): void;
(love: Love): void;
</code></pre>

<p>}
```</p>

<p>全体でこんな感じになってると、<code>Phantom</code>を受け付けません。</p>

<p>```javascript
class Ring {</p>

<pre><code>public name: string = 'ドライバーオンウィザードリング';
</code></pre>

<p>}</p>

<p>class Love {</p>

<pre><code>public target: string = 'こよみ';
</code></pre>

<p>}</p>

<p>class Phantom {</p>

<pre><code>public original: string = 'ミサ';
</code></pre>

<p>}</p>

<p>interface DriverOn {</p>

<pre><code>(ring: Ring): void;
(love: Love): void;
</code></pre>

<p>}</p>

<p>var driverOn: DriverOn = function(power: any) {</p>

<pre><code>if (power instanceof Ring &amp;&amp; power.name === 'ドライバーオンウィザードリング') {
    console.log('ﾄﾞﾗｲﾊﾞｰｵｰﾝｯ!ﾌﾟﾘｨｨｨｽﾞ!');
}
else if (power instanceof Love &amp;&amp; power.target === 'こよみ') {
    console.log('ｲﾝｯﾌｨﾆﾃｨｨ!ｲﾝｯﾌｨﾆﾃｨｨ!ｲﾝｯﾌｨﾆﾃｨｨ!ｲﾝｯﾌｨﾆﾃｨｨ!');
}
</code></pre>

<p>}</p>

<p>driverOn(new Ring());
driverOn(new Love());
driverOn(new Phantom()); // Supplied parameters do not match any signature of call target
```</p>

<p>あとは <code>interface A extends B</code> と出来たり、同じ<code>interface</code>を2回定義する事で拡張できたりします。</p>

<h2>Structural Subtyping</h2>

<p>ようするにダックタイピングみたいなやつです。
さっきの<code>please</code>関数の引数を、</p>

<p>```javascript
function please(rider: { name: string; henshin: () => void; }): void {</p>

<p>}
```</p>

<p>みたいに出来ます、言ってしまえばそれだけです。</p>

<p>なんの役に立つかよくわかんないと思うので、<code>each</code>関数みたいなのを作るのを想定してみましょう。
ウィザードで説明するのに限界を感じ(飽き)ました。</p>

<p><code>each</code>って基本的には<code>Array</code>を受け取ると思うんですが、JavaScriptには<code>Array</code>っぽいものというのが存在しますよね。
オブジェクトとしては、数値でインデックスアクセスできて、<code>length</code>を持っている、というものです。</p>

<p>で、これをさっきの例に当てはめると、</p>

<p>```javascript
function each(list: { [index: number]: any; length: number; }, func: (obj: any) => void): void {</p>

<pre><code>return [];
</code></pre>

<p>}
```</p>

<p>まあこんな感じになるわけです。
これで例えば<code>Array</code>っぽい<code>arguments</code>とかが通るようになります。</p>

<p><code>javascript
() =&gt; each(arguments, (obj: any) =&gt; {})
</code></p>

<p>ただこのままだと、<code>map([1,2,3])</code>が通らないので、<code>any[]</code>も受け付けるようにオーバーロードします。</p>

<p>```javascript
function each(list: any[], func: (obj: any) => void): void;
function each(list: { [index: number]: any; length: any; }, func: (obj: any) => void): void;
function each(list: any, func: (obj: any) => void): void {</p>

<pre><code>for (var i = 0, l = list.length; i &lt; l; i++) {
    func(list[i]);
}
</code></pre>

<p>}
```</p>

<p>こんな感じ。長い。こうすると</p>

<p><code>javascript
each([1,2,3], (obj: any) =&gt; {})
() =&gt; each(arguments, (obj: any) =&gt; {})
</code></p>

<p>は通るけど、</p>

<p><code>javascript
each(1, (obj: any) =&gt; {})
</code></p>

<p>とかは通らなくなります、よかったですね！</p>

<p>あとは<code>func</code>をInterfaceにまとめて、</p>

<p>```javascript
interface EachFunc {</p>

<pre><code>(obj: any): void;
</code></pre>

<p>}</p>

<p>function each(list: any[], func: EachFunc): void;
function each(list: { [index: number]: any; length: any; }, func: EachFunc): void;
function each(list: any, func: EachFunc): void {
}
```</p>

<p>こうなって、さらにさっきのをInterfaceを経由するようにすると、</p>

<p>```javascript
interface EachFunc {</p>

<pre><code>(obj: any): void;
</code></pre>

<p>}</p>

<p>interface LikeArray {</p>

<pre><code>[index: number]: any;
length: any;
</code></pre>

<p>}</p>

<p>function each(list: any[], func: EachFunc): void;
function each(list: LikeArray, func: EachFunc): void;
function each(list: any, func: EachFunc): void {
}
```</p>

<p>とか書いたりできます。</p>

<h2>まとめ</h2>

<p>ﾋｰｽｲﾌｰﾄﾞｰﾎﾞｰｻﾞﾊﾞﾋﾞｭｰﾄﾞｺﾞｰﾝ!</p>
]]></content>
  </entry>
  
</feed>
