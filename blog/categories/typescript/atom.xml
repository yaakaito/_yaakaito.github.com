<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TypeScript | yaakaito.org]]></title>
  <link href="http://yaakaito.org/blog/categories/typescript/atom.xml" rel="self"/>
  <link href="http://yaakaito.org/"/>
  <updated>2013-05-03T22:12:21+09:00</updated>
  <id>http://yaakaito.org/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TypeScriptのInterfaceとStructural Subtyping]]></title>
    <link href="http://yaakaito.org/blog/2013/05/02/typescript-subtyping/"/>
    <updated>2013-05-02T02:58:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/02/typescript-subtyping</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScriptにはInterfaceとStructural Subtypingがあるのでそれについて書こうと思います。まだ0.8.x系です。</p>

<h2>Interface</h2>

<p>JavaやC#でいうinterfaceと似ていますが、ある形をしたオブジェクトに対する別名というのが正しいと思います。</p>

<p>```javascript
interface Rider {</p>

<pre><code>name: string;
henshin: () =&gt; void;
</code></pre>

<p>}</p>

<p>var wizard: Rider = {</p>

<pre><code>name: '仮面ライダーウィザード',
henshin: () =&gt; {
    console.log('ｼｬﾊﾞﾄﾞｭﾋﾞﾀｯﾁﾍﾝｼｰﾝ!');
}
</code></pre>

<p>}
```</p>

<p>こうすると <code>wizard</code> は <code>Rider</code> であることになります。
JavaScriptには存在しないシンタックスなので、コンパイルするとinterfaceは当然ですが消えます。</p>

<p>```javascript
var wizard = {</p>

<pre><code>name: '仮面ライダーウィザード',
henshin: function () {
    console.log('ｼｬﾊﾞﾄﾞｭﾋﾞﾀｯﾁﾍﾝｼｰﾝ!');
}
</code></pre>

<p>};
```</p>

<p>同じように <code>beast</code> も作ってみます。</p>

<p>```javascript
var beast: Rider = {</p>

<pre><code>name: '仮面ライダービースト',
henshin: () =&gt; {
    console.log('L・I・O・N!ﾗｲｵｰﾝ!');
}
</code></pre>

<p>}
```</p>

<p>やりましたね。</p>

<p>このinterfaceはそのまま型のように扱うことが出来るので、</p>

<p>```javascript
var please = function(rider: Rider) {</p>

<pre><code>rider.henshin();
</code></pre>

<p>}</p>

<p>please(wizard);
please(beast);
```</p>

<p>こういう風に使う事も出来ます。便利ですね。</p>

<p>もちろんclassにimplementsすることも出来ます。</p>

<p>```javascript
class WizardInfinity implements Rider {</p>

<pre><code>public name: string = '仮面ライダーウィザード インフィニティ';

public henshin(): void {
    console.log('ﾋｰｽｲﾌｰﾄﾞｰﾎﾞｰｻﾞﾊﾞﾋﾞｭｰﾄﾞｺﾞｰﾝ!');
}
</code></pre>

<p>}
```</p>

<p>実装が欠けている場合は、こういう感じのエラーになります。</p>

<p><code>
Class 'WizardInfinity' declares interface 'Rider' but does not implement it: Type 'WizardInfinity' is missing property 'name' from type 'Rider'
Class 'WizardInfinity' declares interface 'Rider' but does not implement it: Type 'WizardInfinity' is missing property 'henshin' from type 'Rider'
</code></p>

<p>Functionにも適用することができて、</p>

<p>```javascript
class Ring {</p>

<pre><code>public name: string = 'ドライバーオンウィザードリング';
</code></pre>

<p>}</p>

<p>interface DriverOn {</p>

<pre><code>(ring: Ring): void;
</code></pre>

<p>}</p>

<p>var driverOn: DriverOn = function(ring: Ring) {</p>

<pre><code>if (ring.name === 'ドライバーオンウィザードリング') {
    console.log('ﾄﾞﾗｲﾊﾞｰｵｰﾝｯ!ﾌﾟﾘｨｨｨｽﾞ!');
}
</code></pre>

<p>}
```</p>

<p>こういう感じに書けます。これだけだと別に利点が分からなくて、</p>

<p>```javascript
var driverOn = (ring: Ring): void => {</p>

<pre><code>if (ring.name === 'ドライバーオンウィザードリング') {
    console.log('ﾄﾞﾗｲﾊﾞｰｵｰﾝｯ!ﾌﾟﾘｨｨｨｽﾞ!');
}
</code></pre>

<p>}
```</p>

<p>これで別によくね、となるんですが、いうならオーバーロードみたいなことが出来るのでちょっと便利です。こういう感じで書く事が出来るので、</p>

<p>```javascript
interface DriverOn {</p>

<pre><code>(ring: Ring): void;
(love: Love): void;
</code></pre>

<p>}
```</p>

<p>全体でこんな感じになってると、<code>Phantom</code>を受け付けません。</p>

<p>```javascript
class Ring {</p>

<pre><code>public name: string = 'ドライバーオンウィザードリング';
</code></pre>

<p>}</p>

<p>class Love {</p>

<pre><code>public target: string = 'こよみ';
</code></pre>

<p>}</p>

<p>class Phantom {</p>

<pre><code>public original: string = 'ミサ';
</code></pre>

<p>}</p>

<p>interface DriverOn {</p>

<pre><code>(ring: Ring): void;
(love: Love): void;
</code></pre>

<p>}</p>

<p>var driverOn: DriverOn = function(power: any) {</p>

<pre><code>if (power instanceof Ring &amp;&amp; power.name === 'ドライバーオンウィザードリング') {
    console.log('ﾄﾞﾗｲﾊﾞｰｵｰﾝｯ!ﾌﾟﾘｨｨｨｽﾞ!');
}
else if (power instanceof Love &amp;&amp; power.target === 'こよみ') {
    console.log('ｲﾝｯﾌｨﾆﾃｨｨ!ｲﾝｯﾌｨﾆﾃｨｨ!ｲﾝｯﾌｨﾆﾃｨｨ!ｲﾝｯﾌｨﾆﾃｨｨ!');
}
</code></pre>

<p>}</p>

<p>driverOn(new Ring());
driverOn(new Love());
driverOn(new Phantom()); // Supplied parameters do not match any signature of call target
```</p>

<p>あとは <code>interface A extends B</code> と出来たり、同じ<code>interface</code>を2回定義する事で拡張できたりします。</p>

<h2>Structural Subtyping</h2>

<p>ようするにダックタイピングみたいなやつです。
さっきの<code>please</code>関数の引数を、</p>

<p>```javascript
function please(rider: { name: string; henshin: () => void; }): void {</p>

<p>}
```</p>

<p>みたいに出来ます、言ってしまえばそれだけです。</p>

<p>なんの役に立つかよくわかんないと思うので、<code>each</code>関数みたいなのを作るのを想定してみましょう。
ウィザードで説明するのに限界を感じ(飽き)ました。</p>

<p><code>each</code>って基本的には<code>Array</code>を受け取ると思うんですが、JavaScriptには<code>Array</code>っぽいものというのが存在しますよね。
オブジェクトとしては、数値でインデックスアクセスできて、<code>length</code>を持っている、というものです。</p>

<p>で、これをさっきの例に当てはめると、</p>

<p>```javascript
function each(list: { [index: number]: any; length: number; }, func: (obj: any) => void): void {</p>

<pre><code>return [];
</code></pre>

<p>}
```</p>

<p>まあこんな感じになるわけです。
これで例えば<code>Array</code>っぽい<code>arguments</code>とかが通るようになります。</p>

<p><code>javascript
() =&gt; each(arguments, (obj: any) =&gt; {})
</code></p>

<p>ただこのままだと、<code>map([1,2,3])</code>が通らないので、<code>any[]</code>も受け付けるようにオーバーロードします。</p>

<p>```javascript
function each(list: any[], func: (obj: any) => void): void;
function each(list: { [index: number]: any; length: any; }, func: (obj: any) => void): void;
function each(list: any, func: (obj: any) => void): void {</p>

<pre><code>for (var i = 0, l = list.length; i &lt; l; i++) {
    func(list[i]);
}
</code></pre>

<p>}
```</p>

<p>こんな感じ。長い。こうすると</p>

<p><code>javascript
each([1,2,3], (obj: any) =&gt; {})
() =&gt; each(arguments, (obj: any) =&gt; {})
</code></p>

<p>は通るけど、</p>

<p><code>javascript
each(1, (obj: any) =&gt; {})
</code></p>

<p>とかは通らなくなります、よかったですね！</p>

<p>あとは<code>func</code>をInterfaceにまとめて、</p>

<p>```javascript
interface EachFunc {</p>

<pre><code>(obj: any): void;
</code></pre>

<p>}</p>

<p>function each(list: any[], func: EachFunc): void;
function each(list: { [index: number]: any; length: any; }, func: EachFunc): void;
function each(list: any, func: EachFunc): void {
}
```</p>

<p>こうなって、さらにさっきのをInterfaceを経由するようにすると、</p>

<p>```javascript
interface EachFunc {</p>

<pre><code>(obj: any): void;
</code></pre>

<p>}</p>

<p>interface LikeArray {</p>

<pre><code>[index: number]: any;
length: any;
</code></pre>

<p>}</p>

<p>function each(list: any[], func: EachFunc): void;
function each(list: LikeArray, func: EachFunc): void;
function each(list: any, func: EachFunc): void {
}
```</p>

<p>とか書いたりできます。</p>

<h2>まとめ</h2>

<p>ﾋｰｽｲﾌｰﾄﾞｰﾎﾞｰｻﾞﾊﾞﾋﾞｭｰﾄﾞｺﾞｰﾝ!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近TypeScript書くときに使うGrunt+Testem+αのテンプレ]]></title>
    <link href="http://yaakaito.org/blog/2013/04/26/typescript-proj-template/"/>
    <updated>2013-04-26T03:50:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/04/26/typescript-proj-template</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScript0.9のpreviewがリリースされましたね！最近はもうJavaScriptもCoffeeScriptも自発的には書ていないです。
仕事とかでも結構TypeScriptでプロト作っては捨て、みたいなことをやってるんですが、
そうしてるうちにプロジェクトのテンプレ大体決まってきたなーという感じがしたのでまとめた。</p>

<p><a href="https://github.com/yaakaito/typescript-proj">typescript-proj</a></p>

<h2>搭載しているもの</h2>

<ul>
<li>Gruntのカスタムタスク</li>
<li>Testem Mocha+chai でのテスト環境</li>
<li>jQuery.d.ts 1.9</li>
<li>.gitignoreとか.gitattributes</li>
<li>package.jsonとcomponents.json入り</li>
</ul>


<p>中核はGrunt+Testem+Bowerな感じ。yoでよくね感すごい。</p>

<h2>使い方</h2>

<p>完全に個人用にまとめてるだけなので、cloneして<code>.git</code>消して使ってる。</p>

<p><code>
$ git clone https://github.com/yaakaito/typescript-proj.git proj
$ rm -rf proj/.git
</code></p>

<p>npmとbowerを使ってるので、とりあえずテンプレ分を取ってくる</p>

<p><code>
$ npm install
$ bower install
</code></p>

<h2>プロジェクト構成</h2>

<p>セットアップしてから、とりあえず <code>grunt generate</code> するとこんな感じになる。</p>

<p><code>
tree -L 2 --dirsfirst
.
├── build
│   ├── index.js
│   └── index.min.js
├── compiled
│   ├── src
│   └── test
├── components
│   └── jquery
├── d.ts
│   ├── chai.d.ts
│   ├── jquery.d.ts
│   └── mocha.d.ts
├── node_modules
│   ├── grunt
│   ├── grunt-contrib-clean
│   ├── grunt-contrib-concat
│   ├── grunt-contrib-connect
│   ├── grunt-contrib-copy
│   ├── grunt-contrib-uglify
│   ├── grunt-regarde
│   └── grunt-typescript
├── public
│   ├── javascript
│   └── index.html
├── res
│   └── index.html
├── src
│   └── index.ts
├── test
│   └── index.ts
├── Gruntfile.coffee
├── README.md
├── component.json
├── package.json
└── testem.json
</code></p>

<p>上から説明していくと</p>

<h3>build</h3>

<p>連結済み + minify済みのJSが置かれるところ。
これはリリースの配布にも使うことを前提にしているので、gitignoreはされてない。</p>

<h3>compiled</h3>

<p>単純にコンパイルした状態のJSが置かれるところ。
中間ファイルみたいなものなので、gitignoreの対象。</p>

<h3>components</h3>

<p>bowerで入るモジュール。gitginore。</p>

<h3>d.ts</h3>

<p>TypeScript用の<code>d.ts</code>を置くところ。コードとほぼ同じ扱い。
微妙に違うけど、vendorみたいなもの。ドットは好みだと思うのでご自由に。</p>

<p>デフォルトでは jQueryと mocha、chaiを入れてある。
jQueryはまあなんだかんだで使う(使わされる)のでデフォで入れてある感じ。
mochaとchaiはテスト用、testemはそこまでは面倒みてくれないので自分で置く。</p>

<p><code>d.ts</code>の追加は僕は<a href="http://www.tsdpm.com/">tsdpm</a>から探して<code>tsd</code>で取ってきて適当に配置してる。</p>

<h3>node_modules</h3>

<p>npm。主にgrunt系がインストールされる。特に書く事ない。</p>

<h3>public</h3>

<p>プレビューモードでルートにするところ。gh-pagesとか作りたいときはここに入るように作るんだけど、<code>index.html</code>の元ファイルとかは<code>res</code>にある。</p>

<h3>res</h3>

<p>TypeScript以外のものを置くところ。上の<code>index.html</code>とか、cssとか置いたりする。
compassとかをデフォルトで入れてないんだけど、作るならここに入れる事になると思う。</p>

<h3>src</h3>

<p>TypeScript、特に言う事ない。</p>

<h3>test</h3>

<p>テスト、特に言う事ない。</p>

<h3>Gruntfile.coffee</h3>

<p>Gruntの設定ファイル。詳しくは後で。</p>

<h3>README.md</h3>

<p>とりあえずデフォルトでテンプレートのREADME入れてる。</p>

<h3>component.json package.json</h3>

<p>bowerとnpm。特に言う事ない。</p>

<h3>testem.json</h3>

<p>Testemの設定ファイル。詳しくは後で。</p>

<h2>Gruntのタスク</h2>

<p>ビルド系は微妙に分かり難いんだけど、基本的に<code>compile</code> <code>build</code> <code>generate</code>の3種類を定義して使ってる。
それにプラスして<code>preview</code>というのを作っていて、配信サーバーを立てて、ファイル更新されたらビルドしなおす感じ。
LiveReloadとかはなくともよいかなーと思ってるので作ってない。</p>

<h3>compile</h3>

<p>単純にTypeScriptをコンパイルするだけ。<code>src</code> <code>test</code> 共にコンパイルして <code>compiled</code> へ。
TypeScriptだと<code>index.ts</code>だけコンパイルするようにして、<code>index.ts</code>で全部referenceでもいいと思うので使い分ける。</p>

<p>```coffeescript
typescript:</p>

<pre><code>compile:
    src: ['src/**/*.ts']
    dest: 'compiled'
    # src: ['src/index.ts']
    # dest: 'compiled/src/index.ts'
    options:
        module: 'commonjs'
        target: 'es5'
        # sourcemap: true
        # declaration: true
test:
    src: ['test/**/*.ts']
    dest: 'compiled'
    options:
        module: 'commonjs'
        target: 'es5'
</code></pre>

<p>grunt.registerTask 'compile', ['typescript']
```</p>

<h3>build</h3>

<p>concat + uglifyでminify作ったりする。作ったのは <code>build</code> に入る。</p>

<p>```coffeescript
concat:</p>

<pre><code>dist:
    src: ['compiled/src/**/*.js']
    dest: 'build/index.js'
options:
    separator: ';'
</code></pre>

<p>uglify:</p>

<pre><code>min:
    files:
        'build/index.min.js': ['build/index.js']
###
options:
    mangle:
        expect: ['jQuery']
    sourceMap: 'build/source-map.js'
###
</code></pre>

<p>grunt.registerTask 'build', ['concat', 'uglify']
```</p>

<h3>generete</h3>

<p><code>public</code>を作る為のコマンド、用途に合わせて書き足していく。(インデントきもい)</p>

<p>```coffeescript
copy:</p>

<pre><code>public:
    files: [
            expand: true
            cwd: 'build'
            src: '**'
            dest: 'public/javascript'
        ,
            expand: true
            cwd: 'res'
            src: '**'
            dest: 'public/'
    ]
</code></pre>

<p>grunt.registerTask 'generate', ['compile', 'build', 'copy:public']
```</p>

<h3>preview</h3>

<p>connect + regarde。regardeでgenerateするようにしてる。</p>

<p>```coffeescript
connect:</p>

<pre><code>preview:
    options:
        port: 9000
        base: 'public'
</code></pre>

<p>regarde:</p>

<pre><code>src:
    files: ['src/**/*.*']
    tasks: ['generate']
</code></pre>

<p>grunt.registerTask 'preview', ['generate', 'connect:preview', 'regarde']
```</p>

<p>Gruntfileは状況に合わせて柔軟に変えていく感じにしたいので、デフォルトは<code>*</code>指定が多め。</p>

<h2>Testem</h2>

<p>テストは最近は全部Testemでやってる。BusterJS派だったけど、BusterJSはちょっとトロい感じがする・・・。</p>

<p>```javascript
{</p>

<pre><code>"framework" : "mocha+chai",
"before_tests" : "grunt compile",
"src_files" : [
    "src/**/*.ts",
    "test/**/*.ts"
],
"serve_files" : [
    "compiled/src/**/*.js",
    "compiled/test/**/*.js"
]
</code></pre>

<p>}
```</p>

<p>基本は <code>src</code> <code>test</code> を監視して、あとはGruntに任せてる。</p>

<h2>その他</h2>

<p>適当に<code>index.ts</code>を<code>src</code> <code>test</code> 共に吐いているので、忘れかけたら参考にするなどして書く。
<code>.js</code>は最初からバイナリ扱いしているので安心してください！！！</p>

<h2>まとめ</h2>

<p>CoffeeScriptとかも大体同じ感じで出来ると思うので、それなりに汎用性ある感じだと思う。(やろうとしたけど書かない事に気づいてやってない)
<a href="https://github.com/yaakaito/Gruntfile">Gruntfileだけ個別</a>にまとめたりもしてるので、適当に組み合わせるとよいのでは。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptの紹介的なプレゼンした]]></title>
    <link href="http://yaakaito.org/blog/2013/03/30/typescript-introduction/"/>
    <updated>2013-03-30T01:26:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/30/typescript-introduction</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
勉強会っぽいものがあったので、せっかくなのでTypeScriptどうよ的な話した。
スライドはあくまで紹介程度に留めてて、どっちかと言えば後半のどうよ、どうよ的なやりとりが本体だったんですが、せっかくなのでSpeaker Deckにあげた。</p>

<script async class="speakerdeck-embed" data-id="f9ddb2607a740130222e12313809347f" data-ratio="1.33333333333333" src="http://yaakaito.org//speakerdeck.com/assets/embed.js"></script>


<h2>話した事</h2>

<ul>
<li>JavaScriptで書いてたのもをTypeScriptで書くとこんな感じですかね、的な流れです</li>
<li>みなさんJavaScriptを殴りたくなることがあると思います、僕もそうです</li>
<li>というわけでC#を作ったMicrosoft製のTypeScriptはどうなのか試しています</li>
<li>簡単なJavaScriptがあります</li>
<li>これをTypeScriptで書き直すとこうです、すてきですね！！！！</li>
<li>というわけでTypeScriptはJavaScriptのスーパーセットです</li>
<li>スーパーセットなので残念ながら、JavaScriptのトラップなどを解決することはできません</li>
<li>その代わりにコンパイル時に型チェックを付ける事ができます</li>
<li>ただし出てくるJavaScriptまではチェックできないので、注意しましょう</li>
<li>書くのであれば全部tsで書くのが理想です</li>
<li>型を工夫して書いていたいままでよりも、大分見やすく書けるのが多分一番のメリットです(closure compilerとか)</li>
<li>他にもクラス、モジュール、インターフェイスみたいなものはあるので、一個ずつみていきます</li>
<li>まずクラス、JavaScriptで書くとこんな感じですね、結構分かりにくいです</li>
<li>TypeScriptで書くとこうです、全体としての見通しがよくなりました</li>
<li>コンパイルするとでてくるJavaScriptも綺麗です</li>
<li>次はモジュール、JavaScriptでもこういう感じに実装することはできますが・・・</li>
<li>これがもっと書きやすくなります</li>
<li>JavaScriptも綺麗です</li>
<li>最後にインターフェイス、JavaやC#のインターフェイスとやれることは似ていますが、ものが違います</li>
<li>公式のドキュメントから引用すると、あるオブジェクトに別名を与える、という機能です</li>
<li><code>Programmer Interface</code>はこんな感じ、これはそのままオブジェクトの型としても使えますし、<code>implement</code>することもできます</li>
<li>コンパイル時に必要な定義なので、JavaScriptになった段階では消えます</li>
<li><code>Function</code>もオブジェクトなので、それを表すこともできます</li>
<li>これはそれを利用してオーバーロードを実装してみた例です</li>
<li>ただし残念ながら、定義上のオーバーロードなので、実装自体はJavaScriptと変わりません</li>
<li>他にも機能はありますが・・・</li>
<li>JavaScriptだけでも工夫すれば大体似たような感じで実装することはできますし、型チェックもコンパイラを使えば行う事が出来ます</li>
<li>そしてJavaScriptのトラップを回避できるわけでもありません</li>
<li>なので残念ながら、ソリューションというわけではなく</li>
<li>いままでJavaScriptを書いていた人が、見通しよく、安全なコードを書きやすくなる言語という認識でよいと思います</li>
<li>JavaScriptをしっかりと書けることが前提になる言語です</li>
<li>いままで似たような事を、ちゃんとやっていたJavaScripterな方にはかなりおすすめです</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScript + SourceMap でデバッグしてみる]]></title>
    <link href="http://yaakaito.org/blog/2013/03/28/typescript-with-sorucemap/"/>
    <updated>2013-03-28T03:43:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/28/typescript-with-sorucemap</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
SourceMap便利ですよね！TypeScriptでも使ってみましょう。</p>

<p>といってもそんなにやることないです。
<code>tsc</code>でコンパイルするときに <code>--sourcemap</code> オプションをつけてあげれば生成されます。</p>

<p><code>
$ tsc &lt;file&gt; --sourcemap
</code></p>

<p>単体で吐いてもいいですが、<a href="https://github.com/yaakaito/typebone">前から使ってこのリポジトリ</a>みたいに、<code>reference</code>だけしてるファイルをコンパイルしているような場合でも、ちゃんと吐いてくれます。</p>

<p><code>
$ tsc --out backbone.test.js test/bootstrap.ts --sourcemap
</code></p>

<p>こんな感じにすると、<code>backbone.test.js.map</code>が出てくるので、Chormeで使ってみましょう。</p>

<p><img src="/images/ts-sourcemap-setting.png"></p>

<p><code>Enable source maps</code>をonにして、</p>

<p><img src="/images/ts-sourcemap-show.png"></p>

<p>読み込めばこんな感じに<code>.ts</code>が出てくるので、</p>

<p><img src="/images/ts-sourcemap-debug.png"></p>

<p>BP打つなりして使います、便利ですね！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【解決した】TypeScriptで複数ファイルに渡って同一moduleを定義したくてハマってる]]></title>
    <link href="http://yaakaito.org/blog/2013/03/25/typescript-module-division-files/"/>
    <updated>2013-03-25T08:42:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/25/typescript-module-division-files</id>
    <content type="html"><![CDATA[<h2>解決した</h2>

<p>どうも俺が0.8.3だと思っていた<code>tsc</code>は0.8.0だった。
バージョンが古いなんて生易しいもんじゃねぇ、気がついたらnode環境がぶっ壊れていた、何を言っているかわからねーと思うが(ry
npm listで出てくるtscと、パスが通ってるtscが違った。とりあえず直した、お騒がせしました。</p>

<p>本来下に書いてある</p>

<p>```javascript
module A {
  class Hoge {</p>

<pre><code>// ...
</code></pre>

<p>  }
  export var hoge = new Hoge();
}
```</p>

<p>というのは、0.8.3時点でコンパイルでエラーになるようになっています、<code>Hoge</code>をexportしろ、とのことです。
で、Hogeの中でさらにインナークラスとか呼んでると、それもexportしなくちゃいけなくてヤダーなので、ほしいメソッドだけ<code>interface</code>にしました。</p>

<p>あと、<code>reference</code>を反対にするとなんかおかしい問題は健在っぽいです。
いろいろ邪推してみましたが、それにあんまり意味はないので、issueにしてこようと思います。</p>

<hr />

<p>　</p>

<p>こんにちは！うきょーです！分からないので誰か教えてください。
TypeScriptに<code>module</code>って機能があるんですが、こいつでハマってる。</p>

<p>というのもこれって、</p>

<p>```javascript
module A {
  class Hoge {</p>

<pre><code>// ...
</code></pre>

<p>  }
}
```</p>

<p>みたいにしておくと、</p>

<p>```javascript
var A;
(function (A) {</p>

<pre><code>var Hoge = (function () {
    function Hoge() { }
    return Hoge;
})();  
</code></pre>

<p>})(A || (A = {}));
```</p>

<p>こうなるわけ。
で、<code>module</code>は複数のファイルに渡って同一のものを定義できるらしい。
実際そういう感じになっているし、そうなんだろう、分かる。</p>

<p>問題はこのモジュール内で変数定義しようとしたときに起こった。
例えばシングルトン的な感じでオブジェクトを外に出したいときに、</p>

<p>```javascript
module A {
  class Hoge {</p>

<pre><code>// ...
</code></pre>

<p>  }
  export var hoge = new Hoge();
}
```</p>

<p>とすれば、</p>

<p>```javascript
var A;
(function (A) {</p>

<pre><code>var Hoge = (function () {
    function Hoge() { }
    return Hoge;
})(); 
A.hoge = new Hoge(); 
</code></pre>

<p>})(A || (A = {}));
```</p>

<p>となる、ここまではよい。
もう一個同じ<code>module</code>を実装しているファイルがあるとする、</p>

<p>```javascript
module A {
  class Fuga {</p>

<pre><code>// ...
</code></pre>

<p>  }
}
```</p>

<p>で、この二つを個別にコンパイルする分には何も起こらないし、普通に実行できてるっぽいんだけど、</p>

<p>```javascript
/// <reference path="Fugaの方.ts" /></p>

<p>module A {
  class Hoge {</p>

<pre><code>// ...
</code></pre>

<p>  }
  export var hoge = new Hoge();
}
```</p>

<p>という風にreferenceすると <code>export var hoge = new Hoge();</code> でHogeが見つからなくなる。真上にあるが・・・。</p>

<p>例えばこういう感じにしてビルドしてみても駄目。</p>

<p><code>javascript
/// &lt;reference path="Fugaの方.ts" /&gt;
/// &lt;reference path="Hogeの方.ts" /&gt;
</code></p>

<p>なんだけど、順番を入れ替えると・・・</p>

<p><code>javascript
/// &lt;reference path="Hogeの方.ts" /&gt;
/// &lt;reference path="Fugaの方.ts" /&gt;
</code></p>

<p>なんか知らんが通る。そんな参照で大丈夫か？</p>

<p>要するに、コンパイルするときに</p>

<p>```javascript
module A {
  // ...
}</p>

<p>module A {
  // ...
}
```</p>

<p>という状態になると、二番目以降の<code>module</code>内で参照が死ぬ。
けど<code>class</code>とかでプロパティに持つ分には大丈夫という謎状況。</p>

<p>バグなのかな、バグならバグでよいんだけど。</p>

<p>で、ここまで説明してきたんだけど、これエラーは出るけど、コンパイルはちゃんと通った跡がある、どっちやねん。</p>

<p>一番いい解説を頼む。</p>

<p>(誰も知らなさそうなら公式に投げてみようと思います。)</p>
]]></content>
  </entry>
  
</feed>
