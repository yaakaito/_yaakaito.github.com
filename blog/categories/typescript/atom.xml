<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TypeScript | yaakaito.org]]></title>
  <link href="http://yaakaito.org/blog/categories/typescript/atom.xml" rel="self"/>
  <link href="http://yaakaito.org/"/>
  <updated>2013-07-30T03:28:05+09:00</updated>
  <id>http://yaakaito.org/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TypescriptのジェネリクスをObject Type Literalと組み合わせると結構強力]]></title>
    <link href="http://yaakaito.org/blog/2013/07/30/typescript-generics-with-object-type-literal/"/>
    <updated>2013-07-30T03:20:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/07/30/typescript-generics-with-object-type-literal</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScriptのジェネリクスとObject Type Literalを組み合わせると結構強力なのでその紹介。</p>

<h2>Object Type Literalとはなんぞや</h2>

<p>例えばこういうオブジェクトに対して、</p>

<p>```javascript
var v = {</p>

<pre><code>a: 'a',
b: 123
</code></pre>

<p>}
```</p>

<p>こういう型注釈を与えられるのがObject Type Literalです。</p>

<p>```javascript
var v: {a: string, b: number} = {</p>

<pre><code>a: 'a',
b: 123
</code></pre>

<p>}
```</p>

<p>TypeScriptのinterfaceはこのObject Type Literalに別名を与えられるもので、本質的には同じです。
大抵の場合は型推論されたり、interfaceを使うので、あんまり書く事はありません。(その方が見やすいしね)</p>

<p>なんですが、本質的に同じものなので、これをinterfaceのようにジェネリクスの引数型に<code>extends</code>させたりすることができます。</p>

<h2>ジェネリクスと組み合わせると</h2>

<p>こんな感じにかけます、<code>{}</code>がちょっとダサいですね。</p>

<p>```javascript
class Fuga<T extends { piyopiyo(): string }> {</p>

<p>  constructor(private object: T) { }</p>

<p>  callPiyoPiyo() {</p>

<pre><code>this.object.piyopiyo();
</code></pre>

<p>  }</p>

<p>}
```</p>

<p>これで<code>piyopiyp</code>を実装しているものだけ受け付けるようになります。便利ですね。</p>

<h2>使う側でも書けて</h2>

<p>こういうこともできますが、こっちはまず使わないですね、はい。</p>

<p><code>javascript
new Fuga&lt;{piyopiyo(): string, foofoo(): string}&gt;();
</code></p>

<h2>あんまりやすぎるとしんどいので</h2>

<p>実装してほしいメソッドが1つあるけど、その為にinterface書くのだるいし〜、くらいの時につかうとよいと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptは引数の値によって関数定義を変えられるっぽい]]></title>
    <link href="http://yaakaito.org/blog/2013/06/18/typescript-function-def-by-value/"/>
    <updated>2013-06-18T04:24:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/06/18/typescript-function-def-by-value</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！僕は元気です！
<code>lib.d.ts</code>を眺めていたら面白い記述があったので、ちょっと調べてみました。これができるのは、<code>0.9.0</code>からっぽいです。</p>

<p>codeplexの行パーマリンクの貼り方がよくわかんないので、申し訳ないんですが。
<a href="http://typescript.codeplex.com/SourceControl/latest#bin/lib.d.ts">lib.d.ts</a>を<code>0.9.0</code>で開いて<code>interface Document</code>とかでサーチするとこんな感じのが出てきます。</p>

<p>```javascript
// http://typescript.codeplex.com/SourceControl/latest#bin/lib.d.ts
interface Document extends Node, /<em> .... </em>/ {</p>

<pre><code>// ...
createElement(tagName: string): HTMLElement;
createElement(tagName: "a"): HTMLAnchorElement;
createElement(tagName: "abbr"): HTMLElement;
createElement(tagName: "address"): HTMLElement;
createElement(tagName: "area"): HTMLAreaElement;
createElement(tagName: "article"): HTMLElement;
createElement(tagName: "aside"): HTMLElement;
// ...
</code></pre>

<p>}
```</p>

<p>おなじみの<code>createElement</code>です。オーバーロードっぽいですが、よく見ると返り値が<code>tagName</code>によって違います。
どうやら、渡った値によって関数の定義が変わるっぽい。
実際に動かしてみると、確かに変わってた。</p>

<h2>自分で書く事もできて</h2>

<p>例えばこんな感じで書けば自分で定義したものに使う事も出来ます。</p>

<p>```javascript
interface HOGE {</p>

<pre><code>f(a: string): any;
f(a: "string"): string;
f(a: "number"): number;
</code></pre>

<p>}</p>

<p>var hoge: HOGE = {</p>

<pre><code>f(a: any): any {
    return null;
}
</code></pre>

<p>};
```</p>

<h2>引数も変えられるっぽい</h2>

<p><code>interface SVGSVGElementEventHandlers</code>とかがそうなんですが、こういう感じになってる。</p>

<p>```javascript
// http://typescript.codeplex.com/SourceControl/latest#bin/lib.d.ts
interface SVGSVGElementEventHandlers {</p>

<pre><code>onresize: (ev: UIEvent) =&gt; any;
addEventListener(type: "resize", listener: (ev: UIEvent) =&gt; void, useCapture?: boolean): void;
onunload: (ev: Event) =&gt; any;
addEventListener(type: "unload", listener: (ev: Event) =&gt; any, useCapture?: boolean): void;
onscroll: (ev: UIEvent) =&gt; any;
addEventListener(type: "scroll", listener: (ev: UIEvent) =&gt; any, useCapture?: boolean): void;
onerror: (ev: Event) =&gt; any;
addEventListener(type: "error", listener: (ev: Event) =&gt; any, useCapture?: boolean): void;
onzoom: (ev: any) =&gt; any;
addEventListener(type: "zoom", listener: (ev: any) =&gt; any, useCapture?: boolean): void;
onabort: (ev: UIEvent) =&gt; any;
addEventListener(type: "abort", listener: (ev: UIEvent) =&gt; any, useCapture?: boolean): void;
addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
</code></pre>

<p>}
```</p>

<p>イベント名によって<code>listener</code>としてとれる関数が変わる。
<code>listener</code>は<code>interface EventListener</code>で定義されていて、<code>EventListener</code>が取りうる形で制限をかけることができる。
一番最後の</p>

<p><code>javascript
addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
</code></p>

<p>を<code>listener: EventListener</code>じゃなくて、<code>listener: (ev: any) =&gt; any</code>とかやると、全部これと解釈されるっぽい。</p>

<p>こっちも自分で書く事ができて、簡単に書けばこんな感じ。</p>

<p>```javascript
interface FF {</p>

<pre><code>(v: string): void;
(v: number): void;
</code></pre>

<p>}</p>

<p>interface HOGE {</p>

<pre><code>f(a: number, ff: FF): any;
f(a: "string", ff: (v: string) =&gt; void): string;
f(a: "number", ff: (v: number) =&gt; void): number;
</code></pre>

<p>}</p>

<p>var hoge: HOGE = {</p>

<pre><code>f(a: any, ff: FF): any {
    return null;
}
</code></pre>

<p>};
```</p>

<h2>使えるのはstringだけっぽい</h2>

<p>数字とか突っ込んでみたけど、パースエラーだった。使えるのはstringだけっぽい。
特に今回みたいなイベント関連とかのために作られた仕様なんかなーという感じ。</p>

<p>あくまで既存のJavaScriptを安全に使う、というの貫いててすげーなと思う。</p>

<h2>まとめ</h2>

<p>型推論でほとんど隠蔽されるので、意識したり、使うところもほとんどないと思いますけど、
フレームワークとか作る人は覚えておくと便利かもしれません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptで似非Option型作るよ]]></title>
    <link href="http://yaakaito.org/blog/2013/06/04/typescript-like-option/"/>
    <updated>2013-06-04T23:28:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/06/04/typescript-like-option</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
Scalaに<code>Option</code>というものがあって、これが本当に素晴らしいんですよ。
ところで、TypeScriptでも<code>Option</code>使いたいですよね？作りました。</p>

<h2>何が出来るのか</h2>

<p><code>Option</code>は要するに値があるかもしれない、という型です。
みなさんこういうコードを書くかと思いますが、</p>

<p>```javascript
var hoge = fuga.getHoge();
if (!hoge) {</p>

<pre><code>hoge = "default";
</code></pre>

<p>}
return hoge;
```</p>

<p>これをエレガントにこう書けます</p>

<p><code>javascript
return fuga.getHoge().getOrElse(() =&gt; "default")
</code></p>

<p>無駄な変数も<code>if</code>もなくて素晴らしいですね。</p>

<h2>Scalaじゃないのでダサいところ</h2>

<h3>match</h3>

<p>とりあえず<code>match</code>はダサいです。それっぽく書く為に適当なインターフェイスが作ってあって、</p>

<p>```javascript
option.match({</p>

<pre><code>Some: (x) =&gt; {

},
None: () =&gt; {

}
</code></pre>

<p>});
```</p>

<p>こう書けますが、あんまりかっこ良くないですね。</p>

<h3>生成</h3>

<p>Scalaのように<code>Some</code>が<code>Some.apply</code>になるわけでもないので、普通に<code>new</code>します。</p>

<p><code>javascript
new Some('a');
new None&lt;string&gt;();
</code></p>

<p>うーん。</p>

<h3>flatten</h3>

<p><code>implicit</code>とかないので実行時エラーですね。まあテストで分かるのでこれがそこまで問題になる事はないはず・・・。</p>

<h2>コード</h2>

<p>こんな感じです</p>

<p>```javascript
module Katana {</p>

<pre><code>export interface IOptionMatcher&lt;A&gt; {
    Some?(value: A): void;
    None?(): void;
}

export interface Option&lt;A&gt; {
    get(): A;
    getOrElse(defaultValue: () =&gt; A): A;
    orElse(alternative: () =&gt; Option&lt;A&gt;): Option&lt;A&gt;;
    match(matcher: IOptionMatcher&lt;A&gt;);
    map&lt;B&gt;(f: (value: A) =&gt; B): Option&lt;B&gt;;
    flatMap&lt;B&gt;(f: (value: A) =&gt; Option&lt;B&gt;): Option&lt;B&gt;;
    flatten&lt;B&gt;(): Option&lt;B&gt;;
}

export class Some&lt;A&gt; implements Option&lt;A&gt; {

    constructor(private value :A) { }

    get(): A {
        return this.value;
    }

    getOrElse(defaultValue: () =&gt; A): A {
        return this.value;
    }

    orElse(alternative: () =&gt; Option&lt;A&gt;): Option&lt;A&gt; {
        return this;
    }

    match(matcher: IOptionMatcher&lt;A&gt;) {
        if (matcher.Some) {
            matcher.Some(this.value);
        }
    }

    map&lt;B&gt;(f: (value: A) =&gt; B): Option&lt;B&gt; {
        return new Some&lt;B&gt;(f(this.get()));
    }

    flatMap&lt;B&gt;(f: (value: A) =&gt; Option&lt;B&gt;): Option&lt;B&gt; {
        return f(this.get());
    }

    flatten&lt;B&gt;(): Option&lt;B&gt; {
        if (this.value instanceof Some) {
            // :-|
            return &lt;Some&lt;B&gt;&gt;(&lt;any&gt;this.value);
        }
        else if (this.value instanceof None) {
            return new None&lt;B&gt;();
        }
        else {
            throw new Error('Cannot prove that.');
        }
        return null;
    }

}


export class None&lt;A&gt; implements Option&lt;A&gt; {

    get(): A {
        throw new Error('No such element.');
    }

    getOrElse(defaultValue: () =&gt; A): A {
        return defaultValue();
    }

    orElse(alternative: () =&gt; Option&lt;A&gt;): Option&lt;A&gt; {
        return alternative();
    }

    match(matcher: IOptionMatcher&lt;A&gt;) {
        if (matcher.None) {
            matcher.None();
        }
    }

    map&lt;B&gt;(f: (value: A) =&gt; B): Option&lt;B&gt; {
        return new None&lt;B&gt;();
    }

    flatMap&lt;B&gt;(f: (value: A) =&gt; Option&lt;B&gt;): Option&lt;B&gt; {
        return new None&lt;B&gt;();
    }

    flatten&lt;B&gt;(): Option&lt;B&gt; {
        return new None&lt;B&gt;();
    }
}
</code></pre>

<p>}
```</p>

<p><code>foreach</code>とか作ってないんですが、それっぽく使えるはずです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptでのコンストラクタ関数の扱い]]></title>
    <link href="http://yaakaito.org/blog/2013/05/20/typescript-constructor-function/"/>
    <updated>2013-05-20T16:44:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/20/typescript-constructor-function</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
JavaScriptでコンストラクタ関数を</p>

<p><code>javascript
var Hoge = function(){ }
var Fuga = Hoge;
var fuga = new Fuga();
</code></p>

<p>こういう感じに使うのって割とやると思うんだけど、TypeScriptだとどういう扱いになってるのか試してみる。</p>

<p>tscは<code>0.9 alpha</code></p>

<h2>とりあえず</h2>

<p>こんな感じにしてみる</p>

<p>```javascript
class Hoge {</p>

<pre><code>constructor() { }
method() { }
</code></pre>

<p>}</p>

<p>var Hoge2 = Hoge;
```</p>

<p>これは普通に通って、JavaScriptだとこうなる、普通。</p>

<p>```javascript
var Hoge = (function () {</p>

<pre><code>function Hoge() {
}
Hoge.prototype.method = function () {
};
return Hoge;
</code></pre>

<p>})();</p>

<p>var Hoge2 = Hoge;
```</p>

<p>ここで<code>Hoge2</code>がどういう型になっているかというと、こうなっている。</p>

<p><code>
new() =&gt; Hoge
</code></p>

<p>コンストラクタで引数を取るようにするとこうなる</p>

<p>```javascript
class Hoge {</p>

<pre><code>constructor(public fuga: string) { }
</code></pre>

<p>}
```</p>

<p><code>javascript
new(fuga: string) =&gt; Hoge
</code></p>

<p>これは普通に型として使えるので、厳密に書くと、</p>

<p><code>javascript
var Hoge2:new(fuga: string) =&gt; Hoge = Hoge;
</code></p>

<p>こういう感じになる。とりあえず問題なく扱える感じがする。</p>

<h2>Genericsとの組み合わせとか</h2>

<p>結構感動したのがこれ。</p>

<p>```javascript
class Hoge {</p>

<pre><code>constructor() { }
</code></pre>

<p>}</p>

<p>class Fuga<T> {</p>

<pre><code>constructor(public TT: new() =&gt; T) { } 
public create(): T {
    return new this.TT();
}
</code></pre>

<p>}
```</p>

<p>こういう感じにすることができる。
で、これは、</p>

<p><code>javascript
var fuga = new Fuga(Hoge);
</code></p>

<p>という感じにすると推論される。コンストラクタの形の違うクラスを使ってみると、</p>

<p>```javascript
class Foo {</p>

<pre><code>constructor(public fuga: string) { }   
</code></pre>

<p>}</p>

<p>var fuga2 = new Fuga(Foo);
```</p>

<p><code>
error TS2081: Supplied parameters do not match any signature of call target.
</code></p>

<p>すごいぞTypeScript。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptのGenerics試してみる]]></title>
    <link href="http://yaakaito.org/blog/2013/05/16/typescript-generics/"/>
    <updated>2013-05-16T06:34:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/16/typescript-generics</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！TypeScript0.9alpha使える環境作ったのでジェネリクス試すよ！
<a href="https://github.com/yaakaito/typescript-dddbase">typescript-dddbase</a>というのをはじめていたので、これを0.9対応することを見越して、<code>Identity</code> <code>Entity</code> <code>Repository</code>をジェネリクス使って考えてみる。</p>

<h2>使い方</h2>

<p><code>class</code>か<code>interface</code>で名前与えられたものと、<code>string</code> <code>number</code> なんかを使う事が出来ます。
シンタックスはよくある感じで、特に違和感もない。</p>

<p>```javascript
interface Identity<T> {</p>

<pre><code>value: T;
</code></pre>

<p>}</p>

<p>class NumberIdentity implements Identity<number> {</p>

<pre><code>constructor(public value: number) { }
</code></pre>

<p>}</p>

<p>class StringIdentity implements Identity<string> {</p>

<pre><code>constructor(public value: string) { }
</code></pre>

<p>}</p>

<p>var numberIdentity = new NumberIdentity(1);
var stringIdentity = new StringIdentity("A");
```</p>

<p>クラスのときはこんな感じ。</p>

<p>```javascript
class Entity<T extends Identity> {</p>

<pre><code>constructor(public identity: T) { }
</code></pre>

<p>}
```</p>

<h2>推論</h2>

<p>上の<code>Entity</code>みたいなやつの場合、コンストラクタで推論してくれる。
さっき作った<code>numberIdentity</code>を使ってみる。</p>

<p><code>javascript
var entity = new Entity(numberIdentity);
</code></p>

<p>これの<code>identity</code>を<code>stringIdentity</code>で上書きしようとすると、</p>

<p><code>javascript
var entity = new Entity(numberIdentity);
entity.identity = stringIdentity;
</code></p>

<p>こうなる</p>

<p><code>
error TS2012: Cannot convert 'StringIdentity' to 'NumberIdentity':
  Types of property 'value' of types 'StringIdentity' and 'NumberIdentity' are incompatible.
</code></p>

<p>やりましたね！</p>

<p>もちろんですが、こういう風にも書けます。</p>

<p><code>javascript
var entity = new Entity&lt;NumberIdentity&gt;(numberIdentity);
</code></p>

<p>推論できない場合には明示的に書く必要があります。</p>

<h2>ネスト</h2>

<p>ネストも出来ます。<code>Repository</code>を考えたときに、これは<code>Entity&lt;T&gt;</code>の集合なので、</p>

<p><code>javascript
class Repository&lt;E extends Entity&lt;I&gt;, I extends Identity&gt; {
}
</code></p>

<p>こう書けます。
本体もとりあえず書いてみる。(めんどくさいし説明用なので、ただ<code>value</code>にいれて返すだけにした)</p>

<p>```javascript
class Repository<E extends Entity<I>, I extends Identity> {</p>

<pre><code>public value: E = null;

store(entity: E) {
    this.value = entity;
}

findByIdentity(identity: I): E {
    return this.value;
}
</code></pre>

<p>}
```</p>

<p>これの場合は推論できないので、このクラスを直接使う場合は、</p>

<p><code>javascript
var repository = new Repository&lt;Entity&lt;NumberIdentity&gt;, NumberIdentity&gt;();
repository.store(entity);
</code></p>

<p>こんな感じになります。</p>

<h2>もうちょっと書いてみる</h2>

<p>ここまでのを元に<code>Person</code>モデルと<code>PersonRepository</code>を作ってみる、実装はない。</p>

<p>```javascript
class Person extends Entity<NumberIdentity> {</p>

<pre><code>constructor(public identity: NumberIdentity) {
    super(identity);
}
</code></pre>

<p>}</p>

<p>class PersonRepository extends Repository&lt;Person, NumberIdentity> {
}</p>

<p>var person = new Person(numberIdentity);
var personRepository = new PersonRepository();
repository.store(person);
```</p>

<p>こんな感じ。</p>

<h2>関数</h2>

<p>引数の前に書く。</p>

<p><code>
&lt;T&gt;(x: T) =&gt; x
</code></p>

<p>みたいな</p>

<h2>ところで・・・</h2>

<p>試してて途中で気づいたんだけど、</p>

<p>```javascript
class Hoge {</p>

<pre><code>public a: string;
</code></pre>

<p>}
class Fuga {</p>

<pre><code>public a: string;
</code></pre>

<p>}</p>

<p>var hoge: Hoge = new Fuga();
```</p>

<p>これが通るようになってた。で、2時間くらいハマってた。空のクラス定義にすると<code>Array&lt;Hoge&gt;</code>に<code>array.push("ばーか")</code>とかできるよ、やりましたね。
試したのは<code>release-0.9.0-alpha</code>と<code>develop@c3835ab</code>で、どっちも通った。</p>

<p>これって<code>0.8.x</code>だと<code>Cannot convert 'Fuga' to 'Hoge'</code>とかで通らなくて、やりたいなら<code>Interface</code>通してね、
みたいな感じになってたと思うんだけど、変更あったんだろうか？
いくらか探してみたんだけど、それっぽいものを見つけられなくて、よくわかっていない。
眠いし見落としてる可能性もあるので、知ってる人いたら教えてほしい。
挙動は分からんでもないし、バグかなーと思ったんだけど、さすがにテストでこけるんじゃぁ・・・的な。ツッコミなければ投げるつもり。</p>
]]></content>
  </entry>
  
</feed>
