<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: TypeScript | yaakaito.org]]></title>
  <link href="http://yaakaito.org/blog/categories/typescript/atom.xml" rel="self"/>
  <link href="http://yaakaito.org/"/>
  <updated>2013-05-16T01:53:58+09:00</updated>
  <id>http://yaakaito.org/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TypeScript0.9alphaをMac+Gruntで使うよ]]></title>
    <link href="http://yaakaito.org/blog/2013/05/16/using-typescript-09-on-mac-and-grunt/"/>
    <updated>2013-05-16T00:52:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/16/using-typescript-09-on-mac-and-grunt</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScript0.9alphaがちょっと前に出ましたね。
npm経由でインストールできなくてだるいので使ってなかったんですが、0.9の機能試したくなったのでがんばって使えるようにすることにしました。</p>

<h2>TypeScriptのコンパイル</h2>

<p>developをコンパイルすると大体いい感じだと思うのでそうしましょう。
この辺は<a href="http://typescript.codeplex.com/wikipage?title=Build%20The%20Source&amp;referringTitle=Home">本家にも載ってますね</a>。リポジトリでけぇ。
<code>jake</code>が必要なのでいれます。</p>

<p><code>
$ npm install -g jake
$ git clone https://git01.codeplex.com/typescript
$ cd typescript
$ git checkout develop
$ jake local
$ chmod +x bin/tsc
</code></p>

<p>これで <code>typescript/bin/tsc</code> が使えるようになります。</p>

<p>```
$ ./bin/tsc
Version 0.9.0.0
Syntax:   tsc [options] [file ..]</p>

<p>Examples: tsc hello.ts</p>

<pre><code>      tsc --out foo.js foo.ts
      tsc @args.txt
</code></pre>

<p>// ...
```</p>

<p>やったー！！</p>

<h2>grunt-typescript</h2>

<p>普段のビルドは<code>grunt-typesript</code>を使っているので、これが動くと便利な訳です。
どういう指定になってるのかなーと見てみたら、</p>

<p>```javascript
resolveTypeScriptBinPath = function (currentPath, depth) {</p>

<pre><code>var targetPath = path.resolve(__dirname,
    (new Array(depth + 1)).join("../../"),
    "../node_modules/typescript/bin");
if (path.resolve(currentPath, "node_modules/typescript/bin").length &gt; targetPath.length) {
    return;
}
if (fs.existsSync(path.resolve(targetPath, "typescript.js"))) {
    return targetPath;
}

return resolveTypeScriptBinPath(currentPath, ++depth);
</code></pre>

<p>}
```</p>

<p>なるほど？
つまりはこいつのnode_moduleに入ってるtypescriptを丸ごと置き換えちゃえば動くんじゃないかなーーーーーーーーやっちゃえーーーーーー＾ー＾</p>

<p><code>
$ rm /path/to/grunt-typescript/node_modules/typescript
$ cp -r typescript /path/to/grunt-typescript/node_modules
</code></p>

<p>動いた気がする、これはひどい。</p>

<p>適当なファイルをコンパイルしてみる。</p>

<p>```
Running "typescript:compile" (typescript) task
Warning: Object module Hoge {</p>

<pre><code>export class Fuga {
    constructor(public a: string) { }
}
</code></pre>

<p>} has no method 'contents' Use --force to continue.</p>

<p>Aborted due to warnings.
```</p>

<p>うーん、なんか駄目っぽい。
普通に<code>tsc</code>でコンパイルする分にはいけるので、追う意味あんまりないし、<code>tsc</code>でコンパイルしよう。</p>

<h2>grunt-exec</h2>

<p><code>
$ npm install grunt-exec --save-dev
</code></p>

<p>Gruntfileはこんな感じで</p>

<p>```coffeescript
tsc = "path/to/tsc"</p>

<p>module.exports = (grunt) -></p>

<pre><code>grunt.initConfig
    pkg: grunt.file.readJSON 'package.json'
    exec:
        compile:
            cmd: -&gt; "#{tsc} --out compiled/src --declaration src/*.ts"
        test:
            cmd: -&gt; "#{tsc} --out compiled/test test/*.ts"

grunt.loadNpmTasks 'grunt-exec'
</code></pre>

<p>```</p>

<p>コンパイルできた！</p>

<p>あとはgruntのエイリアスよしなにして、とりあえずこれで使えそう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptのコーディング規約を考える]]></title>
    <link href="http://yaakaito.org/blog/2013/05/05/typescript-codeconventions/"/>
    <updated>2013-05-05T19:30:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/05/typescript-codeconventions</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScript書いてますか？？？おすすめです！！！
ところでTypeScriptのコーディング規約がよくわからなかったので、コンパイラをみてきました。
JavaScriptほどあーだーこーだというものでもないと思うので、ほんとにコーディング規約みたいな感じです。</p>

<h2>基本的なところ</h2>

<h3>インデント</h3>

<ul>
<li>ソフトインデントで4個</li>
</ul>


<h3>1行の文字数</h3>

<p>これはコンパイラの方は結構自由に感じた・・・。
ので、JavaScriptよりはJavaとか参考にした方がいいだろうってことで <a href="http://www.oracle.com/technetwork/java/javase/documentation/codeconventions-136091.html#313">Oracle</a> のを参考にすることに。</p>

<ul>
<li><s>1行は80文字</s></li>
</ul>


<h4>追記</h4>

<p>いまどき80文字じゃなくてよくない？というツッコミがあったので考え直した。</p>

<p>僕は、80文字で結構いけるんじゃないかなーと思っている。なのであんまり80文字なってる理由については深追いしてない。
というのも、80文字あったら結構書けるよなーと思うので、オーバーするなら分割する基準になるんでは、というところが大きい。
ただ、シンタックス上長くなっちゃうよねーというのも、もちろんあると思う。(下の方で85文字のがある。)
その都度柔軟に変えばよいというのも、その通りだけど、自分が書いていくのにある程度基準がほしいなーとは思う。</p>

<p>元々は80文字しか表示できないから系(表現あれだけど)の理由らしいんだけど、じゃあ今だとどうなのかなと考えてみた。
で、僕はGithubをよく使う方だと思うので(エンタープライズ含め)、そこで横スクロールしちゃうのはやだなーと思った。
というわけでGithubの100%表示で何文字入るのか数えてみた、122文字らしい。</p>

<p>なので個人で書く範囲では</p>

<ul>
<li>1行は120文字</li>
</ul>


<p>ということにしようかなと思う。</p>

<p>改行ルールとかもこっちを参考にして、</p>

<ul>
<li>コンマのあと</li>
<li>オペレーターの前</li>
<li>改行するときは8個インデント</li>
</ul>


<h3>型の為のコロンの位置</h3>

<ul>
<li>変数名にくっつけてスペースを一つ入れる</li>
</ul>


<p>```javascript
(name: string) => { }</p>

<p>var name: string = Names.at(0);</p>

<p>public name: string = null;
```</p>

<h3>関数の返り値</h3>

<ul>
<li>voidの時は宣言しない</li>
</ul>


<p>```
public voidFunction() {</p>

<p>}</p>

<p>public stringFunction(): string {</p>

<pre><code>return "hoge";
</code></pre>

<p>}
```</p>

<h2>命名規則</h2>

<ul>
<li>変数/関数/メソッドはキャメルケール</li>
</ul>


<h3>クラスとモジュールの命名規則</h3>

<ul>
<li>アッパーキャメルケース</li>
</ul>


<p>```javascript
module Hoge {</p>

<pre><code>class HogeClass {
    // ...
}
</code></pre>

<p>}
```</p>

<h3>Enumの命名規則</h3>

<ul>
<li>アッパーキャメルケース</li>
</ul>


<p>```javascript
enum Fruit {</p>

<pre><code>Apple,
Orange,
KiwiFruit
</code></pre>

<p>}
```</p>

<h3>定数の命名規則</h3>

<ul>
<li>大文字スネークケース</li>
</ul>


<p><code>javascript
var HOGE_FUGA = 'a';
</code></p>

<h3>インターフェイスの命名規則</h3>

<ul>
<li>頭に <code>I</code> をつける</li>
</ul>


<p>```javascript
interface IHoge {</p>

<pre><code>// ...
</code></pre>

<p>}
```</p>

<h2>varの型宣言</h2>

<ul>
<li>基本的には宣言しない</li>
<li>anyとして返されるものに対してには宣言する</li>
</ul>


<p><code>
var name = 'yaakaito';
var name: string = names[0];
</code></p>

<h2>即時関数</h2>

<p>よくわからなかった。JavaScriptのまんま書いてある感じもする。</p>

<p>```javascript
(function(x) {</p>

<pre><code>return x * x
</code></pre>

<p>})(10);
```</p>

<p>TypeScript的にはこんな感じなんだろうか？</p>

<p><code>javascript
(x =&gt; x * x)(10)
</code></p>

<h2>コンストラクタでのプロパティの宣言</h2>

<ul>
<li>コンストラクタに渡された値をそのまま利用する場合はコンストラクタの引数で宣言する</li>
</ul>


<p>```
class Hoge {</p>

<pre><code>public fullName: string;

constructor(public firstName: string, public lastName: string, private age: number) {
    this.fullName = [firstName, lastName].join(" ");
}
</code></pre>

<p>}
```</p>

<h2>こんな感じかなぁ</h2>

<p>追加あれば書く。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptのInterfaceとStructural Subtyping]]></title>
    <link href="http://yaakaito.org/blog/2013/05/02/typescript-subtyping/"/>
    <updated>2013-05-02T02:58:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/05/02/typescript-subtyping</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScriptにはInterfaceとStructural Subtypingがあるのでそれについて書こうと思います。まだ0.8.x系です。</p>

<h2>Interface</h2>

<p>JavaやC#でいうinterfaceと似ていますが、ある形をしたオブジェクトに対する別名というのが正しいと思います。</p>

<p>```javascript
interface Rider {</p>

<pre><code>name: string;
henshin: () =&gt; void;
</code></pre>

<p>}</p>

<p>var wizard: Rider = {</p>

<pre><code>name: '仮面ライダーウィザード',
henshin: () =&gt; {
    console.log('ｼｬﾊﾞﾄﾞｭﾋﾞﾀｯﾁﾍﾝｼｰﾝ!');
}
</code></pre>

<p>}
```</p>

<p>こうすると <code>wizard</code> は <code>Rider</code> であることになります。
JavaScriptには存在しないシンタックスなので、コンパイルするとinterfaceは当然ですが消えます。</p>

<p>```javascript
var wizard = {</p>

<pre><code>name: '仮面ライダーウィザード',
henshin: function () {
    console.log('ｼｬﾊﾞﾄﾞｭﾋﾞﾀｯﾁﾍﾝｼｰﾝ!');
}
</code></pre>

<p>};
```</p>

<p>同じように <code>beast</code> も作ってみます。</p>

<p>```javascript
var beast: Rider = {</p>

<pre><code>name: '仮面ライダービースト',
henshin: () =&gt; {
    console.log('L・I・O・N!ﾗｲｵｰﾝ!');
}
</code></pre>

<p>}
```</p>

<p>やりましたね。</p>

<p>このinterfaceはそのまま型のように扱うことが出来るので、</p>

<p>```javascript
var please = function(rider: Rider) {</p>

<pre><code>rider.henshin();
</code></pre>

<p>}</p>

<p>please(wizard);
please(beast);
```</p>

<p>こういう風に使う事も出来ます。便利ですね。</p>

<p>もちろんclassにimplementsすることも出来ます。</p>

<p>```javascript
class WizardInfinity implements Rider {</p>

<pre><code>public name: string = '仮面ライダーウィザード インフィニティ';

public henshin(): void {
    console.log('ﾋｰｽｲﾌｰﾄﾞｰﾎﾞｰｻﾞﾊﾞﾋﾞｭｰﾄﾞｺﾞｰﾝ!');
}
</code></pre>

<p>}
```</p>

<p>実装が欠けている場合は、こういう感じのエラーになります。</p>

<p><code>
Class 'WizardInfinity' declares interface 'Rider' but does not implement it: Type 'WizardInfinity' is missing property 'name' from type 'Rider'
Class 'WizardInfinity' declares interface 'Rider' but does not implement it: Type 'WizardInfinity' is missing property 'henshin' from type 'Rider'
</code></p>

<p>Functionにも適用することができて、</p>

<p>```javascript
class Ring {</p>

<pre><code>public name: string = 'ドライバーオンウィザードリング';
</code></pre>

<p>}</p>

<p>interface DriverOn {</p>

<pre><code>(ring: Ring): void;
</code></pre>

<p>}</p>

<p>var driverOn: DriverOn = function(ring: Ring) {</p>

<pre><code>if (ring.name === 'ドライバーオンウィザードリング') {
    console.log('ﾄﾞﾗｲﾊﾞｰｵｰﾝｯ!ﾌﾟﾘｨｨｨｽﾞ!');
}
</code></pre>

<p>}
```</p>

<p>こういう感じに書けます。これだけだと別に利点が分からなくて、</p>

<p>```javascript
var driverOn = (ring: Ring): void => {</p>

<pre><code>if (ring.name === 'ドライバーオンウィザードリング') {
    console.log('ﾄﾞﾗｲﾊﾞｰｵｰﾝｯ!ﾌﾟﾘｨｨｨｽﾞ!');
}
</code></pre>

<p>}
```</p>

<p>これで別によくね、となるんですが、いうならオーバーロードみたいなことが出来るのでちょっと便利です。こういう感じで書く事が出来るので、</p>

<p>```javascript
interface DriverOn {</p>

<pre><code>(ring: Ring): void;
(love: Love): void;
</code></pre>

<p>}
```</p>

<p>全体でこんな感じになってると、<code>Phantom</code>を受け付けません。</p>

<p>```javascript
class Ring {</p>

<pre><code>public name: string = 'ドライバーオンウィザードリング';
</code></pre>

<p>}</p>

<p>class Love {</p>

<pre><code>public target: string = 'こよみ';
</code></pre>

<p>}</p>

<p>class Phantom {</p>

<pre><code>public original: string = 'ミサ';
</code></pre>

<p>}</p>

<p>interface DriverOn {</p>

<pre><code>(ring: Ring): void;
(love: Love): void;
</code></pre>

<p>}</p>

<p>var driverOn: DriverOn = function(power: any) {</p>

<pre><code>if (power instanceof Ring &amp;&amp; power.name === 'ドライバーオンウィザードリング') {
    console.log('ﾄﾞﾗｲﾊﾞｰｵｰﾝｯ!ﾌﾟﾘｨｨｨｽﾞ!');
}
else if (power instanceof Love &amp;&amp; power.target === 'こよみ') {
    console.log('ｲﾝｯﾌｨﾆﾃｨｨ!ｲﾝｯﾌｨﾆﾃｨｨ!ｲﾝｯﾌｨﾆﾃｨｨ!ｲﾝｯﾌｨﾆﾃｨｨ!');
}
</code></pre>

<p>}</p>

<p>driverOn(new Ring());
driverOn(new Love());
driverOn(new Phantom()); // Supplied parameters do not match any signature of call target
```</p>

<p>あとは <code>interface A extends B</code> と出来たり、同じ<code>interface</code>を2回定義する事で拡張できたりします。</p>

<h2>Structural Subtyping</h2>

<p>ようするにダックタイピングみたいなやつです。
さっきの<code>please</code>関数の引数を、</p>

<p>```javascript
function please(rider: { name: string; henshin: () => void; }): void {</p>

<p>}
```</p>

<p>みたいに出来ます、言ってしまえばそれだけです。</p>

<p>なんの役に立つかよくわかんないと思うので、<code>each</code>関数みたいなのを作るのを想定してみましょう。
ウィザードで説明するのに限界を感じ(飽き)ました。</p>

<p><code>each</code>って基本的には<code>Array</code>を受け取ると思うんですが、JavaScriptには<code>Array</code>っぽいものというのが存在しますよね。
オブジェクトとしては、数値でインデックスアクセスできて、<code>length</code>を持っている、というものです。</p>

<p>で、これをさっきの例に当てはめると、</p>

<p>```javascript
function each(list: { [index: number]: any; length: number; }, func: (obj: any) => void): void {</p>

<pre><code>return [];
</code></pre>

<p>}
```</p>

<p>まあこんな感じになるわけです。
これで例えば<code>Array</code>っぽい<code>arguments</code>とかが通るようになります。</p>

<p><code>javascript
() =&gt; each(arguments, (obj: any) =&gt; {})
</code></p>

<p>ただこのままだと、<code>map([1,2,3])</code>が通らないので、<code>any[]</code>も受け付けるようにオーバーロードします。</p>

<p>```javascript
function each(list: any[], func: (obj: any) => void): void;
function each(list: { [index: number]: any; length: any; }, func: (obj: any) => void): void;
function each(list: any, func: (obj: any) => void): void {</p>

<pre><code>for (var i = 0, l = list.length; i &lt; l; i++) {
    func(list[i]);
}
</code></pre>

<p>}
```</p>

<p>こんな感じ。長い。こうすると</p>

<p><code>javascript
each([1,2,3], (obj: any) =&gt; {})
() =&gt; each(arguments, (obj: any) =&gt; {})
</code></p>

<p>は通るけど、</p>

<p><code>javascript
each(1, (obj: any) =&gt; {})
</code></p>

<p>とかは通らなくなります、よかったですね！</p>

<p>あとは<code>func</code>をInterfaceにまとめて、</p>

<p>```javascript
interface EachFunc {</p>

<pre><code>(obj: any): void;
</code></pre>

<p>}</p>

<p>function each(list: any[], func: EachFunc): void;
function each(list: { [index: number]: any; length: any; }, func: EachFunc): void;
function each(list: any, func: EachFunc): void {
}
```</p>

<p>こうなって、さらにさっきのをInterfaceを経由するようにすると、</p>

<p>```javascript
interface EachFunc {</p>

<pre><code>(obj: any): void;
</code></pre>

<p>}</p>

<p>interface LikeArray {</p>

<pre><code>[index: number]: any;
length: any;
</code></pre>

<p>}</p>

<p>function each(list: any[], func: EachFunc): void;
function each(list: LikeArray, func: EachFunc): void;
function each(list: any, func: EachFunc): void {
}
```</p>

<p>とか書いたりできます。</p>

<h2>まとめ</h2>

<p>ﾋｰｽｲﾌｰﾄﾞｰﾎﾞｰｻﾞﾊﾞﾋﾞｭｰﾄﾞｺﾞｰﾝ!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近TypeScript書くときに使うGrunt+Testem+αのテンプレ]]></title>
    <link href="http://yaakaito.org/blog/2013/04/26/typescript-proj-template/"/>
    <updated>2013-04-26T03:50:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/04/26/typescript-proj-template</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScript0.9のpreviewがリリースされましたね！最近はもうJavaScriptもCoffeeScriptも自発的には書ていないです。
仕事とかでも結構TypeScriptでプロト作っては捨て、みたいなことをやってるんですが、
そうしてるうちにプロジェクトのテンプレ大体決まってきたなーという感じがしたのでまとめた。</p>

<p><a href="https://github.com/yaakaito/typescript-proj">typescript-proj</a></p>

<h2>搭載しているもの</h2>

<ul>
<li>Gruntのカスタムタスク</li>
<li>Testem Mocha+chai でのテスト環境</li>
<li>jQuery.d.ts 1.9</li>
<li>.gitignoreとか.gitattributes</li>
<li>package.jsonとcomponents.json入り</li>
</ul>


<p>中核はGrunt+Testem+Bowerな感じ。yoでよくね感すごい。</p>

<h2>使い方</h2>

<p>完全に個人用にまとめてるだけなので、cloneして<code>.git</code>消して使ってる。</p>

<p><code>
$ git clone https://github.com/yaakaito/typescript-proj.git proj
$ rm -rf proj/.git
</code></p>

<p>npmとbowerを使ってるので、とりあえずテンプレ分を取ってくる</p>

<p><code>
$ npm install
$ bower install
</code></p>

<h2>プロジェクト構成</h2>

<p>セットアップしてから、とりあえず <code>grunt generate</code> するとこんな感じになる。</p>

<p><code>
tree -L 2 --dirsfirst
.
├── build
│   ├── index.js
│   └── index.min.js
├── compiled
│   ├── src
│   └── test
├── components
│   └── jquery
├── d.ts
│   ├── chai.d.ts
│   ├── jquery.d.ts
│   └── mocha.d.ts
├── node_modules
│   ├── grunt
│   ├── grunt-contrib-clean
│   ├── grunt-contrib-concat
│   ├── grunt-contrib-connect
│   ├── grunt-contrib-copy
│   ├── grunt-contrib-uglify
│   ├── grunt-regarde
│   └── grunt-typescript
├── public
│   ├── javascript
│   └── index.html
├── res
│   └── index.html
├── src
│   └── index.ts
├── test
│   └── index.ts
├── Gruntfile.coffee
├── README.md
├── component.json
├── package.json
└── testem.json
</code></p>

<p>上から説明していくと</p>

<h3>build</h3>

<p>連結済み + minify済みのJSが置かれるところ。
これはリリースの配布にも使うことを前提にしているので、gitignoreはされてない。</p>

<h3>compiled</h3>

<p>単純にコンパイルした状態のJSが置かれるところ。
中間ファイルみたいなものなので、gitignoreの対象。</p>

<h3>components</h3>

<p>bowerで入るモジュール。gitginore。</p>

<h3>d.ts</h3>

<p>TypeScript用の<code>d.ts</code>を置くところ。コードとほぼ同じ扱い。
微妙に違うけど、vendorみたいなもの。ドットは好みだと思うのでご自由に。</p>

<p>デフォルトでは jQueryと mocha、chaiを入れてある。
jQueryはまあなんだかんだで使う(使わされる)のでデフォで入れてある感じ。
mochaとchaiはテスト用、testemはそこまでは面倒みてくれないので自分で置く。</p>

<p><code>d.ts</code>の追加は僕は<a href="http://www.tsdpm.com/">tsdpm</a>から探して<code>tsd</code>で取ってきて適当に配置してる。</p>

<h3>node_modules</h3>

<p>npm。主にgrunt系がインストールされる。特に書く事ない。</p>

<h3>public</h3>

<p>プレビューモードでルートにするところ。gh-pagesとか作りたいときはここに入るように作るんだけど、<code>index.html</code>の元ファイルとかは<code>res</code>にある。</p>

<h3>res</h3>

<p>TypeScript以外のものを置くところ。上の<code>index.html</code>とか、cssとか置いたりする。
compassとかをデフォルトで入れてないんだけど、作るならここに入れる事になると思う。</p>

<h3>src</h3>

<p>TypeScript、特に言う事ない。</p>

<h3>test</h3>

<p>テスト、特に言う事ない。</p>

<h3>Gruntfile.coffee</h3>

<p>Gruntの設定ファイル。詳しくは後で。</p>

<h3>README.md</h3>

<p>とりあえずデフォルトでテンプレートのREADME入れてる。</p>

<h3>component.json package.json</h3>

<p>bowerとnpm。特に言う事ない。</p>

<h3>testem.json</h3>

<p>Testemの設定ファイル。詳しくは後で。</p>

<h2>Gruntのタスク</h2>

<p>ビルド系は微妙に分かり難いんだけど、基本的に<code>compile</code> <code>build</code> <code>generate</code>の3種類を定義して使ってる。
それにプラスして<code>preview</code>というのを作っていて、配信サーバーを立てて、ファイル更新されたらビルドしなおす感じ。
LiveReloadとかはなくともよいかなーと思ってるので作ってない。</p>

<h3>compile</h3>

<p>単純にTypeScriptをコンパイルするだけ。<code>src</code> <code>test</code> 共にコンパイルして <code>compiled</code> へ。
TypeScriptだと<code>index.ts</code>だけコンパイルするようにして、<code>index.ts</code>で全部referenceでもいいと思うので使い分ける。</p>

<p>```coffeescript
typescript:</p>

<pre><code>compile:
    src: ['src/**/*.ts']
    dest: 'compiled'
    # src: ['src/index.ts']
    # dest: 'compiled/src/index.ts'
    options:
        module: 'commonjs'
        target: 'es5'
        # sourcemap: true
        # declaration: true
test:
    src: ['test/**/*.ts']
    dest: 'compiled'
    options:
        module: 'commonjs'
        target: 'es5'
</code></pre>

<p>grunt.registerTask 'compile', ['typescript']
```</p>

<h3>build</h3>

<p>concat + uglifyでminify作ったりする。作ったのは <code>build</code> に入る。</p>

<p>```coffeescript
concat:</p>

<pre><code>dist:
    src: ['compiled/src/**/*.js']
    dest: 'build/index.js'
options:
    separator: ';'
</code></pre>

<p>uglify:</p>

<pre><code>min:
    files:
        'build/index.min.js': ['build/index.js']
###
options:
    mangle:
        expect: ['jQuery']
    sourceMap: 'build/source-map.js'
###
</code></pre>

<p>grunt.registerTask 'build', ['concat', 'uglify']
```</p>

<h3>generete</h3>

<p><code>public</code>を作る為のコマンド、用途に合わせて書き足していく。(インデントきもい)</p>

<p>```coffeescript
copy:</p>

<pre><code>public:
    files: [
            expand: true
            cwd: 'build'
            src: '**'
            dest: 'public/javascript'
        ,
            expand: true
            cwd: 'res'
            src: '**'
            dest: 'public/'
    ]
</code></pre>

<p>grunt.registerTask 'generate', ['compile', 'build', 'copy:public']
```</p>

<h3>preview</h3>

<p>connect + regarde。regardeでgenerateするようにしてる。</p>

<p>```coffeescript
connect:</p>

<pre><code>preview:
    options:
        port: 9000
        base: 'public'
</code></pre>

<p>regarde:</p>

<pre><code>src:
    files: ['src/**/*.*']
    tasks: ['generate']
</code></pre>

<p>grunt.registerTask 'preview', ['generate', 'connect:preview', 'regarde']
```</p>

<p>Gruntfileは状況に合わせて柔軟に変えていく感じにしたいので、デフォルトは<code>*</code>指定が多め。</p>

<h2>Testem</h2>

<p>テストは最近は全部Testemでやってる。BusterJS派だったけど、BusterJSはちょっとトロい感じがする・・・。</p>

<p>```javascript
{</p>

<pre><code>"framework" : "mocha+chai",
"before_tests" : "grunt compile",
"src_files" : [
    "src/**/*.ts",
    "test/**/*.ts"
],
"serve_files" : [
    "compiled/src/**/*.js",
    "compiled/test/**/*.js"
]
</code></pre>

<p>}
```</p>

<p>基本は <code>src</code> <code>test</code> を監視して、あとはGruntに任せてる。</p>

<h2>その他</h2>

<p>適当に<code>index.ts</code>を<code>src</code> <code>test</code> 共に吐いているので、忘れかけたら参考にするなどして書く。
<code>.js</code>は最初からバイナリ扱いしているので安心してください！！！</p>

<h2>まとめ</h2>

<p>CoffeeScriptとかも大体同じ感じで出来ると思うので、それなりに汎用性ある感じだと思う。(やろうとしたけど書かない事に気づいてやってない)
<a href="https://github.com/yaakaito/Gruntfile">Gruntfileだけ個別</a>にまとめたりもしてるので、適当に組み合わせるとよいのでは。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeScriptの紹介的なプレゼンした]]></title>
    <link href="http://yaakaito.org/blog/2013/03/30/typescript-introduction/"/>
    <updated>2013-03-30T01:26:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/30/typescript-introduction</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
勉強会っぽいものがあったので、せっかくなのでTypeScriptどうよ的な話した。
スライドはあくまで紹介程度に留めてて、どっちかと言えば後半のどうよ、どうよ的なやりとりが本体だったんですが、せっかくなのでSpeaker Deckにあげた。</p>

<script async class="speakerdeck-embed" data-id="f9ddb2607a740130222e12313809347f" data-ratio="1.33333333333333" src="http://yaakaito.org//speakerdeck.com/assets/embed.js"></script>


<h2>話した事</h2>

<ul>
<li>JavaScriptで書いてたのもをTypeScriptで書くとこんな感じですかね、的な流れです</li>
<li>みなさんJavaScriptを殴りたくなることがあると思います、僕もそうです</li>
<li>というわけでC#を作ったMicrosoft製のTypeScriptはどうなのか試しています</li>
<li>簡単なJavaScriptがあります</li>
<li>これをTypeScriptで書き直すとこうです、すてきですね！！！！</li>
<li>というわけでTypeScriptはJavaScriptのスーパーセットです</li>
<li>スーパーセットなので残念ながら、JavaScriptのトラップなどを解決することはできません</li>
<li>その代わりにコンパイル時に型チェックを付ける事ができます</li>
<li>ただし出てくるJavaScriptまではチェックできないので、注意しましょう</li>
<li>書くのであれば全部tsで書くのが理想です</li>
<li>型を工夫して書いていたいままでよりも、大分見やすく書けるのが多分一番のメリットです(closure compilerとか)</li>
<li>他にもクラス、モジュール、インターフェイスみたいなものはあるので、一個ずつみていきます</li>
<li>まずクラス、JavaScriptで書くとこんな感じですね、結構分かりにくいです</li>
<li>TypeScriptで書くとこうです、全体としての見通しがよくなりました</li>
<li>コンパイルするとでてくるJavaScriptも綺麗です</li>
<li>次はモジュール、JavaScriptでもこういう感じに実装することはできますが・・・</li>
<li>これがもっと書きやすくなります</li>
<li>JavaScriptも綺麗です</li>
<li>最後にインターフェイス、JavaやC#のインターフェイスとやれることは似ていますが、ものが違います</li>
<li>公式のドキュメントから引用すると、あるオブジェクトに別名を与える、という機能です</li>
<li><code>Programmer Interface</code>はこんな感じ、これはそのままオブジェクトの型としても使えますし、<code>implement</code>することもできます</li>
<li>コンパイル時に必要な定義なので、JavaScriptになった段階では消えます</li>
<li><code>Function</code>もオブジェクトなので、それを表すこともできます</li>
<li>これはそれを利用してオーバーロードを実装してみた例です</li>
<li>ただし残念ながら、定義上のオーバーロードなので、実装自体はJavaScriptと変わりません</li>
<li>他にも機能はありますが・・・</li>
<li>JavaScriptだけでも工夫すれば大体似たような感じで実装することはできますし、型チェックもコンパイラを使えば行う事が出来ます</li>
<li>そしてJavaScriptのトラップを回避できるわけでもありません</li>
<li>なので残念ながら、ソリューションというわけではなく</li>
<li>いままでJavaScriptを書いていた人が、見通しよく、安全なコードを書きやすくなる言語という認識でよいと思います</li>
<li>JavaScriptをしっかりと書けることが前提になる言語です</li>
<li>いままで似たような事を、ちゃんとやっていたJavaScripterな方にはかなりおすすめです</li>
</ul>

]]></content>
  </entry>
  
</feed>
