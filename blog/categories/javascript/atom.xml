<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | yaakaito.org]]></title>
  <link href="http://yaakaito.org/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://yaakaito.org/"/>
  <updated>2013-03-30T18:48:57+09:00</updated>
  <id>http://yaakaito.org/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mocha + Testem + HTMLCov 出来るようにする]]></title>
    <link href="http://yaakaito.org/blog/2013/03/23/testing-mocha-testem-htmlcov/"/>
    <updated>2013-03-23T14:32:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/23/testing-mocha-testem-htmlcov</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！だるくなくJavaScript開発できる環境を探しています。</p>

<p>というわけでタイトル通りなんですが、Mocha + Testem + HTML-Cov環境を試してみようと思うので、それの作り方です。
想定している使い方としては、普段はTestemを使ってChrome、Firefox、Safariあたりでテストを回しつつ、たまにカバレッジを確認して〜くらいの割と普通な感じです。
CIは今回はやりません。本当は同じランナーでやりたかったんですが、めんどいので分けました。
もっといいやり方知ってる人いたら教えてください！</p>

<p><a href="https://github.com/yaakaito/mocha-testem-htmlcov">作られたリポジトリはgithubにあります。</a></p>

<h2>必要な物の準備</h2>

<p>せっかくなので？ node 0.10.1 を使います。</p>

<p><code>
$ nvm install 0.10.1
</code></p>

<p>必要なモジュールをいれます。</p>

<ul>
<li>testem</li>
<li>mocha</li>
<li>jscoverage</li>
<li>json2htmlcov</li>
<li>mocha-phantomjs

<ul>
<li>phantomjs</li>
</ul>
</li>
</ul>


<p><code>
$ brew install phantomjs
</code></p>

<p><code>
$ npm install -g testem mocha mocha-phantomjs jscoverage json2htmlcov
</code></p>

<p>メンドーだったので僕は<code>Makefile</code>使ってますが、<code>grunt</code>とかがいいですって人はそれもいれるといいと思います。</p>

<h3>chaiとsinonをとってくる</h3>

<p>chaiとsinonを使いたいので、とってきます。sinon-chaiは別にいらないかなーと思ってる子なので入れてません。
<code>/test/vendor</code> みたいなところに配置しておきます。</p>

<p><code>
$ curl -O http://chaijs.com/chai.js
$ curl -O http://sinonjs.org/releases/sinon-1.6.0.js
</code></p>

<h2>適当にテスト用のjs書く</h2>

<p>サンプル用に適当に</p>

<p>```javascript
// /src/sample.js
var A = (function(){
  function A() {</p>

<p>  }
  A.prototype.method = function(v) {</p>

<pre><code>if (v) {
  return "YES";
}
else {
  return "NO";
}
</code></pre>

<p>  }
  return A;
})();
```</p>

<p>テストはこんな感じ、<code>NO</code>の方は通らないようにしてあります。</p>

<p>```javascript
// /test/tests/sample-tests.js
describe('Sample', function(){
  var a;
  beforeEach(function(){</p>

<pre><code>a = new A();
</code></pre>

<p>  });</p>

<p>  it('YES', function(){</p>

<pre><code>chai.expect(a.method(true)).to.equals('YES');
</code></pre>

<p>  })
});
```</p>

<h2>testem.jsonを書く</h2>

<p>chaiやsinonを一緒に混ぜるようにして、<code>testem.json</code>を作ります。</p>

<p>```javascript
{
  "framework" : "mocha",
  "src_files" : [</p>

<pre><code>"src/**/*.js",
"test/vendor/chai.js",
"test/vendor/sinon.js",
"test/tests/**/*-tests.js"
</code></pre>

<p>  ]
}
```</p>

<p>これでtestem側は終わりです。走らせてみましょう。</p>

<p><code>
$ testem
</code></p>

<p><img src="/images/testem-run.png"></p>

<p>テストしたいブラウザで <code>http://localhost:7357</code> を開きます。あとは開きっぱでよいです。</p>

<p><img src="/images/testem-browsers.png"></p>

<p><img src="/images/testem-result.png"></p>

<p>テストしてくれます、便利ですね。</p>

<h2>HTMLCovでカバレッジを出す</h2>

<p>こういう感じにカバレッジを出す事ができます。</p>

<p><img src="/images/htmlcov.png"></p>

<p>適当にいろいろなブラウザでテストした結果をマージできると理想だけど、面倒そうなのでphantomjsで・・・ 、というか<a href="https://github.com/visionmedia/mocha/issues/281">サポートされていない</a>のかな。
<a href="https://github.com/visionmedia/mocha/pull/506">こういうのもあったけど</a>今回はスルーで。</p>

<p>手順としては</p>

<ul>
<li><code>jscoverage</code> で対象のjsを変換</li>
<li><code>mocha-phantomjs</code> で実行して <code>jsoncov</code> の形で吐き出す</li>
<li><code>json2htmlcov</code> を通して HTMLCov へ変換</li>
</ul>


<p>と、ちょっと面倒くさい。</p>

<h3>ランナーを用意する</h3>

<p><code>mocha</code> のランナーを用意します。</p>

<p><code>
$ mocha init [dir]
</code></p>

<p>吐き出されたのを適当に <code>coverage-runner.html</code> みたいなのにリネームして、必要なファイルを読み込むようにする。</p>

<p>```html</p>

<script src="../cover/sample.js"></script>


<script src="./vendor/mocha.js"></script>


<script src="./vendor/chai.js"></script>


<script src="./vendor/sinon.js"></script>


<script>mocha.setup('bdd')</script>


<script src="./tests/sample-tests.js"></script>


<p>```</p>

<p>僕はカバレッジに使うjsを<code>cover</code>というディレクトリに吐き出すようにしたので、こんな感じで。</p>

<p><code>mocha-phantomjs</code> を使えるようにブートを置き換えます。</p>

<p>```javascript</p>

<script>
  if (window.mochaPhantomJS) {
    mochaPhantomJS.run()
  }
  else {
    mocha.run();
  }
</script>


<p>```</p>

<h3>カバレッジを出すコマンド</h3>

<p>さっきの手順に従ったコマンドで実行します。</p>

<p><code>
$ jscoverage src/sample.js ./cover/
$ mocha-phantomjs -R json-cov test/cover-runner.html | json2htmlcov &gt; cover.html
</code></p>

<p>こんな感じで <code>cover.html</code> が作られるので、あとはそれを<code>open</code>すればよいです。</p>

<p>ちょっと面倒ですが、簡単な部類でしたね。</p>

<h2>ちなみに</h2>

<p>僕は Buster.JS 派です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flow.jsをObjective-Cに移植してみた]]></title>
    <link href="http://yaakaito.org/blog/2013/03/21/flow-m-0-0-1/"/>
    <updated>2013-03-21T03:24:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/21/flow-m-0-0-1</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
<a href="http://www.slideshare.net/uupaa/flowjs">Flow.js</a> というJavaScriptのライブラリを見て、面白いなーと思ったのでObjective-Cでも似たようなことが出来るようにしてみた。junctionとforkは(まだ)実装してないので、完全な移植ではないです。
コードも適当なので遊び程度に見ていただければ。
ところで英語全然書けないので誰か「Natural English」ってプルリクをください。</p>

<p><a href="https://github.com/yaakaito/Flow.m">Flow.m</a></p>

<p>名前はまんま、一応Cocoapodsにも入れてはいるのでCocoapods使ってる人は</p>

<p><code>ruby
pod 'Flow.m'
</code></p>

<p>で使える。</p>

<h2>出来ること</h2>

<p>といっても、基本的には本家と同じなので、<a href="http://www.slideshare.net/uupaa/flowjs">本家のスライド</a>の方が詳しいのでそちらを参照していただきたく。
ただ微妙に仕様が違うところもある感じなので流しで書いておく。</p>

<h3>基本的な使い方</h3>

<p><code>FMFlow</code>のオブジェクトを作る時に、<code>waits</code>と<code>completionBlock</code>を渡す。
<code>FMFlow</code>のオブジェクトには<code>pass</code>ってメソッドが生えていて、これを呼び出すとカウンタが一個づつあがる。
呼び出した回数が<code>waits</code>に達したら、<code>completionBlock</code>が呼び出される。</p>

<p>```objective-c
FMFlow <em>flow = [FMFlow flowWithWaits:2 completionBlock:<sup>(NSError</sup> </em>error, FMArguments *arguments) {</p>

<pre><code>NSLog(@"Flow!");
</code></pre>

<p>}];</p>

<p>[flow pass];
[flow pass]; // Flow!
```</p>

<h3>extends</h3>

<p>処理待機数を増やす、増える方向だけ。</p>

<p>```objective-c
FMFlow <em>flow = [FMFlow flowWithWaits:1 completionBlock:<sup>(NSError</sup> </em>error, FMArguments *arguments) {</p>

<pre><code>NSLog(@"Flow!");
</code></pre>

<p>}];</p>

<p>[flow extend:1];</p>

<p>[flow pass];
[flow pass];  // Flow!
```</p>

<h3>arguments</h3>

<p>本家に合わせる為に若干無理してるんだけど、<code>passWithValue:</code> か <code>passWithValue:forKey:</code>で渡せるし、インデックスかキーか好きなほうでどうぞ。</p>

<p>```objective-c
FMFlow <em>flow = [FMFlow flowWithWaits:2 completionBlock:<sup>(NSError</sup> </em>error, FMArguments *arguments) {</p>

<pre><code>NSLog([arguments argumentAtIndex:0]); // HOGE
NSLog([arguments argumentAtIndex:1]); // FUGA
NSLog([arguments argumentForKey:@"fuga"]); // FUGA
</code></pre>

<p>}];</p>

<p>[flow passWithValue:@"HOGE"];
[flow passWithValue:@"FUGA" forKey:@"fuga"];
```</p>

<h3>missとmissable</h3>

<p>失敗可能回数の設定と、失敗の通知</p>

<p>```objective-c
FMFlow <em>flow = [FMFlow flowWithWaits:1 completionBlock:<sup>(NSError</sup> </em>error, FMArguments *arguments) {</p>

<pre><code>NSLog(@"Flow!");
</code></pre>

<p>}];</p>

<p>[flow missable:1];</p>

<p>[flow miss]; // 1回は許可してるので問題ない
[flow pass]; // Flow!
```</p>

<p>失敗可能回数を超えた時は</p>

<p>```objective-c
FMFlow <em>flow = [FMFlow flowWithWaits:2 completionBlock:<sup>(NSError</sup> </em>error, FMArguments *arguments) {</p>

<pre><code>// error がこんな感じで渡ってくる
// error.domain : org.yaakaito.flow
// error.code   : kFMErrorCodeFailure
NSLog([arguments argumentAtIndex:0]); // ここまでに渡した引数は渡ってくる 
</code></pre>

<p>}];</p>

<p>[flow missable:1];</p>

<p>[flow miss];
[flow passWithValue:@"HOGE"];
[flow miss]; // 失敗したのでCompletionBlockを呼び出す
```</p>

<h3>exit</h3>

<p>強制終了。これはちょっと本家と違って、<code>userInfo</code>を渡すと、<code>CompletionBlock</code>の<code>error.userInfo</code>に入ってくるようになってる。</p>

<p>```objective-c
FMFlow <em>flow = [FMFlow flowWithWaits:1 completionBlock:<sup>(NSError</sup> </em>error, FMArguments *arguments) {</p>

<pre><code>// error.domain : org.yaakaito.flow
// error.code   : kFMErrorCodeExit
NSLog([[error userInfo] objectForKey:@"msg"]); // えらー
</code></pre>

<p>}];</p>

<p>[flow exit:@{ @"msg" : @"えらー"}];
```</p>

<p>こんな感じです、残りはまた今度・・・</p>

<h2>ところで</h2>

<p>AppCode2.0のDarculaテーマは、見やすいのでおすすめです。</p>

<p>あああと非同期テストが必要になったわけなんですが、Cocoapods見てても、SenTestingKit+Asyncみたいなのはみるんだけど単純なモジュールねーなーみたいな。
みんなSenTestingKit用のスーパークラス作るのかなーと思った。
僕は別にちょっと待っててくれればいいだけなので、べつにただのオブジェクトでもいいわってなって、<a href="https://github.com/yaakaito/AsyncTestSupporter">こういう</a>の作った。作ったというか、元から他のコードで使ってたやつをpod化しただけ。
なんか<code>waitForTimeout:</code>くらいしか使わんし、それで十分やろ、とか思うので、それしか作ってない。</p>

<p>```objective-c
- (void)testAsyncMethod
{</p>

<p>  // Create instance.
  AsyncTestSupporter *asyncTest = [[AsyncTestSupporter alloc] init];</p>

<p>  // Prepare for asynchronous call.
  __weak AsyncTestSupporter *that = asyncTest;
  // Call asynchronous method.
  [object asyncMethod:<sup>()</sup> { // Completion blocks.</p>

<pre><code>// Wait for notify with timeout seconds.
[that waitForTimeout:10];
</code></pre>

<p>  }];</p>

<p>  // Notify state if completed asynchronous method.
  [asyncTest notify:notify:kAsyncTestSupporterWaitStatusSuccess];</p>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chaplin Overview オレオレ意訳]]></title>
    <link href="http://yaakaito.org/blog/2013/03/15/chaplin-overview-ja/"/>
    <updated>2013-03-15T07:22:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/15/chaplin-overview-ja</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
このエントリは<a href="http://chaplinjs.org/">Chaplin</a>の<a href="https://github.com/chaplinjs/chaplin/blob/master/docs/overview.md">Overview</a>のオレオレ意訳です。あんまり信用はしないでください。
おかしいだろそれ、というのあれば教えてください。</p>

<p><em>italic</em>はこうでは、と思ったのを勝手に足してるところです。</p>

<h2>アーキテクチャ</h2>

<p>ChaplinはJavaScriptでWebアプリケーションを作るためのアーキテクチャで、backboneをベースにしてるよ。
<a href="http://moviepilot.com">moviepilot.com</a>みたいな単一ページの大規模プロジェクトに使われてるよ。</p>

<h2>フレームワーク</h2>

<h3>Application</h3>

<p>ブートストラップ。Chaplinを利用する上で重要なとこだよ。</p>

<h3>Router</h3>

<p>定義されたURLマッピングにしたがって、<code>Controller</code>の各アクションを呼び出すことを助ける部分だよ。
URLの変更などを監視して、責任を持つよ。
でも、<code>Router</code>が直接<code>Controller</code>をキックするんじゃなくて、それは<code>Dispatcher</code>の仕事だよ。</p>

<h3>Route</h3>

<p>Railsに似たURLマッピングを提供するよ。<code>route.coffee</code>みたいなファイル作るといいよ。
こんな感じで定義するよ。</p>

<p><code>coffeescript
match 'likes/:id', 'likes#show'
</code></p>

<p>ルートにマッチしたら、GETパラメータと、パターン一致部分(例で言えば<code>id</code>) <em>と、オプションの引数</em> を持って、<code>matchRoute</code>イベントを発行するよ。
これは<code>Dispacther</code>に引き継がれるよ。</p>

<h3>Dispachter</h3>

<p>ルーティングに関するイベントをListenしてるよ。
対象のイベントが発生したら、それに対応する<code>Controller</code>のインスタンスを生成して、対象のアクション(<code>Controller</code>のメソッド)を呼び出すよ。</p>

<h3>Layout</h3>

<p><code>Layout</code>はアプリケーションの中で一番外側にあるビューだよ。新しい<code>Controller</code>が起動されると、<code>Layout</code>は新しい<code>Controller</code>をメインビューにするよ。</p>

<p><code>Layout</code>はアプリケーション内でのリンクをうまく処理する役割ももつよ。たとえば<code>&lt;a href="http://yaakaito.org/foo"&gt;</code>というリンクなんかも、正しく機能するようにしてくれるよ。</p>

<p>そして、<code>window</code>や<code>document</code>などのトップレイヤーに対するイベントハンドリングなどは<code>Layout</code>で行うよ。</p>

<h3>Mediator</h3>

<p><code>Mediator</code>はpub/subを実装するためのブローカーだよ。
Chaplinアプリケーションでは、ほとんどのモジュール間通信で利用されるべきだよ。
モジュールは<code>this.publishEvent</code>でイベントを発行できるし、<code>this.subscribeEvent</code>でイベントをリッスンできるよ。
例えばユーザーモデルのような永続的でグローバルにアクセス可能なものを共有するために使ったりもできるよ。</p>

<h3>Controller</h3>

<p><em>BackboneのControllerを継承してるよ。だからBackboneの方もちゃんと見た方がいいよ。</em></p>

<p><code>Controller</code>は<code>Model</code>とそれに結びつけられる<code>View</code>をインスタンス化して、管理するよ。
１つの<code>Controller</code>はアプリケーションの１画面を構成するようにするのが普通だよ。
けど、メインビュー的なものを提供して、他に現在のURLを表すためのコントローラーが存在することもあるよ。 <em>(多分HeaderとかFooterなんかの共通パーツのこと？)</em></p>

<p>コントローラーはアプリケーションの機能を定義することが多いよ。
<code>Controller</code>は<code>index</code>や<code>show</code>、<code>edit</code>のようなアクションメソッドを提供することができるよ。
そしてこれらのアクションはURLが一致したときに<code>Dispacther</code>から呼び出されるよ。</p>

<h3>Model</h3>

<p><em>BackboneのModelを継承してるよ。だからBackboneの方もちゃんと見た方がいいよ。</em></p>

<p>データと、それに操作を行うためのロジックをもってるよ。</p>

<h3>Collection</h3>

<p><em>BackboneのCollectionを継承してるよ。だからBackboneの方もちゃんと見た方がいいよ。</em></p>

<p><code>Model</code>のリストを持つためのものだよ。クライアントサイドでフィルタリングをしたり、ソートしたりするためのロジックをもってるよ。</p>

<h3>View</h3>

<p><em>BackboneのViewを継承してるよ。だからBackboneの方もちゃんと見た方がいいよ。</em></p>

<p><code>Model</code>をテンプレートを使って描画したり、その中に含まれるユーザーイベントなどを管理するよ。</p>

<h3>Collection View</h3>

<p><code>Collection</code>のためのビューだよ。それぞれの<code>Model</code>に対する<code>View</code>を作って、それを管理するよ。</p>

<h2>アプリケーションの起動フロー</h2>

<p>アプリケーションは、<code>Chaplin.Application</code>を継承したところから始まるよ。
<code>Application</code>では<code>Dispacther</code> <code>Layout</code> <code>Mediator</code> <code>Router</code> の順で、これらをインスタンス化してセットアップしてね。</p>

<p><code>Router</code>に<code>Route</code>を登録するよ。普通は設定ファイルとして<code>route.coffee</code>か<code>route.js</code>使うよ。
<code>Route</code>は<code>Controller</code>のアクションにURLパターンをマッピングするよ、たとえば<code>/</code>なら<code>HomeController</code>の<code>index</code>、という感じだよ。</p>

<p>ここまで終わったら、<code>initRouter</code>を呼び出して、URLの監視を始めよう。URLにマッチするパターンであれば、<code>Dispacther</code>や他のモジュールへ通知するよ。</p>

<p><code>Dispacther</code>まで来たら、対象の<code>Controller</code>をインスタンス化して、対応するアクションを呼び出すよ。
<code>Dispachter</code>はアクティブな<code>Controller</code>を管理していて、必要ないものを破棄するよ。</p>

<p>対応するアクションが呼び出されたら、<code>Model</code>や<code>Collection</code>を<code>Ctonroller</code>で生成して、それに対応する<code>View</code>をレンダリングしていくのがよくある流れだよ。
<code>Model</code>や<code>Collection</code>は必要に応じてサーバーからデータを取得したりするよ。
<code>Model</code>や<code>Collection</code>と、それに対応する<code>View</code>は、<code>Controller</code>によって管理されるのが通例だよ。</p>

<h2>メモリ管理について</h2>

<p>Chaplinでは、適切なメモリ管理を行う、というのがコアにあるよ。</p>

<p>みんな、あまりJavaScriptでGCやメモリ管理に関する議論をしないけど、それは重要なトピックだよ。
イベントドリブンで動くシステムは、イベントを登録するときにオブジェクト間の参照が発生するし、それが削除されないと、メモリ解放されないよ。</p>

<p>だから、ChaplinではBackboneのModel、Collection、View、Controllerを拡張して、それらのクリーンアップを保証して、パワフルな処理プロセスを実装できるようにしているよ。</p>

<h2>終わり</h2>

<p>起動フローとかはコードと付き合わせないと分かりにくいところが多いと思うので、<a href="https://github.com/paulmillr/ostio/blob/master/app/application.coffee">ost.ioのブート</a>とか合わせて読むといいと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Brunchプロジェクトでtestemを使う]]></title>
    <link href="http://yaakaito.org/blog/2013/03/14/brunch-withw-testem/"/>
    <updated>2013-03-14T16:36:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/14/brunch-withw-testem</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
<a href="http://yaakaito.org/blog/2013/03/08/hello-brunch/">前回</a>みたいな手順で始めたChaplinのプロジェクトで<a href="https://github.com/airportyh/testem">testem</a>を使う手順です。
Brunch with Chaplinを使っていますが、Brunchプロジェクトなら多分大体同じ感じでいけると思います。</p>

<h2>testemの準備</h2>

<p>testemがないと始まらないのでtestemをインストールします。</p>

<p><code>
$ npm install -g testem
</code></p>

<h2>testem.jsonの設定</h2>

<p>BrunchはデフォルトでMochaを使ったテストのテンプレートを作ってくれるので、これを参考にします。
<code>brunch build</code>すると、<code>/public/test/index.html</code>ができるので、これを参考に書いていきます。</p>

<p>```javascript
{
  "framework" : "mocha",
  "src_files" : [</p>

<pre><code>"public/javascripts/vendor.js",
"public/javascripts/app.js",
"public/test/javascripts/test-vendor.js",
"public/test/javascripts/test.js"
</code></pre>

<p>  ]
}
```</p>

<p>これをプロジェクトのルートに配置します。</p>

<h2>brunchが生成するmochaを消す</h2>

<p>brunchはmochaやsinonを <code>public/test/javascripts/test-vendor.js</code> にまとめてビルドしているので、このビルドからmochaを外します。とりあえず <code>rm</code> してしまいます。</p>

<p><code>
$ rm test/vender/scripts/mocha[version].js
</code></p>

<h2>brunch watchを起動する</h2>

<p>brunchはテストをまとめて <code>public/test/javascripts/test.js</code> にビルドしてくれます。
なのでtestem側からはこれを見ているだけでOKです。便利ですね。</p>

<p><code>
$ brunch w -s
</code></p>

<p>ついでなのでサーバーも立てておきます。</p>

<h2>testemでテストする</h2>

<p>あとはtestemでテストするだけです。</p>

<p><code>
$ testem
</code></p>

<p>便利ですね！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BrunchでJavaScriptアプリはじめる手順]]></title>
    <link href="http://yaakaito.org/blog/2013/03/08/hello-brunch/"/>
    <updated>2013-03-08T08:14:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/08/hello-brunch</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
最近<a href="http://brunch.io/">Brunch</a>というものを知ったので、とりあえずはじめてみたときのメモです。
正確には<a href="http://chaplinjs.org/">Chaplin</a>を先に知って、結構良さげだし試してみよーとか思ったところが始まりなので、brunch-with-chaplinを前提にしてます。(今回はchaplinの話はしません。)</p>

<h2>brunchってそもそも何</h2>

<p>gruntとか使っている人は、gruntにgiter8をくっつけて++というイメージが分かりやすいかと思います。Yeomanとかその系列のものです。
レイヤーが違うので比較してもあんまり意味はないんですが、grunt使っていた頃からすると、</p>

<ul>
<li>最初からCoffeeScriptのことを考えているので、CoffeeScript使う場合は嬉しい (最近はそうでもないみたいだけど)</li>
<li>プロジェクトのひな形作りやすいのは嬉しい</li>
<li>ビルトインサーバーがあるので、<code>watch --server</code> みたいなの出来て嬉しい</li>
<li>Mocha+phantomjsを最初から生成してくれるので、テストドリブンで始めるが楽</li>
<li>ブラウザのオートリロードとかもあるよ！</li>
</ul>


<p>という感じで、gruntみたいに自分でタスク組んで〜とやるよりは、サクッと開発を始められる感じです。
そこまで使ってないし、まだよくわからんので説明はこのくらいで。</p>

<p>CommonJSっぽいモジュールシステムとかはまあ一長一短だと思うのであんまり。</p>

<h2>はじめる</h2>

<p>brunchをインストールします。(node 0.6.10 ~)</p>

<p><code>
$ npm install -g brunch
</code></p>

<h3>プロジェクトのひな形を作る</h3>

<p>Githubからテンプレートを引っ張ってきて作ります。今回はchaplinが使いたかったので、brunch-with-chaplinを引っ張ってきます。</p>

<p><code>
$ brunch new &lt;app-name&gt; --skeleton https://github.com/paulmillr/brunch-with-chaplin
</code></p>

<p>簡単ですね。<code>tree</code>してみるとこんな感じになってます。</p>

<p><code>
$ tree -L 2 -F --dirsfirst
.
├── app/
│   ├── assets/
│   ├── controllers/
│   ├── lib/
│   ├── models/
│   ├── views/
│   ├── application.coffee
│   ├── initialize.coffee
│   ├── mediator.coffee
│   └── routes.coffee
├── generators/
│   ├── collection/
│   ├── collection-test/
│   ├── collection-view/
│   ├── controller/
│   ├── controller-test/
│   ├── generator/
│   ├── model/
│   ├── model-test/
│   ├── style/
│   ├── template/
│   ├── view/
│   └── view-test/
├── node_modules/
│   ├── chai/
│   ├── clean-css-brunch/
│   ├── coffee-script-brunch/
│   ├── css-brunch/
│   ├── handlebars-brunch/
│   ├── javascript-brunch/
│   ├── sinon/
│   ├── sinon-chai/
│   ├── stylus-brunch/
│   └── uglify-js-brunch/
├── test/
│   ├── assets/
│   ├── vendor/
│   ├── views/
│   └── test-helpers.coffee
├── vendor/
│   ├── scripts/
│   └── styles/
├── README.md
├── config.coffee
└── package.json
</code></p>

<p><code>config.coffee</code>にいろいろ設定が書いてあるんですが、長いので別で書きます。</p>

<p>とりあえずビルドしてみます。</p>

<p><code>
$ brunch build
</code></p>

<p><code>/public</code>ができて、ここにもろもろ生成されたファイルが入っています。デプロイのときはここを使えばよいっぽい。</p>

<p>ビルトインサーバーを使ってアプリを起動してみる。</p>

<p><code>
$ brunch watch --server
$ open http://localhost:3333/
</code></p>

<p><img src="/images/hello-brunch.png"></p>

<p>こういう感じにアプリが起動していることがわかります、やりましたね！</p>

<h2>テストを走らせる</h2>

<p>サーバー起動してる状態で、<code>/public</code>の中に出来たテストランナーをブラウザで開けば普通にテストが走ります。
phantomjs使いたいときは、</p>

<p><code>
$ brunch test
</code></p>

<p>でよいらしいです。(使ってない)</p>

<h2>他の環境でのセットアップ</h2>

<p>brunchベースのプロジェクトにコミットするときは、
見た感じ、<code>npm install</code>すればよさそうなので試してみる</p>

<p><code>
$ npm install
$ brunch w --server
</code></p>

<p>出来た、これでよさげ。</p>

<p>使ってみてあーだこうだはもうちょっとしてから書こうと思います。</p>
]]></content>
  </entry>
  
</feed>
