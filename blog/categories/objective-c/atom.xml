<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | yaakaito.org]]></title>
  <link href="http://yaakaito.org/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://yaakaito.org/"/>
  <updated>2013-04-26T05:19:23+09:00</updated>
  <id>http://yaakaito.org/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Storyboardで横にずれるメニュー作る]]></title>
    <link href="http://yaakaito.org/blog/2013/04/25/sliding-view-with-stroyboard/"/>
    <updated>2013-04-25T02:22:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/04/25/sliding-view-with-stroyboard</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
Storyboardって、FaceBookとかがやってる横にずれるメニューを作るのがめちゃくちゃめんどくさそう、というかそこだけコードで書くんじゃないの？という印象だったんですが、
<a href="https://github.com/edgecase/ECSlidingViewController">ESSlidingViewController</a>というのがStroyboardに対応しているらしく、綺麗にいけそうなので試してみた。</p>

<p><a href="https://github.com/yaakaito/StoryBoard-Sliding">コードはGithubで</a></p>

<h2>プロジェクトつくってセットアップ</h2>

<p>とりあえずSingle View Applicationを選んで適当に</p>

<p>作ったらCocoapodsで</p>

<p>```
platform :ios</p>

<p>pod 'ECSlidingViewController'
```</p>

<p><code>
$ pod install
</code></p>

<h2>ECSlidingViewControllerを設定する</h2>

<p>Storyboardに最初に出てくるViewControllerのクラスを<code>ECSlidingViewController</code>にする。</p>

<p><img src="/images/storyboard-sliding-base.png"></p>

<p>MenuViewControllerみたいなのをUITableViewControllerで作って、Storyboardで関連付ける。
Menuというidentifierを与えておく。</p>

<p><img src="/images/storyboard-sliding-menu.png"></p>

<p>これでAppDelegateをいじるのかなーと思ったんだけど、ついてくるサンプルを読んだら、
InitialSlidingViewControllerみたいなを作って、これで初期化してた、こっちの方が綺麗な感じがするのでこっちでやることにする。
最初に表示されるViewControllerを設定しているので、それを作つくるんだけど、ついでなので2つ追加して全体でこんなStoryboardにした。
それぞれにFirstViewとSecondViewでidentifiterを与えている。</p>

<p><img src="/images/storyboard-sliding.png"></p>

<p><code>topViewController</code>というのが生えているので、ここへFirstViewControllerみたいなのを入れる。</p>

<p>```objective-c
@implementation SSInitialViewController</p>

<ul>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];</p>

<p>  UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@"MainStoryboard" bundle:nil];
  self.topViewController = [storyboard instantiateViewControllerWithIdentifier:@"FirstView"];
}</p></li>
</ul>


<p>@end
```</p>

<p>ここまでやったらFirstViewControllerの方でメニューなんかを追加する。
グローバルな感じで設定するんじゃなくて、ViewController単位に指定できるっぽい、便利。</p>

<p>```objective-c
@implementation SSFirstViewController</p>

<ul>
<li><p>(void)viewWillAppear:(BOOL)animated
{
  [super viewWillAppear:animated];</p>

<p>  self.view.layer.shadowOpacity = 0.75f;
  self.view.layer.shadowRadius = 4.0f;
  self.view.layer.shadowColor = [UIColor blackColor].CGColor;</p>

<p>  if (![self.slidingViewController.underLeftViewController isKindOfClass:[SSMenuViewController class]]) {</p>

<pre><code>  UIViewController *menu =  [self.storyboard instantiateViewControllerWithIdentifier:@"Menu"];
  self.slidingViewController.underLeftViewController = menu;
</code></pre>

<p>  }</p>

<p>  [self.view addGestureRecognizer:self.slidingViewController.panGesture];
  [self.slidingViewController setAnchorRightRevealAmount:280.0f];
}</p></li>
</ul>


<p>@end
<code>``
ところでここで一回ハマってて、</code>[self.slidingViewController setAnchorRightRevealAmount:280.0f]`はデフォルトとかがあるわけじゃなくて、かならず設定しないと駄目っぽい。</p>

<p>こんなかんじ！</p>

<p><img src="/images/storyboard-sliding-sample.png" width="320"></p>

<h2>メニューの実装してみる</h2>

<p>適当に、面倒なのでメニュー名からidentifier作るようにしてる。</p>

<p>```objective-c
@interface SSMenuViewController ()
@property (strong, nonatomic) NSArray *items;
@end</p>

<p>@implementation SSMenuViewController</p>

<ul>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];</p>

<p>  self.items = @[@"First", @"Second"];
}</p></li>
<li><p>(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
  return 1;
}</p></li>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
  return self.items.count;
}</p></li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  static NSString </em>CellIdentifier = @"MenuCell";
  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];</p>

<p>  cell.textLabel.text = self.items[indexPath.row];</p>

<p>  return cell;
}</p></li>
<li><p>(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  NSString <em>identifier = [NSString stringWithFormat:@"%@View", self.items[indexPath.row]];
  UIViewController </em>newTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:identifier];</p>

<p>  [self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:<sup>{</sup></p>

<pre><code>  CGRect frame = self.slidingViewController.topViewController.view.frame;
  self.slidingViewController.topViewController = newTopViewController;
  self.slidingViewController.topViewController.view.frame = frame;
  [self.slidingViewController resetTopView];
</code></pre>

<p>  }];
}</p></li>
</ul>


<p>@end
```</p>

<p>画面の切り替えは<code>tableView:didSelectRowAtIndexPath:</code>でやってるあたり。</p>

<p>```objective-c
- (void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>NSString *identifier = [NSString stringWithFormat:@"%@View", self.items[indexPath.row]];
UIViewController *newTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:identifier];

[self.slidingViewController anchorTopViewOffScreenTo:ECRight animations:nil onComplete:^{
    CGRect frame = self.slidingViewController.topViewController.view.frame;
    self.slidingViewController.topViewController = newTopViewController;
    self.slidingViewController.topViewController.view.frame = frame;
    [self.slidingViewController resetTopView];
}];
</code></pre>

<p>}
```</p>

<p>storyboardからidentifierで引いてきて、それを<code>topViewConttoller</code>に設定するだけの親切構造。
僕がいままで使ってきたライブラリだと、この辺は自由にやってね、が多かったので、こうするとよいよがあると助かる。</p>

<p>ほとんどサンプルのまま持ってきたんだけど、このままだとメニューをタップしたあとのアニメーションがちょっとうざい。(一番右まで行ってから戻るやつ)
これは<code>anchorTopViewOffScreenTo:animations:onComplete:</code>がそういうアニメーションっぽいので、<code>resetTopView</code>だけにする。こっちは元の位置に戻すやつ。</p>

<p>```objective-c
- (void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>NSString *identifier = [NSString stringWithFormat:@"%@View", self.items[indexPath.row]];
UIViewController *newTopViewController = [self.storyboard instantiateViewControllerWithIdentifier:identifier];

CGRect frame = self.slidingViewController.topViewController.view.frame;
self.slidingViewController.topViewController = newTopViewController;
self.slidingViewController.topViewController.view.frame = frame;
[self.slidingViewController resetTopView];
</code></pre>

<p>}
```</p>

<p>あとはStoryboardでよしなにビュー作ったりしていけばよい、Storyboardすごいなー。</p>

<h2>まとめ</h2>

<p>思ってたより綺麗にできたし、Storyboard毛嫌いなおりそうでよかったです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Segueでのオブジェクトのやりとりとか]]></title>
    <link href="http://yaakaito.org/blog/2013/04/24/segue-with-object/"/>
    <updated>2013-04-24T03:34:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/04/24/segue-with-object</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
UIのコード書くのがだるいので今更感満載でStoryboardを始めました！
Storyboard出来がよくて、iOSっぽいUIを作る分にはぽちぽちしていけば作れて便利だなーという感じです。</p>

<p>で、ViewController間でのオブジェクトのやりとりにはやっぱコードが必要なので、そこのメモ。
大体よく使うのは<code>pushViewController</code>、<code>Modal</code>、<code>TableView</code>あたりだと思うので、その3つあたりを書く。</p>

<p>別にそれぞれで大きく変わる訳でもないと思うので、最初に貼っておくととりあえずこんな感じのStoryboard作った。</p>

<p><img src="/images/sample-story-board.png"></p>

<p>めんどくさいので最初のVCをSSViewController、遷移先をSSSecondViewControllerにしてある。</p>

<h2>基本</h2>

<p><code>prepareForSegue:sender:</code>というのを使うらしい、これは遷移元の方に書く。
遷移先から戻すときは<code>delegate</code>、両方<code>prepareForSegue:sender:</code>でいけんのかなーとか思ったけどそうではないらしい。</p>

<h2>PushVC</h2>

<p><a href="https://github.com/yaakaito/SegueSample/tree/navigation">コードはここ</a></p>

<p>遷移元の方で<code>prepareForSegue:sender:</code>を定義してあげる。Segueには<code>TopToSecond</code>って名前が付けてある。</p>

<p>```objective-c
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {</p>

<pre><code>if ([segue.identifier isEqualToString:@"TopToSecond"]) {
    NSLog(@"%@", segue.destinationViewController);
}
</code></pre>

<p>}
```</p>

<p>こうすると遷移するときに、ここが呼ばれるので、Segue名で分岐する。
<code>segue.destinationViewController</code>に遷移先のViewControllerのインスタンスが入っているので、ここでよしなにする。
別にそんなにめんどくさくなさそう。</p>

<p>次、戻る時。普通に<code>delegate</code>でやる。</p>

<p><code>objective-c
@protocol SSSecondViewControllerDelegate
- (void)willBack:(id)obj;
@end
</code></p>

<p>適当にプロトコルつくって、さっきのところで関連付ける。</p>

<p>```objective-c
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {</p>

<pre><code>((SSSecondViewController *)segue.destinationViewController).delegate = self;
</code></pre>

<p>}
```</p>

<p>で、戻ってくるときにこれを呼べばいいんだけど、そういう感じのイベントがあるのかと思ったら別になかった。
軽く調べてみた感じだけど、<code>viewWillDisappear</code>でやればよさげ。</p>

<p>```objective-c
- (void)viewWillDisappear:(BOOL)animated {</p>

<pre><code>[super viewWillDisappear:animated];
[self.delegate willBack:@{@"A" : @"HOGE"}];
</code></pre>

<p>}
```</p>

<h2>Modal</h2>

<p><a href="https://github.com/yaakaito/SegueSample/tree/modal">コードはここ</a></p>

<p>pushVCと大差ない。使ってないけど、いままで<code>self.presentedViewController</code>だったのが<code>self.presentingViewController</code>に変わるらしい、紛らわしい。</p>

<p>モーダル閉じるところまでStoryboardで面倒みてほしい気分なんだけど、やりかたがよくわからなかった。</p>

<p>```
- (IBAction)touchDismiss:(id)sender {</p>

<pre><code>[self dismissViewControllerAnimated:YES completion:nil];
</code></pre>

<p>}
```</p>

<h2>TableView</h2>

<p><a href="https://github.com/yaakaito/SegueSample/tree/table">コードはここ</a></p>

<p>戻すところは一緒だけど、indexPathを知る必要があるので一手間増える。
試してみたら、<code>prepareForSegue:sender:</code> -> <code>tableView:didSelectRowAtIndexPath:</code> という順になってて、それはどうなんだろうという気持ちになった。</p>

<p>```objective-c
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {</p>

<pre><code>if ([segue.identifier isEqualToString:@"TopToSecond"]) {
    NSLog(@"%@", segue.destinationViewController);
    NSLog(@"%@", self.tableView.indexPathForSelectedRow);
}
</code></pre>

<p>}
```</p>

<p>こんな感じで、あとはよしなに。</p>

<h2>まとめ</h2>

<p>別に<code>prepareForSegue:sender:</code>じゃなくともよいのではという気がしたりしたけど、
そう書けと言われてるっぽいし長い物に巻かれてそう書く事にした。
いろいろ書けてしまいそうなので、早めにルール作っちゃうのがいいのかなーという感じ。</p>

<p>あとこれどういう名前付ければいいのかよくわからん、<code>Segue</code>ってサフィックスは付けた気がいい気がする。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS用テスティングサーバー NLTHTTPStubServer 0.4 を公開しました]]></title>
    <link href="http://yaakaito.org/blog/2013/04/22/release-nlt-http-stub-server-0-4-0/"/>
    <updated>2013-04-22T00:51:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/04/22/release-nlt-http-stub-server-0-4-0</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
<a href="https://github.com/yaakaito/NLTHTTPStubServer">NLTHTTPStubServer</a> を0.4にアップデートしました。</p>

<p>最初にごめんなさいしておかなければいけないことがあります。</p>

<h2>0.2.x 系との互換性がありません</h2>

<p>ごめんなさい。0.1.x 0.2.x 系でのバグフィックスなどは、半年くらいは受け付けようと思っていますので、気軽にご連絡ください。</p>

<h2>NLTHTTPStubServerって何</h2>

<p>簡単に言えば、レスポンス登録を動的にできるHTTPサーバー for iOSです。
HTTP通信をするiOSアプリはたくさんあると思うのですが、これのテストを書く為に開発されました。</p>

<p>仕組みとしては結構単純で、ローカルにHTTPサーバーを立てて、そこにレスポンスを登録し、アプリ(HTTPClient)でそこへアクセスする、という感じです。
例えば <code>/api/v1/fake</code> は <code>fake.json</code> を返してほしい、というケースであれば、</p>

<p><code>objective-c
[[[server expect] forPath:@"/api/v1/fake"] andJSONResponseResource:@"fake" ofType:@"json"];
</code></p>

<p>という風に記述すると、クライアントからここにアクセスしたときに、<code>fake.json</code>が返されます。
NSURLConnectionを使って書くと、</p>

<p>```objective-c
NSURL *api = [NSURL URLWithString:@"http://localhost:12345/api/v1/fake"];
[NSURLConnection sendAsynchronousRequest:[NSURLRequest requestWithURL:api]</p>

<pre><code>                               queue:[[NSOperationQueue alloc] init]
                   completionHandler:^(NSURLResponse *res, NSData *data, NSError *err) {
                     // dataに fake.json が返ってくる
                   }];
</code></pre>

<p>```</p>

<p>このように<code>http://localhost:12345/api/v1/fake</code>へアクセスすると、<code>fake.json</code>が返ってきます。</p>

<p>カテゴリを使ってレスポンスを入れ替えたりするライブラリなんかもありますが、それと比べて、副作用が起こりにくいのが特徴です。
またモックを差し込む、という行為を必要とせず、APIのエンドポイントを入れ替えるだけでよいので、実装自体に手をいれる必要もほとんどありません。</p>

<h2>セットアップ</h2>

<p>Cocoapodsでのセットアップが簡単です。</p>

<p><code>
pod 'NLTHTTPStubServer'
</code></p>

<p><code>NLTHTTPStubServer.h</code>をインポートして使います。</p>

<p>```objective-c</p>

<h1>import "NLTHTTPStubServer"</h1>

<p>```</p>

<h2>機能</h2>

<h3>サーバーの取得</h3>

<p>テスト用サーバーは <code>sharedServer</code> でインスタンスを取得することができます。</p>

<p><code>objective-c
NLTHTTPStubServer *server = [NLTHTTPStubServer sharedServer];
</code></p>

<p><code>clear</code>で登録されているレスポンスをすべて削除し、綺麗な状態にすることができます。</p>

<p><code>objective-c
[server clear];
</code></p>

<p><code>tearDown</code>などでお使いください。</p>

<h3>expect / stub /verify</h3>

<p>0.2.x まででサポートされていた<code>stub</code>が廃止されました。<code>stub</code>というAPIは存在しますが、動作が異なっています。</p>

<h4>expect</h4>

<p><code>expect</code>はレスポンスを登録する一般的な方法です。</p>

<p><code>objective-c
[[server expect] forPath:@"/path"];
</code></p>

<p>このように記述すると、<code>/path</code>へレスポンスが登録されます。
これに対して、メソッドチェインの形式で、必要なものを付加していきます。</p>

<p><code>objective-c
[[[server expect] forPath:@"/api/v1/fake"] andJSONResponseResource:@"fake" ofType:@"json"];
</code></p>

<p><code>expect</code>で登録されたレスポンスは、一度アクセスを受けてそれが返されると、自動的に消化さた状態になります。
<code>/path</code>へ二度アクセスしても、レスポンスは返されません。(例外が投げられます。)</p>

<h4>verify</h4>

<p><code>expect</code>されたものは、<code>verify</code>によって、それが利用されたかを検証することができます。</p>

<p>```objective-c
[[server expect] forPath:@"/path"];</p>

<p>// http://localhost:12345/path へアクセスするコード</p>

<p>[server verify]; // /path へきちんとアクセスされているかを検証
```</p>

<h4>stub</h4>

<p><code>stub</code>は<code>expect</code>と同じインターフェイスを持ちますが、永続的に登録されるレスポンスです。</p>

<p><code>objective-c
[[server stub] forPath:@"/path"];
</code></p>

<p>これは <code>http://localhost:12345/path</code> へアクセスを受けそれが返されても、<strong>消化された状態になりません</strong>。
また、<code>verify</code>による検証では、<code>stub</code>で登録されたものは<strong>無視されます</strong>。</p>

<h3>NLTPath</h3>

<p><code>NLTPath</code>は複雑なURLを表現するために使われる物で、現状では特にGETパラメーターに対応するための機能です。</p>

<p>```objective-c
[[server expect] forPath:[NLTPath pathWithPathString:@"/fake" andParameters:@{</p>

<pre><code>    @"k1" : @"v1",
    @"k2" : @"v2",
</code></pre>

<p>}]];
```</p>

<p>このような記述をした場合、このレスポンスは <code>/fake?k1=v1&amp;k2=v2</code> または <code>/fake?k2=v2&amp;k1=v1</code> にマッチします。</p>

<h4>anyValue</h4>

<p><code>[NLTPath anyValue]</code>を使う事で、値部分をワイルドカードにすることができます。</p>

<p>```objective-c
[[server expect] forPath:[NLTPath pathWithPathString:@"/fake" andParameters:@{</p>

<pre><code>    @"k1" : [NLTPAth anyValue]
</code></pre>

<p>}]];
```</p>

<p>これは、<code>/fake?k1=hogeeeeeeee</code> や <code>/fake?k1=fugaaaaaaaaaa</code> にマッチします。</p>

<h3>付加可能な項目</h3>

<p>メソッドチェインにより付加できる事ができる項目は以下です。</p>

<h4>HTTP Method</h4>

<p><code>objective-c
[[server stub] forPath:@"/fake" HTTPMethod:@"Post"];
</code></p>

<h4>Status code</h4>

<p><code>objective-c
[[[server stub] forPath:@"/fake"] andStatusCode:200];
</code></p>

<h4>Simulate waiting</h4>

<p>タイムアウトなどを再現することができます。</p>

<p><code>objective-c
[[[server stub] forPath:@"/fake"] andProcessingTime:10.0f];
</code></p>

<h4>Checking POST body</h4>

<p>POSTされた内容を調べる事が出来ます。</p>

<p>```objective-c
[[[server expect] forPath:@"/fake" HTTPMethod:@"POST"] andCheckPostBody:<sup>(NSData</sup> *postBody) {</p>

<pre><code>    NSString *postBodyString = [that toString:postBody];
    GHAssertEqualStrings(postBodyString, @"POST_BODY", nil);
}];
</code></pre>

<p>```</p>

<h4>Supporting Content-Types</h4>

<p>自動的にContentTypeを付加してくれるものは以下です。</p>

<p><code>objective-c
[[[server expect] forPath:@"/fake"] and{ContentType}Response...]
</code></p>

<ul>
<li>JSON</li>
<li>HTML</li>
<li>XML</li>
<li>Plain Text</li>
<li>Binary

<ul>
<li>application/octet-stream</li>
</ul>
</li>
</ul>


<p>カスタムのContent-Typeは、<code>andContentTypeHeader</code>によって付加することができます。</p>

<h2>バグなどの報告</h2>

<p><a href="https://github.com/yaakaito/NLTHTTPStubServer/issues">Github Issue</a>で受け付けています。(日本語可)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MagicalRecordの始め方忘れたので思い出しながら書く]]></title>
    <link href="http://yaakaito.org/blog/2013/04/01/magical-record-setup/"/>
    <updated>2013-04-01T00:49:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/04/01/magical-record-setup</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
<a href="https://github.com/magicalpanda/MagicalRecord">MagicalRecord</a>使うかーと思ったけど、やりかた覚えてなかったので書く！やっぱブログ書かないと駄目ですね。</p>

<h2>プロジェクト作る</h2>

<p><code>Use Core Data</code> をチェックする</p>

<h2>xcdatamodeldをいじる</h2>

<p>とりあえずサンプルとして</p>

<p>```
Book:
  name: string
  bookId: integer 16
  authors: [Author]</p>

<p>Author:
  name: string
  type: string
  book: [Book]
```</p>

<p>という感じにした、<code>Book</code>と<code>Author</code>は一対多なので、<code>To-Many Relationship</code>を設定する。</p>

<p><img src="/images/mr-to-many.png"></p>

<p><code>Class</code>とかも忘れずに設定する。</p>

<p><img src="/images/mr-class.png" width="240"></p>

<h2>エンティティのモデルクラス作る</h2>

<p><a href="http://rentzsch.github.com/mogenerator/">mogenerator</a>を使うのが一般的っぽいですが、僕は別に使わなくていいかなーと思ってます。
というのも、mogeneratorって「自動生成されるやつだと変更したあとにマージが大変・・・、なのでCoreDataとビジネスロジックをカテゴリで分ける」的な使われ方をするのかなーと思ってるんだけど、それってそりゃそーじゃね、と思うのです。</p>

<p>僕は、CoreDataから出てきたものは、いうならJSON形式のレスポンスをそのまま<code>NSDicitionary</code>として使ってるのとそんなに違わないよなーと思っていて、なので内部的に<code>NSManagedObject</code>をもってるビジネスロジックを担当するクラスを作ればいいと思う。</p>

<p>とはいえただの決めの問題だし、どっちにしろmogenerator使えば楽出来ることに変わりはないと思うので、mogenerator使っときます。(ていうかこれじゃないと駄目なんだっけ？大丈夫だよね？)</p>

<p>(入ってない人は)<code>brew</code>でmogeneratorをインストールします。</p>

<p><code>
$ brew install mogenerator
</code></p>

<p>mogeneratorが吐き出すクラスを入れるディレクトリなんかを作る。とりあえず <code>CoreData</code> とかにしておく。</p>

<p>準備したらmogeneratorでクラスを吐き出す。</p>

<p><code>
$ mogenerator -m [YourCoreData].xcdatamodeld/[YourCoreData].xcdatamodel -O CoreData/ --template-var arc=true
</code></p>

<p>こんな感じ！ <code>--template-var arc=true</code> 付けないとARC用のコードが出てこないっぽいので注意。</p>

<h2>MagicalRecord入れる</h2>

<p><code>
pod `'MagicalRecord'
</code></p>

<p><code>
$ pod install
</code></p>

<p>いい時代になりましたね。</p>

<h2>MagicalRecord使う</h2>

<p>インポートします。</p>

<p>```objective-c</p>

<h1>define MR_SHORTHAND 1</h1>

<h1>import "CoreData+MagicalRecord.h"</h1>

<p>```</p>

<p>セットアップします。</p>

<p><code>objective-c
[MagicalRecord setupCoreDataStackWithStoreNamed:@"YourCoreData.sqlite"];
</code></p>

<p>使います。</p>

<p>```objective-c
MGBook *book = [MGBook createEntity];
book.name = @"Objective-C";
book.bookId = @(123);</p>

<p>[context saveToPersistentStoreAndWait];
```</p>

<p>簡単ですね！</p>

<p>いつの間にか <code>MR_save</code> じゃなくて、<code>MR_saveToPersistentStoreAndWait</code> と <code>MR_saveToPersistentStoreWithCompletion:</code> になったんですね。こっちの方がいいと思います！！！！</p>

<h2>sqliteのビュアーとか</h2>

<p><a href="https://itunes.apple.com/jp/app/liya/id455484422?mt=12">Liya</a>がおすすめですかね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Overline0.2.0とBlocksKit併用版を公開しました]]></title>
    <link href="http://yaakaito.org/blog/2013/03/30/overline-020-release/"/>
    <updated>2013-03-30T19:13:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/30/overline-020-release</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
Objective-C用ユーティリティ、<a href="https://github.com/yaakaito">Overline</a> 0.2.0を公開しました。0.1.5は6時間くらいの命でした。
同時に0.1.xで問題になっていたBlocksKitと一緒に使うとassertで死ぬ問題を回避した、Overline-BlocksKitを公開しています。</p>

<h2>BlocksKitと一緒に使う場合</h2>

<p>Overline-BlocksKitを利用します。Podfileはこんな感じ。</p>

<p><code>
pod 'BlocksKit'
pod 'Overline-BlocksKit'
</code></p>

<p>重複を解決するために、いくつかショートハンドのメソッドを削除しています。
削除されているのは、<code>NSArray</code> <code>NSDictionary</code> <code>NSSet</code> にある以下のメソッドです。</p>

<ul>
<li><code>each:</code></li>
<li><code>map:</code></li>
<li><code>reduce:memo:</code></li>
<li><code>filter:</code></li>
<li><code>reject:</code></li>
</ul>


<p>ショートハンドは削除されますが、Objective-Cっぽい方はそのまま使えます。このあたりはBlocksKitが実装してくれているので、そちらをご利用ください。</p>

<h2>追加された機能とか</h2>

<p>たらたらと紹介していきます。全部書くのはだるいので全部じゃないです。0.1.0から0.2.0までの変更のうちいろいろという感じです。</p>

<h3>NSArray arrayWithRange</h3>

<p>指定した範囲のNSArrayを作ります、NSNumber自体が使いにくいので、あんまり使わないですかね。</p>

<p><code>objective-c
NSArray *array = [NSArray arrayWithRangeFrom:0 to:10];
// @[@0, @1, @2, @3, @4, @5, @6, @7, @8, @9]
</code></p>

<p>逆方向にも行けます</p>

<p><code>objective-c
NSArray *array2 = [NSArray arrayWithRangeFrom:0 to:-10 step:2];
// @[@0, @-2, @-4, @-6, @-8]
</code></p>

<h3>NSArray uniqueObjects</h3>

<p>まんま、ユニークなものだけ返ってきます。</p>

<p><code>objective-c
NSArray *uniqueObjects = [@[@1, @2, @3, @1, @3, @4, @5] uniqueObjects];
// @[@1, @2, @3, @4, @5]
</code></p>

<p>比較の部分をBlocksで書ける <code>uniqueObjectsUsingEqualsBlock:</code> もあります。</p>

<h3>その他NSArray</h3>

<p><code>subArray</code> <code>diffrence</code> <code>reversed</code> とかが地味に増えました。</p>

<h3>NSDictionary arrayMap</h3>

<p>そもそも<code>map</code>おかしくね？となって、追加した。</p>

<p>```objective-c
[@{</p>

<pre><code>@"a" : @1,
@"b" : @2,
@"c" : @3,
@"d" : @4
</code></pre>

<p>} mappedArrayUsingBlock:<sup>(id</sup> obj, NSString *key) {</p>

<pre><code>return @([obj integerValue] * 2);
</code></pre>

<p>}];
// @[@2,@4,@6,@8]
```</p>

<h3>NSDictionary objectForKey:transformBlock: pathForKey:</h3>

<p><code>objectForKey:</code>したあとに変換してーというのが面倒なので、Blocksでまとめられるようにしました。</p>

<p>```objective-c
NSDate *date = [JSON objectForKey:@"date8601" transformBlock:<sup>id(id</sup> obj) {</p>

<pre><code>NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
[formatter setDateFormat:@"yyyy/MM/dd HH:mm:ss Z"];
return [formatter dateFromString:obj];
</code></pre>

<p>}];
```</p>

<p>とか、あとは<code>stringForKey:</code> <code>dateForKey:usingFormat:</code> <code>bookForKey:withTrueValue:</code> <code>integerForKey:</code> などもろもろ。多いのでREADMEかテストを見てください。</p>

<p><code>objectForPath:</code> は <code>hoge.fuga</code> みたいなので階層を辿れる。 <code>valueForKey</code> とか <code>valueForKeyPath</code> でも出来たはずだけど、本来その目的に使う物ではないはずなので、あんまり使っちゃ駄目だと思います。</p>

<p>こっちの<code>transform</code>とかの対応そういえばやってなかった・・・</p>

<p>多分大きめなのはこれくらいかと思います。はい。</p>

<h2>よろしくね！</h2>

<p><a href="https://github.com/yaakaito">Overline</a></p>
]]></content>
  </entry>
  
</feed>
