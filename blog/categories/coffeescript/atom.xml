<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CoffeeScript | yaakaito.org]]></title>
  <link href="http://yaakaito.github.com/blog/categories/coffeescript/atom.xml" rel="self"/>
  <link href="http://yaakaito.github.com/"/>
  <updated>2013-01-26T18:19:28+09:00</updated>
  <id>http://yaakaito.github.com/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[小さいCoffeeScriptのテストにはVowsが便利]]></title>
    <link href="http://yaakaito.github.com/blog/2012/11/03/vows-coffee-testing/"/>
    <updated>2012-11-03T02:04:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/11/03/vows-coffee-testing</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
小さめのツールをCoffeeScriptで書く機会があったのですが、
テストに使った<a href="http://vowsjs.org/">Vows</a>(<a href="http://vowsjs.jp/">日本語訳</a>)というのが結構良かったです。
一言で言えば、BDDライクで非同期テストに強く、Coffeeと相性のよい、topicという独特の概念をもったフレームワークです。(長い)</p>

<h2>Vowsのセットアップと実行</h2>

<p>npm経由でインストールします。</p>

<p><code>
npm install vows
npm install -g vows
</code></p>

<p>設定ファイルとかは特に必要なく、直接テストファイルを実行します。</p>

<p><code>
vows test.js
</code></p>

<p>CoffeeScriptをそのまま実行することができます。ここが重要</p>

<p><code>
vows test.coffee --spec
</code></p>

<p><code>--spec</code>オプションを付けるといい感じの出力になります。</p>

<h2>Vowsのテストケース</h2>

<p>簡単な例として文字列を反転する<code>reverse</code>というモジュールを考えたときのテストはこんな感じ。
特にCoffeeScriptで書くことにメリットを感じるので、サンプルは全部CoffeeScriptです。</p>

<p>```
vows    = require 'vows'
assert  = require 'assert'
reverse = require 'reverse'</p>

<p>vows
  .describe('reverse')
  .addBatch</p>

<pre><code>'example' :
  topic : -&gt;
    reverse('abc')
  'should return cba' : (str) -&gt;
    assert.equal str, 'cba'
</code></pre>

<p>```</p>

<p><code>describe</code>を定義して、<code>addBatch</code>でテストのまとまりを追加します。
ポイントはさっきからちょっと出てきている<code>topic</code>で、これの実行結果がその下のテストケースへ渡ってきます。
この中は非同期でもokみたいで(今回は試していないけど)、<code>topic</code>の実行が終わったタイミングでテストが走る、という仕組みみたいです。便利ですね。
<code>topic</code>を使っていくとどうしてもモジュールを小さくせざるをえないので、きれいなコードを書くのにはよいと思います。</p>

<p><code>topic</code>とかテストケースはネストすることもできて、例えばabcの他にdefgもテストしたい！とかって場合は、</p>

<p>```
.addBatch
  'example2' :</p>

<pre><code>topic : reverse
'when abc' :
  topic : (f) -&gt; f('abc')
  'should return cba' : (str) -&gt;
    assert.equal str, 'cba'
'when abc' :
  topic : (f) -&gt; f('defg')
  'should return gfed' : (str) -&gt;
    assert.equal str, 'gfed'
</code></pre>

<p>```</p>

<p>こういう感じで書くこともできます、一つ上の<code>topic</code>は次の<code>topic</code>に渡っていくので、テストするスコープを制限することができます。
ただ、ネストしすぎるとちょっと読みにくいですね。</p>

<h2>まとめ</h2>

<p>個人的には、今回みたいにNodeを使って小さいコマンドラインツールとかを全部Coffeeで書くときに使うのがよいかなーという印象でした。
クライアントサイドのテストとかになってくると、長い目で見たときにBusterJSやその他Swarm系使った方がよさそうな印象。
大きめのプロジェクトになってくると、テストケースが要はでかいオブジェクトの定義なので、どうもしんどくなっていく気がする。</p>

<p>テストの為の中間ファイルとして.jsを吐く必要がないので、リポジトリがCoffeeScriptだけできれいに保てるのもポイント。
vowsでカバーできるサイズなら全部CoffeeScriptで書いてしまっても、それなりにモチベーションが保てる。(CoffeeScriptそんなに好きじゃない)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoffeeScriptでライトにBDDする]]></title>
    <link href="http://yaakaito.github.com/blog/2012/10/10/light-coffee-bdd/"/>
    <updated>2012-10-10T00:54:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/10/10/light-coffee-bdd</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
ちょろいCoffeeScript(単発ライブラリ程度)をBDDしながら書くとしたら、
どんな感じにするのが楽かなーと思ったのでちょっとやってみた。</p>

<p>選ぶ以前に、割と最初から何使うかなーってのは決めていて、
grunt+grunt-jasmine-taskの組み合わせです。</p>

<ul>
<li><a href="https://github.com/yaakaito/light-coffee-bdd">light-coffee-bdd</a></li>
</ul>


<h2>grunt-jasmine-task</h2>

<p>grunt-jasmine-taskをnpmから引っ張ってきます。
これはgruntに標準でついてくるtest-taskと同じでphantomjsを使ってテストを実行するタスクです。
requirejs使うといい感じに書けるっぽいです。
package.jsonを適当に作って取ってきます。ついでにcoffee-taskも取ってきます。</p>

<p>```javascript
{
  "name": "project"
  , "version": "0.0.1"
  , "private": true
  , "dependencies": {</p>

<pre><code>"grunt-coffee" : "*"
, "grunt-jasmine-task" : "*"
</code></pre>

<p>  }
}
```</p>

<h2>grunt.js</h2>

<p>grunt.jsにcoffeeのコンパイルとjasmineのタスクを追加します。</p>

<p>```javascript
coffee : {
  app : {</p>

<pre><code>src : [
  'lib/*.coffee'
]
, dest : 'build/'
</code></pre>

<p>  }</p>

<p>  , spec : {</p>

<pre><code>src : [
  'specs/*.coffee'
]
, dest : 'spec_runner/spec/'
</code></pre>

<p>  }</p>

<p>  , runner : {</p>

<pre><code>src : [
  'spec_runner/main.coffee'
]
, dest : 'spec_runner/' 
</code></pre>

<p>  }
}
, jasmine : {
  all : {</p>

<pre><code>src : ['spec_runner/index.html']
, tasks : 'coffee:all'
</code></pre>

<p>  }
}
```</p>

<h2>ランナー</h2>

<p>spec_runner/にランナーを用意します
libとかにjasmineとrequirejsを用意しておきます。
htmlはjasmineをブラウザで実行するときと一緒です。</p>

<p><code>html
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Jasmine Spec Runner&lt;/title&gt;
  &lt;link rel="shortcut icon" type="image/png" href="lib/jasmine-1.2.0/jasmine_favicon.png"&gt;
  &lt;link rel="stylesheet" type="text/css" href="lib/jasmine-1.2.0/jasmine.css"&gt;
  &lt;script type="text/javascript" data-main="main.js" src="lib/require-2.0.2.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>こんな感じ。
で、main.jsからspecを読み込んで実行してあげます。
main.js自体はgruntでcoffeeからコンパイルします。</p>

<p>```coffeescript
config =
  paths :</p>

<pre><code>'jasmine':       'lib/jasmine-1.2.0/jasmine'
'jasmine.html':   'lib/jasmine-1.2.0/jasmine-html'
'jasmine.helper': 'lib/jasmine-1.2.0/jasmine-helper'
</code></pre>

<p>  shim :</p>

<pre><code>'jasmine' :
  'exports' : 'jasmine'
'jasmine.html':   ['jasmine']
'jasmine.helper': ['jasmine']
</code></pre>

<p>require.config config</p>

<p>require ['jasmine', 'jasmine.html', 'jasmine.helper', 'spec/sample_spec'], (jasmine) ->
  jasmineEnv = jasmine.getEnv()
  jasmineEnv.updateInterval = 1000</p>

<p>  htmlReporter = new jasmine.HtmlReporter()</p>

<p>  jasmineEnv.addReporter htmlReporter</p>

<p>  jasmineEnv.specFilter = (spec) -></p>

<pre><code>htmlReporter.specFilter spec
</code></pre>

<p>  jasmineEnv.execute()
```</p>

<p>これで準備完了です。適当なspecを書いてみましょう。</p>

<h2>sample_spec</h2>

<p>gruntで一緒にコンパイルするので、specもcoffeeで書けばよかだと思います。今回は実装がないので何もdefineしてません。</p>

<p>```coffeescript
define [], ->
  describe 'A suite', -></p>

<pre><code>it 'sample spec', -&gt;
  expect(true).toBe true
</code></pre>

<p>```</p>

<p>あとはコンソールから</p>

<p><code>
$ grunt jasmine
</code></p>

<p>で動かします。watch-task書いて動かすのもよいと思います。</p>

<h2>まとめ</h2>

<p>jasmineの部分だけ抽出してますが、実際はこれ+coffeelint+cancat+minifyみたいな構成で書いています。
gruntと使うと簡単なものなら早くセットアップできて、ブラウザもイチイチリロードしなくていいような環境になるので、楽チンですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gruntのcoffeelintタスク作ってみた]]></title>
    <link href="http://yaakaito.github.com/blog/2012/08/21/grunt-coffeelint/"/>
    <updated>2012-08-21T01:59:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/08/21/grunt-coffeelint</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
みなさん<a href="http://www.coffeelint.org/">CoffeeLint</a>使ってますか？
僕はあんまりCoffeeは書かないんですが、ちょっと使ってみようかなーと思っているアプリがあるので、それの下準備をしています。
coffeelintは便利ですがいちいち
<code>
$ coffeelint hoge.coffee
</code>
とかするのはだるいですよね！
なので<a href="https://github.com/cowboy/grunt">grunt.js</a>を使いましょう！
(grunt.jsの説明は別にしません)</p>

<h2>使い方</h2>

<p>ほぼ自分用でnpmとかには登録してないのでがんばってください！</p>

<ul>
<li><a href="https://github.com/yaakaito/grunt-coffeelint">grunt-coffeelint</a></li>
</ul>


<p>まずはCoffeelintを入れます。
<code>
$ npm install -g coffeelint
</code></p>

<p>取ってきます。
<code>
$ git clone git://github.com/yaakaito/grunt-coffeelint.git grunt-coffeelint
</code></p>

<p>タスクをコピーします。
<code>
cd grunt-coffeelint
cp -rf tasks your/grunt/dir
</code></p>

<p>あとはロードしてconfigを埋めます。
```javascript
grunt.loadTasks('tasks');
grunt.initConfig({
  // ...
  coffeelint : {</p>

<pre><code>all : { 
  files : [
    'coffee/*.coffee'
  ]
}
</code></pre>

<p>  }
});
```</p>

<p>いざ！
```
$ grunt coffeelint
Running "coffeelint:all" (coffeelint) task
[ 'coffee/*.coffee' ]</p>

<p>  ✓ coffee/a.coffee
  ✓ coffee/b.coffee</p>

<p>  ✓ Ok! » 0 errors and 0 warnings in 2 files</p>

<p>Done, without errors.
```</p>

<p>やりましたね！！！！</p>

<h2>まとめ</h2>

<p>grunt.js便利なので使いましょう。</p>
]]></content>
  </entry>
  
</feed>
