<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CoffeeScript | yaakaito.org]]></title>
  <link href="http://yaakaito.org/blog/categories/coffeescript/atom.xml" rel="self"/>
  <link href="http://yaakaito.org/"/>
  <updated>2013-04-12T10:15:47+09:00</updated>
  <id>http://yaakaito.org/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[体感的には学ばないBackboneとSpine: Events編]]></title>
    <link href="http://yaakaito.org/blog/2013/04/06/not-head-first-backbone-and-spine-events/"/>
    <updated>2013-04-06T09:42:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/04/06/not-head-first-backbone-and-spine-events</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！頭と体でも学びません。
というわけでBackboneとSpineコードを写経しましょう、根気で覚えます。
そしてヘタクソなりにブログにまとめることで精進します。ショージンショージン。
暇な人は是非一緒にやりましょう！</p>

<p>今回はEvents編です。中核ですね、やりましたね！
Eventsを押さえればMVCなど理解したも当然・・・という訳ではないですが、重要な部類だし、APIの差がほとんどないので読みやすいところです。</p>

<p>写経したコードにはゴミみたいな日本語で解説が書いてあるので、見たい人は合わせてお読みください。(逆に混乱する可能性があるので本家を見た方がいいです)</p>

<p>本家 <a href="https://github.com/documentcloud/backbone/blob/master/backbone.js#L78">Backbone.Events</a> | <a href="https://github.com/spine/spine/blob/master/src/spine.coffee">Spine.Events</a></p>

<p>僕 <a href="https://github.com/yaakaito/Syakyo/blob/master/backbone/events.js">Backbone.Events</a> | <a href="https://github.com/yaakaito/Syakyo/blob/master/spine/events.coffee">Spine.Events</a></p>

<h2>Eventsってなに</h2>

<p>要はObserverパターンです。</p>

<p>BackboneとSpineの間でEventsのAPIの差は、名前が違うくらいでほとんどないです。
どちらも <code>on</code>/<code>bind</code> でイベントをはって、<code>trigger</code>で通知します、簡単ですね。</p>

<p>あとは書いて覚えろ！</p>

<h2>実装方法について</h2>

<p>どちらも<code>this</code>に対して特定のオブジェクトを生成して、そこにイベント情報を突っ込んでいく形です。
オブジェクトとして吐き出されているので、使いたいときは<code>extend</code>して使います。</p>

<p>Backboneは、引数としてthisにバインディングするオブジェクトを取ることができるので、その分複雑になっています。
一方でSpineはそれを取らずに、単純なコールバックのリストして管理しています。<code>=&gt;</code>を使えばよいのでは、ってことだと思う。</p>

<h2>ボリューム感</h2>

<p>さっきも書きましたが、Backboneの方がちょっと複雑です。
コードはJavaScriptとCoffeeScriptなのであれですが、Spineの方がすっきりします。
読むならSpineからがいいかなと思います。</p>

<h2>というわけでいってみよー</h2>

<p>僕が写経したやつを整理して貼っていきます。</p>

<h3>on / bind</h3>

<p>Backbone:
```javascript
on: function(name, callback, context) {</p>

<pre><code>// eventsApiに聞いてみて、オーバーロードされてる形ならあとはeventsApiに任せる
if(!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;

// eventsApiか、きれいな形で呼び出されたとき (not 複数 and マップ)
// イベントを登録する
this._events || (this._events = {}); // _eventsなかったら作る

// すでに同じ名前のイベントがあったらそのArray、なければその名前で新しいArrayを作ってアサイン 
var events = this._events[name] || (this._events[name] = []);       

// イベントを登録
events.push({callback: callback, context: context, ctx: context || this});
return this;
</code></pre>

<p>}
```</p>

<p>Spine:
```coffeescript
bind: (ev, callback) -></p>

<pre><code># 複数登録のパターンなら分割して一個ずつ ex: 'a b c'
evs     = ev.split(' ')
# なかったら作ってから取得
calls   = @hasOwnProperty('_callbacks') and @_callbacks or= {}
for name in evs
    # 対応するものがなければ作る
    calls[name] or = []
    # 登録
    calls[name].push(callback)
return this
</code></pre>

<p>```</p>

<p>Bacbkoneの方で<code>eventsApi</code>というのが登場してますね！
これはBackbone特有の疑似オーバーロードを実装するためのものです。Backboneは結構これがキモですね。
Backboneは以下のようなパターンでイベントを登録することができます。</p>

<p><code>javascript
obj.on('event', callback);
obj.on('event', callback, context);
obj.on('event event2', callback);
obj.on('event event2', callback, context);
obj.on({
  'event' : callback,
  'event2' : callback
}, context);
obj.on({
  'event event2', callback,
  'event3 event4', callback
} , context);
</code></p>

<p>結構複雑ですね。これを解釈していって、最終的に</p>

<p><code>javascript
obj.on('event', callback, context);
</code></p>

<p>この形式になるようにして、必要な回数呼び直すのが<code>eventsApi</code>です。したのは、<code>on</code>から呼ばれたことを前提に説明しています。</p>

<p>```javascript
var eventsApi = function(obj, action, name, rest) {</p>

<pre><code>if (!name) return true; // 名前ないとか論外

// マップ形式だったら
if (typeof name === "object") {
    for (var key in name) {
        /*
        自身の on を呼び直す
        マップ形式
        {
            'name' : callback 
        }
        なので on(name , callback , context) となるようにして全部呼び直す 
        この場合はonのcallbackにはcontextが入っているはずなので(わたってくるのが[context, undefned])、
        結果として on(name , callback , context, undefined) が on(name , callback , context) になる。
        ちょっとトリッキー
        */
        obj[action].apply(obj, [key, name[key]].concat(rest));

        // マップ形式だったので失敗 == 呼び直した、と返す
        return false;
    }
}

// 複数名前が ("hoge fuga piyo") 含まれているときは
if(eventSplitter.test(name)) {
    var names = name.split(eventSplitter);
    for(var i = 0, l = names.length; i &lt; l; i++) {
        /*
        自身の on を呼び出す
        複数なのでsplitして１個づつ呼び直す
        この場合はcallbackはrestに含まれているので、nameだけ設定してconcatすると
        on(name, callback, context) となる
        */
        obj[action].apply(obj, [names[i]].concat(rest));
    }
}

// ここまできた場合は一番シンプルな形 on('hoge', callback, context) で呼び出されているときなので、
// それぞれの処理をお願いするために成功させる
return true;
</code></pre>

<p>}
```</p>

<p>これは他のメソッドの実装でも使われる物なので、最初にどういう動きをするか抑えておきましょう。</p>

<p>spineは結構シンプルで、<code>"event event2"</code>の形にだけ対応しています。</p>

<p>Backboneは<code>context</code>というのがあるので、その分イベントの登録が複雑です。</p>

<p>Backbone:
<code>javascript
events.push({callback: callback, context: context, ctx: context || this});
</code></p>

<p>Spine:
<code>coffeescript
calls[name].push(callback)
</code></p>

<p><code>on</code> / <code>bind</code> はこんな感じです。疑似オーバーロードが面倒ですね。</p>

<h3>trigger</h3>

<p>次にイベントを発火させる<code>trigger</code></p>

<p>Backbone:
```javascript
trigger: function(name) {</p>

<pre><code>if(!this._events) return this; // イベントなんてなかった
var args = slice.call(arguments, 1); // 通常発火用の引数取り出し

// オーバーロード (onを参照)
if(!eventsApi(this, 'trigger', name, args)) return this; 

// 対象になるイベントとってくる
var events = this._events[name];
var allEvents = this._events.all; // 'all'で登録されたもの

// nameに該当するイベントを発火 引数にイベント名なし
if(events) triggerEvents(events, args);

// allのイベントを発火 出元を知る為に引数にイベント名を含める
if(allEvents) triggerEvents(allEvents, arguments);

return this;
</code></pre>

<p>}
```</p>

<p>```javascript
var triggerEvents = function(events, args) {</p>

<pre><code>var ev, i = -1, l = events.length;
while(++i &lt; l) { // _.each じゃ駄目なんだろうか
    (ev = events[i]).callback.apply(ev.ctx, args);
}
</code></pre>

<p>}
```</p>

<p>Spine:
```coffeescript
trigger: (args...) -></p>

<pre><code># 一つ目にイベント名が入っている
ev = args.shift()

# _callbacksからcallbackのリストを取ってくる、無かったら何もしない
list = @hasOwnProperty('_callbacks') and @_callbacks?[ev]
return unless list

for callback in list
    # 失敗したらやめる
    if callback.apply(this, args) is false
        break

return true
</code></pre>

<p>```</p>

<p>基本は一緒ですが、<code>all</code>と引数の扱い方が違います。
Backboneは<code>all</code>として登録されたものも、同時に発火させます。
この時に渡される引数が、イベント名を含めたものになるので、<code>all</code>以外で登録されたものとは引数が異なります。どうなのこれ。</p>

<p>Backboneは<code>context</code>に指定されているものを<code>this</code>にバインドして発火させます。</p>

<h2>off / unbind</h2>

<h2>気になるところがあってですね</h2>

<p>どっちもそうなんだけど、<code>off</code>/<code>unbind</code>、とあと<code>stopListening</code>する時にすべての引数を省略すると全部消す、って動きをする。
要するに疑似オーバーロードなんだけど、これが、一番目の引数のbooleanで分岐してる。</p>

<p>```coffeescript</p>

<h1>Spine</h1>

<p>stopListening: (obj, ev, callback) ->
  if obj</p>

<pre><code># ....
</code></pre>

<p>  else</p>

<pre><code># unbind all
</code></pre>

<p>```</p>

<p>つまりは、現実的に起こる/起こすようなコードを書くのか、というのは置いておいて、</p>

<p><code>javascript
obj.stopListening(undefined);
</code></p>

<p>ってなったときに、イベントが全部消える。実装的に <code>f()</code> と <code>f(undefined)</code> の区別を付ける事が出来ない。
で、これって、<code>arguments.length</code>とかを見るべきだと思うんだけど、どうなんだろ、という疑問。
僕は、メソッド単体としてみたときに上の例は、オブジェクトを元にした<code>unbind</code>/<code>stop</code>であって、オブジェクトがないので、何も出来ない or エラーであってほしいと思う。</p>

<p>正直なところ、こういう挙動をするJavaScriptを、自分では絶対に書かない(書きたくない)ので、よくわからない。
なんで<code>stopListeningAll</code>みたいにメソッド切り分けないの、事故らないしそれでいいじゃん、とか、
引数を全部Objectにして</p>

<p><code>
obj.stopListening({all : true});
</code></p>

<p>とかで、いいじゃん感。こっちのがずいぶん楽だし、コードもすっきりすると思うんだけども。</p>

<p>まあよく分からんとか言ってて助けを待っててもこないので、
Spineに<a href="https://github.com/spine/spine/pull/450">ゴミ屑みたいな英語とともにプルリク</a>してみた。
タイトルはあとで表現がよくなかったことに気づいたので、アテにはしないほうがいい。
Yahoo翻訳を片手に糞英語を書いた結果、とりあえずやりたいことは分かってもらえたっぽい。
で、まあ当然なんだけど、最初に書いたようにコア部分なので、慎重に考えないとね・・・、みたいな感じ。</p>

<p>これ系の実装は気に入らないなーと思ってるし、自分では絶対に作らないので、
僕はこう思うんだけど、というのはすごい勉強になる。的外れな意見でもないっぽいし、とりあえずよかった。
僕はマージされれば嬉しいけど、テストは通ってるとはいえ、変えるのは影響範囲でかいだろうというのも分かってるつもりなので、結構駄目元。</p>

<p>(ぶっちゃけ、Backboneの方はコントリビューターも多すぎるし流速も速いし、そもそも無理だろ。というのはあったのでSpineにしたみたいなところはある。)</p>

<p>あいや、てゆーか、jQueryとかもなんすけどね。セレクトと生成分けろ感とかすごい。
ぼくはあーゆーいんたーふぇいすがきれいとかつかいやすいとはあんまりおもわないな。
(作る方が非現実的だから使うけど)</p>

<h2>次回</h2>

<p>Modelとかやると思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chaplin Overview オレオレ意訳]]></title>
    <link href="http://yaakaito.org/blog/2013/03/15/chaplin-overview-ja/"/>
    <updated>2013-03-15T07:22:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/15/chaplin-overview-ja</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
このエントリは<a href="http://chaplinjs.org/">Chaplin</a>の<a href="https://github.com/chaplinjs/chaplin/blob/master/docs/overview.md">Overview</a>のオレオレ意訳です。あんまり信用はしないでください。
おかしいだろそれ、というのあれば教えてください。</p>

<p><em>italic</em>はこうでは、と思ったのを勝手に足してるところです。</p>

<h2>アーキテクチャ</h2>

<p>ChaplinはJavaScriptでWebアプリケーションを作るためのアーキテクチャで、backboneをベースにしてるよ。
<a href="http://moviepilot.com">moviepilot.com</a>みたいな単一ページの大規模プロジェクトに使われてるよ。</p>

<h2>フレームワーク</h2>

<h3>Application</h3>

<p>ブートストラップ。Chaplinを利用する上で重要なとこだよ。</p>

<h3>Router</h3>

<p>定義されたURLマッピングにしたがって、<code>Controller</code>の各アクションを呼び出すことを助ける部分だよ。
URLの変更などを監視して、責任を持つよ。
でも、<code>Router</code>が直接<code>Controller</code>をキックするんじゃなくて、それは<code>Dispatcher</code>の仕事だよ。</p>

<h3>Route</h3>

<p>Railsに似たURLマッピングを提供するよ。<code>route.coffee</code>みたいなファイル作るといいよ。
こんな感じで定義するよ。</p>

<p><code>coffeescript
match 'likes/:id', 'likes#show'
</code></p>

<p>ルートにマッチしたら、GETパラメータと、パターン一致部分(例で言えば<code>id</code>) <em>と、オプションの引数</em> を持って、<code>matchRoute</code>イベントを発行するよ。
これは<code>Dispacther</code>に引き継がれるよ。</p>

<h3>Dispachter</h3>

<p>ルーティングに関するイベントをListenしてるよ。
対象のイベントが発生したら、それに対応する<code>Controller</code>のインスタンスを生成して、対象のアクション(<code>Controller</code>のメソッド)を呼び出すよ。</p>

<h3>Layout</h3>

<p><code>Layout</code>はアプリケーションの中で一番外側にあるビューだよ。新しい<code>Controller</code>が起動されると、<code>Layout</code>は新しい<code>Controller</code>をメインビューにするよ。</p>

<p><code>Layout</code>はアプリケーション内でのリンクをうまく処理する役割ももつよ。たとえば<code>&lt;a href="http://yaakaito.org/foo"&gt;</code>というリンクなんかも、正しく機能するようにしてくれるよ。</p>

<p>そして、<code>window</code>や<code>document</code>などのトップレイヤーに対するイベントハンドリングなどは<code>Layout</code>で行うよ。</p>

<h3>Mediator</h3>

<p><code>Mediator</code>はpub/subを実装するためのブローカーだよ。
Chaplinアプリケーションでは、ほとんどのモジュール間通信で利用されるべきだよ。
モジュールは<code>this.publishEvent</code>でイベントを発行できるし、<code>this.subscribeEvent</code>でイベントをリッスンできるよ。
例えばユーザーモデルのような永続的でグローバルにアクセス可能なものを共有するために使ったりもできるよ。</p>

<h3>Controller</h3>

<p><em>BackboneのControllerを継承してるよ。だからBackboneの方もちゃんと見た方がいいよ。</em></p>

<p><code>Controller</code>は<code>Model</code>とそれに結びつけられる<code>View</code>をインスタンス化して、管理するよ。
１つの<code>Controller</code>はアプリケーションの１画面を構成するようにするのが普通だよ。
けど、メインビュー的なものを提供して、他に現在のURLを表すためのコントローラーが存在することもあるよ。 <em>(多分HeaderとかFooterなんかの共通パーツのこと？)</em></p>

<p>コントローラーはアプリケーションの機能を定義することが多いよ。
<code>Controller</code>は<code>index</code>や<code>show</code>、<code>edit</code>のようなアクションメソッドを提供することができるよ。
そしてこれらのアクションはURLが一致したときに<code>Dispacther</code>から呼び出されるよ。</p>

<h3>Model</h3>

<p><em>BackboneのModelを継承してるよ。だからBackboneの方もちゃんと見た方がいいよ。</em></p>

<p>データと、それに操作を行うためのロジックをもってるよ。</p>

<h3>Collection</h3>

<p><em>BackboneのCollectionを継承してるよ。だからBackboneの方もちゃんと見た方がいいよ。</em></p>

<p><code>Model</code>のリストを持つためのものだよ。クライアントサイドでフィルタリングをしたり、ソートしたりするためのロジックをもってるよ。</p>

<h3>View</h3>

<p><em>BackboneのViewを継承してるよ。だからBackboneの方もちゃんと見た方がいいよ。</em></p>

<p><code>Model</code>をテンプレートを使って描画したり、その中に含まれるユーザーイベントなどを管理するよ。</p>

<h3>Collection View</h3>

<p><code>Collection</code>のためのビューだよ。それぞれの<code>Model</code>に対する<code>View</code>を作って、それを管理するよ。</p>

<h2>アプリケーションの起動フロー</h2>

<p>アプリケーションは、<code>Chaplin.Application</code>を継承したところから始まるよ。
<code>Application</code>では<code>Dispacther</code> <code>Layout</code> <code>Mediator</code> <code>Router</code> の順で、これらをインスタンス化してセットアップしてね。</p>

<p><code>Router</code>に<code>Route</code>を登録するよ。普通は設定ファイルとして<code>route.coffee</code>か<code>route.js</code>使うよ。
<code>Route</code>は<code>Controller</code>のアクションにURLパターンをマッピングするよ、たとえば<code>/</code>なら<code>HomeController</code>の<code>index</code>、という感じだよ。</p>

<p>ここまで終わったら、<code>initRouter</code>を呼び出して、URLの監視を始めよう。URLにマッチするパターンであれば、<code>Dispacther</code>や他のモジュールへ通知するよ。</p>

<p><code>Dispacther</code>まで来たら、対象の<code>Controller</code>をインスタンス化して、対応するアクションを呼び出すよ。
<code>Dispachter</code>はアクティブな<code>Controller</code>を管理していて、必要ないものを破棄するよ。</p>

<p>対応するアクションが呼び出されたら、<code>Model</code>や<code>Collection</code>を<code>Ctonroller</code>で生成して、それに対応する<code>View</code>をレンダリングしていくのがよくある流れだよ。
<code>Model</code>や<code>Collection</code>は必要に応じてサーバーからデータを取得したりするよ。
<code>Model</code>や<code>Collection</code>と、それに対応する<code>View</code>は、<code>Controller</code>によって管理されるのが通例だよ。</p>

<h2>メモリ管理について</h2>

<p>Chaplinでは、適切なメモリ管理を行う、というのがコアにあるよ。</p>

<p>みんな、あまりJavaScriptでGCやメモリ管理に関する議論をしないけど、それは重要なトピックだよ。
イベントドリブンで動くシステムは、イベントを登録するときにオブジェクト間の参照が発生するし、それが削除されないと、メモリ解放されないよ。</p>

<p>だから、ChaplinではBackboneのModel、Collection、View、Controllerを拡張して、それらのクリーンアップを保証して、パワフルな処理プロセスを実装できるようにしているよ。</p>

<h2>終わり</h2>

<p>起動フローとかはコードと付き合わせないと分かりにくいところが多いと思うので、<a href="https://github.com/paulmillr/ostio/blob/master/app/application.coffee">ost.ioのブート</a>とか合わせて読むといいと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BrunchでJavaScriptアプリはじめる手順]]></title>
    <link href="http://yaakaito.org/blog/2013/03/08/hello-brunch/"/>
    <updated>2013-03-08T08:14:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/08/hello-brunch</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
最近<a href="http://brunch.io/">Brunch</a>というものを知ったので、とりあえずはじめてみたときのメモです。
正確には<a href="http://chaplinjs.org/">Chaplin</a>を先に知って、結構良さげだし試してみよーとか思ったところが始まりなので、brunch-with-chaplinを前提にしてます。(今回はchaplinの話はしません。)</p>

<h2>brunchってそもそも何</h2>

<p>gruntとか使っている人は、gruntにgiter8をくっつけて++というイメージが分かりやすいかと思います。Yeomanとかその系列のものです。
レイヤーが違うので比較してもあんまり意味はないんですが、grunt使っていた頃からすると、</p>

<ul>
<li>最初からCoffeeScriptのことを考えているので、CoffeeScript使う場合は嬉しい (最近はそうでもないみたいだけど)</li>
<li>プロジェクトのひな形作りやすいのは嬉しい</li>
<li>ビルトインサーバーがあるので、<code>watch --server</code> みたいなの出来て嬉しい</li>
<li>Mocha+phantomjsを最初から生成してくれるので、テストドリブンで始めるが楽</li>
<li>ブラウザのオートリロードとかもあるよ！</li>
</ul>


<p>という感じで、gruntみたいに自分でタスク組んで〜とやるよりは、サクッと開発を始められる感じです。
そこまで使ってないし、まだよくわからんので説明はこのくらいで。</p>

<p>CommonJSっぽいモジュールシステムとかはまあ一長一短だと思うのであんまり。</p>

<h2>はじめる</h2>

<p>brunchをインストールします。(node 0.6.10 ~)</p>

<p><code>
$ npm install -g brunch
</code></p>

<h3>プロジェクトのひな形を作る</h3>

<p>Githubからテンプレートを引っ張ってきて作ります。今回はchaplinが使いたかったので、brunch-with-chaplinを引っ張ってきます。</p>

<p><code>
$ brunch new &lt;app-name&gt; --skeleton https://github.com/paulmillr/brunch-with-chaplin
</code></p>

<p>簡単ですね。<code>tree</code>してみるとこんな感じになってます。</p>

<p><code>
$ tree -L 2 -F --dirsfirst
.
├── app/
│   ├── assets/
│   ├── controllers/
│   ├── lib/
│   ├── models/
│   ├── views/
│   ├── application.coffee
│   ├── initialize.coffee
│   ├── mediator.coffee
│   └── routes.coffee
├── generators/
│   ├── collection/
│   ├── collection-test/
│   ├── collection-view/
│   ├── controller/
│   ├── controller-test/
│   ├── generator/
│   ├── model/
│   ├── model-test/
│   ├── style/
│   ├── template/
│   ├── view/
│   └── view-test/
├── node_modules/
│   ├── chai/
│   ├── clean-css-brunch/
│   ├── coffee-script-brunch/
│   ├── css-brunch/
│   ├── handlebars-brunch/
│   ├── javascript-brunch/
│   ├── sinon/
│   ├── sinon-chai/
│   ├── stylus-brunch/
│   └── uglify-js-brunch/
├── test/
│   ├── assets/
│   ├── vendor/
│   ├── views/
│   └── test-helpers.coffee
├── vendor/
│   ├── scripts/
│   └── styles/
├── README.md
├── config.coffee
└── package.json
</code></p>

<p><code>config.coffee</code>にいろいろ設定が書いてあるんですが、長いので別で書きます。</p>

<p>とりあえずビルドしてみます。</p>

<p><code>
$ brunch build
</code></p>

<p><code>/public</code>ができて、ここにもろもろ生成されたファイルが入っています。デプロイのときはここを使えばよいっぽい。</p>

<p>ビルトインサーバーを使ってアプリを起動してみる。</p>

<p><code>
$ brunch watch --server
$ open http://localhost:3333/
</code></p>

<p><img src="/images/hello-brunch.png"></p>

<p>こういう感じにアプリが起動していることがわかります、やりましたね！</p>

<h2>テストを走らせる</h2>

<p>サーバー起動してる状態で、<code>/public</code>の中に出来たテストランナーをブラウザで開けば普通にテストが走ります。
phantomjs使いたいときは、</p>

<p><code>
$ brunch test
</code></p>

<p>でよいらしいです。(使ってない)</p>

<h2>他の環境でのセットアップ</h2>

<p>brunchベースのプロジェクトにコミットするときは、
見た感じ、<code>npm install</code>すればよさそうなので試してみる</p>

<p><code>
$ npm install
$ brunch w --server
</code></p>

<p>出来た、これでよさげ。</p>

<p>使ってみてあーだこうだはもうちょっとしてから書こうと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[buster-html-docとあとcoffee]]></title>
    <link href="http://yaakaito.org/blog/2013/03/02/buster-html-doc-and-coffee/"/>
    <updated>2013-03-02T14:40:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/02/buster-html-doc-and-coffee</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
<a href="http://yaakaito.github.com/blog/2013/03/01/buster-testbed-and-boot/">前回BusterJSのtestbedの話</a>を書いたのですが、</p>

<p><blockquote><p>@yaakaito HTMLを用意するまでもない場合は buster-html-doc とかも良いと思いますがどうでしょう！</p><footer><strong>@y_imaya</strong> <cite><a href='https://twitter.com/y_imaya/status/307347977712848896'>twitter.com/y_imaya/status/&hellip;</a></cite></footer></blockquote></p>

<p>という意見をもらったので、こっちのことも書いておこうと思いました。</p>

<h2>そもそもbuster-html-docって何</h2>

<p>BusterJSはJSTestDriver形式で書かれたテストケースの実行をサポートしているのですが、JSTestDriverに<a href="http://code.google.com/p/js-test-driver/wiki/HtmlDoc">HTML Doc</a>という昨日があります。
この部分だけをBusterJS用に切り出したのがbuster-html-docで、前回のようにHTMLを用意するまでもない場合に</p>

<p><code>javascript
/*:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;*/
assert.equals(this.hoge.innerHTML, 'aaaa');
</code></p>

<p>という風にテスト毎にエレメントを生成することができます。</p>

<h2>使い方</h2>

<p><code>buster-html-doc</code>をnpmからインストールします。</p>

<p><code>
$ npm install buster-html-doc
</code></p>

<p><code>buster.js</code>でbuster-html-docを読み込むようにします。</p>

<p>```javascript
var config = module.exports;</p>

<p>config["browser test"] = {
  env : "browser",
  tests : [</p>

<pre><code>"test.js"
</code></pre>

<p>  ],
  extensions: [require("buster-html-doc")] // これ
}
```</p>

<p>こういう感じにテストを書きます。</p>

<p>```javascript
buster.testCase('hoge', {</p>

<pre><code>'test html doc' : function() {
    /*:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;*/
    assert.equals(this.hoge.innerHTML, 'aaaa');
}
</code></pre>

<p>})
```</p>

<p>これでテストを実行すると、テスト時に<code>/*:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;*/</code>の部分が、</p>

<p>```javascript
this.hoge = (function () {</p>

<pre><code>var element = document.createElement("div");
element.innerHTML = "&lt;p&gt;aaaa&lt;/p&gt;";if (element.childNodes.length &gt; 1) {
    throw new Error("HTML doc expected to only contain one root node, found " + element.childNodes.length); 
}
return element.firstChild; 
</code></pre>

<p>}());
```</p>

<p>という感じに変換されます。
あとはこのエレメントを使ってアサーションするなりできます。</p>

<p>上の例では<code>this.hoge</code>に対してエレメントを生成していますが、
そうではなく<code>body</code>とかに突っ込んでほしい場合は、<code>+=</code>を使って書く事もできます。</p>

<p><code>javascript
/*:DOC += &lt;p id="hoge"&gt;aaaa&lt;/p&gt;*/
assert.equals(document.getElementById('hoge').innerHTML, 'aaaa');
</code></p>

<p>という感じなのがbuster-html-docプラグインです。</p>

<h2>buster-coffee</h2>

<p>続いてbuster-coffeeなのですが、名前の通りテスト実行時にCoffeeScriptをコンパイルしてくれるので、コードをCoffeeScriptで書けるよ、というものです。
これ自体は特にめんどくさくなくて、npmでインストールして、</p>

<p><code>
$ npm install buster-coffee
</code></p>

<p>```javascript
var runner = module.exports;</p>

<p>runner["browser test"] = {
  env : "browser",
  tests : [</p>

<pre><code>"test.coffee" // coffee
</code></pre>

<p>  ],
  extensions: [require("buster-coffee")]
}
```</p>

<p>という風に使えばよいのですが、buster-html-docと少し相性の問題があるみたいで、</p>

<p><code>javascript
extensions: [require("buster-coffee"), require("buster-html-doc")]
</code></p>

<p>こういう感じにして、</p>

<p>```coffeescript
buster.testCase 'hoge',</p>

<pre><code>'test html doc' : -&gt;
    ###:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;###
    assert.equals(this.hoge.innerHTML, 'aaaa');
</code></pre>

<p>```</p>

<p>こう書いても、</p>

<blockquote><p>TypeError: Cannot read property 'innerHTML' of undefined</p></blockquote>

<p>となります。</p>

<p>コンパイルされるとHTML Docの部分は</p>

<p><code>javascript
/*:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;
*/
</code></p>

<p>こうなるはずなので、一見大丈夫そうに思えるんですが、うまくいきません。
というか自分でコンパイルするとちゃんと動くので、プラグインの実行順か、それぞれの実行タイミングが悪いのかみたいな話だと思います。</p>

<p>ハマりやすいので気をつけましょう。</p>

<p>回避策としてはプラグインのところ見直してプルリクエストが一番早そうなんですが、
僕は他の理由もあって先にcoffeeを別にコンパイルするようにしてしまいました。</p>

<h2>おまけ</h2>

<p>HTML Doc形式の書式が結構便利で、最近関わっているプロダクトだと</p>

<p>```coffeescript</p>

<h3>:XHR /hoge = {</h3>

<pre><code>fuga : 'fuga',
piyo : 'piyo'
</code></pre>

<p>}</p>

<h2>#</h2>

<h1>/hoge にアクセスしたらこのレスポンスが返ってくる (XHR部分のラッパー有)</h1>

<p>```</p>

<p>みたいにして通信部分をモックできるようしてみた、便利。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小さいCoffeeScriptのテストにはVowsが便利]]></title>
    <link href="http://yaakaito.org/blog/2012/11/03/vows-coffee-testing/"/>
    <updated>2012-11-03T02:04:00+09:00</updated>
    <id>http://yaakaito.org/blog/2012/11/03/vows-coffee-testing</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
小さめのツールをCoffeeScriptで書く機会があったのですが、
テストに使った<a href="http://vowsjs.org/">Vows</a>(<a href="http://vowsjs.jp/">日本語訳</a>)というのが結構良かったです。
一言で言えば、BDDライクで非同期テストに強く、Coffeeと相性のよい、topicという独特の概念をもったフレームワークです。(長い)</p>

<h2>Vowsのセットアップと実行</h2>

<p>npm経由でインストールします。</p>

<p><code>
npm install vows
npm install -g vows
</code></p>

<p>設定ファイルとかは特に必要なく、直接テストファイルを実行します。</p>

<p><code>
vows test.js
</code></p>

<p>CoffeeScriptをそのまま実行することができます。ここが重要</p>

<p><code>
vows test.coffee --spec
</code></p>

<p><code>--spec</code>オプションを付けるといい感じの出力になります。</p>

<h2>Vowsのテストケース</h2>

<p>簡単な例として文字列を反転する<code>reverse</code>というモジュールを考えたときのテストはこんな感じ。
特にCoffeeScriptで書くことにメリットを感じるので、サンプルは全部CoffeeScriptです。</p>

<p>```
vows    = require 'vows'
assert  = require 'assert'
reverse = require 'reverse'</p>

<p>vows
  .describe('reverse')
  .addBatch</p>

<pre><code>'example' :
  topic : -&gt;
    reverse('abc')
  'should return cba' : (str) -&gt;
    assert.equal str, 'cba'
</code></pre>

<p>```</p>

<p><code>describe</code>を定義して、<code>addBatch</code>でテストのまとまりを追加します。
ポイントはさっきからちょっと出てきている<code>topic</code>で、これの実行結果がその下のテストケースへ渡ってきます。
この中は非同期でもokみたいで(今回は試していないけど)、<code>topic</code>の実行が終わったタイミングでテストが走る、という仕組みみたいです。便利ですね。
<code>topic</code>を使っていくとどうしてもモジュールを小さくせざるをえないので、きれいなコードを書くのにはよいと思います。</p>

<p><code>topic</code>とかテストケースはネストすることもできて、例えばabcの他にdefgもテストしたい！とかって場合は、</p>

<p>```
.addBatch
  'example2' :</p>

<pre><code>topic : reverse
'when abc' :
  topic : (f) -&gt; f('abc')
  'should return cba' : (str) -&gt;
    assert.equal str, 'cba'
'when abc' :
  topic : (f) -&gt; f('defg')
  'should return gfed' : (str) -&gt;
    assert.equal str, 'gfed'
</code></pre>

<p>```</p>

<p>こういう感じで書くこともできます、一つ上の<code>topic</code>は次の<code>topic</code>に渡っていくので、テストするスコープを制限することができます。
ただ、ネストしすぎるとちょっと読みにくいですね。</p>

<h2>まとめ</h2>

<p>個人的には、今回みたいにNodeを使って小さいコマンドラインツールとかを全部Coffeeで書くときに使うのがよいかなーという印象でした。
クライアントサイドのテストとかになってくると、長い目で見たときにBusterJSやその他Swarm系使った方がよさそうな印象。
大きめのプロジェクトになってくると、テストケースが要はでかいオブジェクトの定義なので、どうもしんどくなっていく気がする。</p>

<p>テストの為の中間ファイルとして.jsを吐く必要がないので、リポジトリがCoffeeScriptだけできれいに保てるのもポイント。
vowsでカバーできるサイズなら全部CoffeeScriptで書いてしまっても、それなりにモチベーションが保てる。(CoffeeScriptそんなに好きじゃない)</p>
]]></content>
  </entry>
  
</feed>
