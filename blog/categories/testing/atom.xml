<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Testing | yaakaito.org]]></title>
  <link href="http://yaakaito.org/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://yaakaito.org/"/>
  <updated>2013-03-24T01:24:27+09:00</updated>
  <id>http://yaakaito.org/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mocha + Testem + HTMLCov 出来るようにする]]></title>
    <link href="http://yaakaito.org/blog/2013/03/23/testing-mocha-testem-htmlcov/"/>
    <updated>2013-03-23T14:32:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/23/testing-mocha-testem-htmlcov</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！だるくなくJavaScript開発できる環境を探しています。</p>

<p>というわけでタイトル通りなんですが、Mocha + Testem + HTML-Cov環境を試してみようと思うので、それの作り方です。
想定している使い方としては、普段はTestemを使ってChrome、Firefox、Safariあたりでテストを回しつつ、たまにカバレッジを確認して〜くらいの割と普通な感じです。
CIは今回はやりません。本当は同じランナーでやりたかったんですが、めんどいので分けました。
もっといいやり方知ってる人いたら教えてください！</p>

<p><a href="https://github.com/yaakaito/mocha-testem-htmlcov">作られたリポジトリはgithubにあります。</a></p>

<h2>必要な物の準備</h2>

<p>せっかくなので？ node 0.10.1 を使います。</p>

<p><code>
$ nvm install 0.10.1
</code></p>

<p>必要なモジュールをいれます。</p>

<ul>
<li>testem</li>
<li>mocha</li>
<li>jscoverage</li>
<li>json2htmlcov</li>
<li>mocha-phantomjs

<ul>
<li>phantomjs</li>
</ul>
</li>
</ul>


<p><code>
$ brew install phantomjs
</code></p>

<p><code>
$ npm install -g testem mocha mocha-phantomjs jscoverage json2htmlcov
</code></p>

<p>メンドーだったので僕は<code>Makefile</code>使ってますが、<code>grunt</code>とかがいいですって人はそれもいれるといいと思います。</p>

<h3>chaiとsinonをとってくる</h3>

<p>chaiとsinonを使いたいので、とってきます。sinon-chaiは別にいらないかなーと思ってる子なので入れてません。
<code>/test/vendor</code> みたいなところに配置しておきます。</p>

<p><code>
$ curl -O http://chaijs.com/chai.js
$ curl -O http://sinonjs.org/releases/sinon-1.6.0.js
</code></p>

<h2>適当にテスト用のjs書く</h2>

<p>サンプル用に適当に</p>

<p>```javascript
// /src/sample.js
var A = (function(){
  function A() {</p>

<p>  }
  A.prototype.method = function(v) {</p>

<pre><code>if (v) {
  return "YES";
}
else {
  return "NO";
}
</code></pre>

<p>  }
  return A;
})();
```</p>

<p>テストはこんな感じ、<code>NO</code>の方は通らないようにしてあります。</p>

<p>```
// /test/tests/sample-tests.js
describe('Sample', function(){
  var a;
  beforeEach(function(){</p>

<pre><code>a = new A();
</code></pre>

<p>  });</p>

<p>  it('YES', function(){</p>

<pre><code>chai.expect(a.method(true)).to.equals('YES');
</code></pre>

<p>  })
});
```</p>

<h2>testem.jsonを書く</h2>

<p>chaiやsinonを一緒に混ぜるようにして、<code>testem.json</code>を作ります。</p>

<p>```javascript
{
  "framework" : "mocha",
  "src_files" : [</p>

<pre><code>"src/**/*.js",
"test/vendor/chai.js",
"test/vendor/sinon.js",
"test/tests/**/*-tests.js"
</code></pre>

<p>  ]
}
```</p>

<p>これでtestem側は終わりです。走らせてみましょう。</p>

<p><code>
$ testem
</code></p>

<p><img src="/images/testem-run.png"></p>

<p>テストしたいブラウザで <code>http://localhost:7357</code> を開きます。あとは開きっぱでよいです。</p>

<p><img src="/images/testem-browsers.png"></p>

<p><img src="/images/testem-result.png"></p>

<p>テストしてくれます、便利ですね。</p>

<h2>HTMLCovでカバレッジを出す</h2>

<p>こういう感じにカバレッジを出す事ができます。</p>

<p><img src="/images/htmlcov.png"></p>

<p>適当にいろいろなブラウザでテストした結果をマージできると理想だけど、面倒そうなのでphantomjsで・・・ 、というか<a href="https://github.com/visionmedia/mocha/issues/281">サポートされていない</a>のかな。
<a href="https://github.com/visionmedia/mocha/pull/506">こういうのもあったけど</a>今回はスルーで。</p>

<p>手順としては</p>

<ul>
<li><code>jscoverage</code> で対象のjsを変換</li>
<li><code>mocha-phantomjs</code> で実行して <code>jsoncov</code> の形で吐き出す</li>
<li><code>json2htmlcov</code> を通して HTMLCov へ変換</li>
</ul>


<p>と、ちょっと面倒くさい。</p>

<h3>ランナーを用意する</h3>

<p><code>mocha</code> のランナーを用意します。</p>

<p><code>
$ mocha init [dir]
</code></p>

<p>吐き出されたのを適当に <code>coverage-runner.html</code> みたいなのにリネームして、必要なファイルを読み込むようにする。</p>

<p>```html</p>

<script src="../cover/sample.js"></script>


<script src="./vendor/mocha.js"></script>


<script src="./vendor/chai.js"></script>


<script src="./vendor/sinon.js"></script>


<script>mocha.setup('bdd')</script>


<script src="./tests/sample-tests.js"></script>


<p>```</p>

<p>僕はカバレッジに使うjsを<code>cover</code>というディレクトリに吐き出すようにしたので、こんな感じで。</p>

<p><code>mocha-phantomjs</code> を使えるようにブートを置き換えます。</p>

<p>```javascript</p>

<script>
  if (window.mochaPhantomJS) {
    mochaPhantomJS.run()
  }
  else {
    mocha.run();
  }
</script>


<p>```</p>

<h3>カバレッジを出すコマンド</h3>

<p>さっきの手順に従ったコマンドで実行します。</p>

<p><code>
$ jscoverage src/sample.js ./cover/
$ mocha-phantomjs -R json-cov test/cover-runner.html | json2htmlcov &gt; cover.html
</code></p>

<p>こんな感じで <code>cover.html</code> が作られるので、あとはそれを<code>open</code>すればよいです。</p>

<p>ちょっと面倒ですが、簡単な部類でしたね。</p>

<h2>ちなみに</h2>

<p>僕は Buster.JS 派です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hosted CIでiOSライブラリ(Overline)のテスト回してみた]]></title>
    <link href="http://yaakaito.org/blog/2013/03/15/hosted-ci-with-ocunit/"/>
    <updated>2013-03-15T02:05:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/15/hosted-ci-with-ocunit</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
<a href="https://hosted-ci.com/">Hosted CI</a>という、なんとMac環境でのJenkinsをホスティングしてくれるという超絶便利サービスがあるのですが、
そこで<a href="https://github.com/yaakaito/overline">Overline</a>のテストを回してみました。(Hosted CIはまだベータ版みたいです。)</p>

<p>参考までに、というかいろいろありそうなので、書いた時点でのOverlineの開発環境を先に乗せておきます。</p>

<ul>
<li>OS 10.7.5</li>
<li>AppCode 1.6</li>
<li>Xcode 4.5</li>
<li>Cocoapods 0.15.2

<ul>
<li>OCHamcrest 1.9</li>
</ul>
</li>
</ul>


<p>コードはAppCodeで書いています。(Hosted CI関係ないけどAppCodeの問題もあったので下に書きます)
テストはSenTestingKit + OCHamcrest。
いろいろあってメインマシンでやらなかったので、ちょっと古いです。</p>

<h2>Hosted CI へ登録する</h2>

<p>OpenSourceだしfree planで登録しました。
ちょっと時間がかかったので、先にローカルでやれることをやっておきます。</p>

<h2>ローカルでテストをビルドする</h2>

<p>とりあえずローカルでテストがビルドできないと話にならないので、そっちを確認します。
Cocoapods込みで<code>xcodebuild</code>するのが思えば始めてだったので、ちょっと面倒でした。</p>

<p>まずテスト用のSchemeを作ります。
ビルドの設定へ<code>Jenkins</code>という名前のschemeを定義してあげます。</p>

<p><img src="/images/appcode-jenkins-scheme.png"></p>

<p>ところでこのschemeをjenkinsから使うのかと思ったんですが、実はいらなかったので、自身のある人はやらなくてよいかもしれません。
作ったら<code>xcodebuild</code>で<code>-list</code>してみましょう。</p>

<p>```
$ xcodebuild -workspace Overline.xcworkspace -list
Information about workspace "Overline":</p>

<pre><code>Schemes:
    ...
    Jenkins
</code></pre>

<p>```</p>

<p>こんな感じに出てきたら準備完了です。<code>xcodebuild</code>で<code>Jenkins</code>のshcemeをビルドします</p>

<p><code>
$ xcodebuild -workspace Overline.xcworkspace -scheme 'Jenkins' -configuration 'Debug' -sdk iphonesimulator clean build
</code></p>

<h2>Hosted CI へログイン</h2>

<p>登録できたっぽいメールがきたので、Hosted CI へログインしましょう！ログインするとDashboardが出てきます。何個かプロジェクトがありますね。</p>

<p><img src="/images/hosted-ci-dashboard.png"></p>

<p>下の方にある Create new project からプロジェクトを追加します。</p>

<p><img src="/images/hosted-ci-create.png"></p>

<h2>プロジェクトの作成</h2>

<p>新しいプロジェクトのセットアップを始めます。</p>

<p><img src="/images/hosted-ci-new-project.png"></p>

<p>おおーここから大まかな設定は出来るのかー。便利だなー。
けどスクリプトとかどうせ書くんだろうしだるいなぁ、とか思いながらセットアップして、 Create Project します。さて次はめんどうな・・・</p>

<p><img src="/images/hosted-ci-config-xcode.png"></p>

<p>なん・・・だと・・・</p>

<p><img src="/images/hosted-ci-selected-target.png"></p>

<p>こいつは・・・まさか・・・ 力強くUpdateします。</p>

<p><img src="/images/hosted-ci-created-project.png"></p>

<p>プロジェクトのページができます。ビルドします。</p>

<p><img src="/images/hosted-ci-jenkins-console.png"></p>

<p><img src="/images/hosted-ci-test-complete.png"></p>

<p>俺の知ってるJenkins+iOSと違う・・・。</p>

<p>という感じで拍子抜けするくらい簡単にセットアップが出来てしまいました。
(正確にはAppCodeの問題で2~3回ビルドしたんですが、それは後述します。)</p>

<p>なにげにPodfileのサポートとかも入っててすごい・・・。</p>

<h2>GithubにPushしたときにHookでテスト</h2>

<p>HookのURLが提供されているので、それを使います。プロジェクトのページにあります。</p>

<p><img src="/images/hosted-ci-github-hook.png"></p>

<p>あとはGithubからJenkins Hook URL を設定して終わりです。</p>

<p><img src="/images/github-jenkins-hook.png"></p>

<h2>と、というわけで</h2>

<p>あっさり動いてしまいましたね・・・？</p>

<p><img src="http://tiqav.com/et.jpg"></p>

<p>あ、いや本当に超絶素晴らしいサービスだと思いますし、フィードバックなどしつつ使わせて頂こうと思います、はい。</p>

<h2>【おまけ】AppCode使っててうまくいかなかった話</h2>

<p>Cocoapodsを使うときに、</p>

<p><blockquote><p>[!] Xcodeproj doesn't know about the following attributes lastKnownFileTypetext for the 'PBXGroup' isa.</p></blockquote></p>

<p>こういう感じになってしまったので、何かなーと思ったら、</p>

<p><blockquote><p>Overline これにはまってた  "Problematic attribute added to PBXGroup when renaming group using AppCode : OC-5881"  http://bit.ly/13XdHU8</p><footer><strong>@azu_re</strong> <cite><a href='https://twitter.com/azu_re/status/312065250436456448'>twitter.com/azu_re/status/&hellip;</a></cite></footer></blockquote></p>

<p>というのを見つけて、<a href="http://bit.ly/13XdHU8">リンク先</a>見てみたらどうもこれっぽい。
<code>lastKnownFileType = text;</code> というのが入ってしまうのだとか。</p>

<p>僕の場合はNSNumberのグループに入ってたので、<a href="https://github.com/yaakaito/Overline/commit/01fbeaf306a56319485e394d56b249bd502cab30">これ消したら</a>なおった。</p>

<p>ありがとうございます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Brunchプロジェクトでtestemを使う]]></title>
    <link href="http://yaakaito.org/blog/2013/03/14/brunch-withw-testem/"/>
    <updated>2013-03-14T16:36:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/14/brunch-withw-testem</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
<a href="http://yaakaito.org/blog/2013/03/08/hello-brunch/">前回</a>みたいな手順で始めたChaplinのプロジェクトで<a href="https://github.com/airportyh/testem">testem</a>を使う手順です。
Brunch with Chaplinを使っていますが、Brunchプロジェクトなら多分大体同じ感じでいけると思います。</p>

<h2>testemの準備</h2>

<p>testemがないと始まらないのでtestemをインストールします。</p>

<p><code>
$ npm install -g testem
</code></p>

<h2>testem.jsonの設定</h2>

<p>BrunchはデフォルトでMochaを使ったテストのテンプレートを作ってくれるので、これを参考にします。
<code>brunch build</code>すると、<code>/public/test/index.html</code>ができるので、これを参考に書いていきます。</p>

<p>```javascript
{
  "framework" : "mocha",
  "src_files" : [</p>

<pre><code>"public/javascripts/vendor.js",
"public/javascripts/app.js",
"public/test/javascripts/test-vendor.js",
"public/test/javascripts/test.js"
</code></pre>

<p>  ]
}
```</p>

<p>これをプロジェクトのルートに配置します。</p>

<h2>brunchが生成するmochaを消す</h2>

<p>brunchはmochaやsinonを <code>public/test/javascripts/test-vendor.js</code> にまとめてビルドしているので、このビルドからmochaを外します。とりあえず <code>rm</code> してしまいます。</p>

<p><code>
$ rm test/vender/scripts/mocha[version].js
</code></p>

<h2>brunch watchを起動する</h2>

<p>brunchはテストをまとめて <code>public/test/javascripts/test.js</code> にビルドしてくれます。
なのでtestem側からはこれを見ているだけでOKです。便利ですね。</p>

<p><code>
$ brunch w -s
</code></p>

<p>ついでなのでサーバーも立てておきます。</p>

<h2>testemでテストする</h2>

<p>あとはtestemでテストするだけです。</p>

<p><code>
$ testem
</code></p>

<p>便利ですね！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[buster-html-docとあとcoffee]]></title>
    <link href="http://yaakaito.org/blog/2013/03/02/buster-html-doc-and-coffee/"/>
    <updated>2013-03-02T14:40:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/02/buster-html-doc-and-coffee</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
<a href="http://yaakaito.github.com/blog/2013/03/01/buster-testbed-and-boot/">前回BusterJSのtestbedの話</a>を書いたのですが、</p>

<p><blockquote><p>@yaakaito HTMLを用意するまでもない場合は buster-html-doc とかも良いと思いますがどうでしょう！</p><footer><strong>@y_imaya</strong> <cite><a href='https://twitter.com/y_imaya/status/307347977712848896'>twitter.com/y_imaya/status/&hellip;</a></cite></footer></blockquote></p>

<p>という意見をもらったので、こっちのことも書いておこうと思いました。</p>

<h2>そもそもbuster-html-docって何</h2>

<p>BusterJSはJSTestDriver形式で書かれたテストケースの実行をサポートしているのですが、JSTestDriverに<a href="http://code.google.com/p/js-test-driver/wiki/HtmlDoc">HTML Doc</a>という昨日があります。
この部分だけをBusterJS用に切り出したのがbuster-html-docで、前回のようにHTMLを用意するまでもない場合に</p>

<p><code>javascript
/*:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;*/
assert.equals(this.hoge.innerHTML, 'aaaa');
</code></p>

<p>という風にテスト毎にエレメントを生成することができます。</p>

<h2>使い方</h2>

<p><code>buster-html-doc</code>をnpmからインストールします。</p>

<p><code>
$ npm install buster-html-doc
</code></p>

<p><code>buster.js</code>でbuster-html-docを読み込むようにします。</p>

<p>```javascript
var config = module.exports;</p>

<p>config["browser test"] = {
  env : "browser",
  tests : [</p>

<pre><code>"test.js"
</code></pre>

<p>  ],
  extensions: [require("buster-html-doc")] // これ
}
```</p>

<p>こういう感じにテストを書きます。</p>

<p>```javascript
buster.testCase('hoge', {</p>

<pre><code>'test html doc' : function() {
    /*:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;*/
    assert.equals(this.hoge.innerHTML, 'aaaa');
}
</code></pre>

<p>})
```</p>

<p>これでテストを実行すると、テスト時に<code>/*:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;*/</code>の部分が、</p>

<p>```javascript
this.hoge = (function () {</p>

<pre><code>var element = document.createElement("div");
element.innerHTML = "&lt;p&gt;aaaa&lt;/p&gt;";if (element.childNodes.length &gt; 1) {
    throw new Error("HTML doc expected to only contain one root node, found " + element.childNodes.length); 
}
return element.firstChild; 
</code></pre>

<p>}());
```</p>

<p>という感じに変換されます。
あとはこのエレメントを使ってアサーションするなりできます。</p>

<p>上の例では<code>this.hoge</code>に対してエレメントを生成していますが、
そうではなく<code>body</code>とかに突っ込んでほしい場合は、<code>+=</code>を使って書く事もできます。</p>

<p><code>javascript
/*:DOC += &lt;p id="hoge"&gt;aaaa&lt;/p&gt;*/
assert.equals(document.getElementById('hoge').innerHTML, 'aaaa');
</code></p>

<p>という感じなのがbuster-html-docプラグインです。</p>

<h2>buster-coffee</h2>

<p>続いてbuster-coffeeなのですが、名前の通りテスト実行時にCoffeeScriptをコンパイルしてくれるので、コードをCoffeeScriptで書けるよ、というものです。
これ自体は特にめんどくさくなくて、npmでインストールして、</p>

<p><code>
$ npm install buster-coffee
</code></p>

<p>```javascript
var runner = module.exports;</p>

<p>runner["browser test"] = {
  env : "browser",
  tests : [</p>

<pre><code>"test.coffee" // coffee
</code></pre>

<p>  ],
  extensions: [require("buster-coffee")]
}
```</p>

<p>という風に使えばよいのですが、buster-html-docと少し相性の問題があるみたいで、</p>

<p><code>javascript
extensions: [require("buster-coffee"), require("buster-html-doc")]
</code></p>

<p>こういう感じにして、</p>

<p>```coffeescript
buster.testCase 'hoge',</p>

<pre><code>'test html doc' : -&gt;
    ###:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;###
    assert.equals(this.hoge.innerHTML, 'aaaa');
</code></pre>

<p>```</p>

<p>こう書いても、</p>

<blockquote><p>TypeError: Cannot read property 'innerHTML' of undefined</p></blockquote>

<p>となります。</p>

<p>コンパイルされるとHTML Docの部分は</p>

<p><code>javascript
/*:DOC hoge = &lt;p&gt;aaaa&lt;/p&gt;
*/
</code></p>

<p>こうなるはずなので、一見大丈夫そうに思えるんですが、うまくいきません。
というか自分でコンパイルするとちゃんと動くので、プラグインの実行順か、それぞれの実行タイミングが悪いのかみたいな話だと思います。</p>

<p>ハマりやすいので気をつけましょう。</p>

<p>回避策としてはプラグインのところ見直してプルリクエストが一番早そうなんですが、
僕は他の理由もあって先にcoffeeを別にコンパイルするようにしてしまいました。</p>

<h2>おまけ</h2>

<p>HTML Doc形式の書式が結構便利で、最近関わっているプロダクトだと</p>

<p>```coffeescript</p>

<h3>:XHR /hoge = {</h3>

<pre><code>fuga : 'fuga',
piyo : 'piyo'
</code></pre>

<p>}</p>

<h2>#</h2>

<h1>/hoge にアクセスしたらこのレスポンスが返ってくる (XHR部分のラッパー有)</h1>

<p>```</p>

<p>みたいにして通信部分をモックできるようしてみた、便利。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BusterJSでテストに使うHTMLの設定と手動実行]]></title>
    <link href="http://yaakaito.org/blog/2013/03/01/buster-testbed-and-boot/"/>
    <updated>2013-03-01T02:35:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/01/buster-testbed-and-boot</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
みなさんJavaScriptのテスト書いてますか？当然書いてますよね？？？</p>

<p>JSでテスト書く時に、こういうHTMLを使いたいんだけど的なことってあると思います。
BusterJSはデフォルトでいい感じのHTMLを作って使ってくれるので楽にテストをはじめられるんですが、まあ差し替えたいよねーってことで差し替えます。</p>

<p>BusterJSではこれをtestbedと呼んでいて、設定ファイル(だいたいの場合は<code>buster.js</code>)で設定することができます。
設定の仕方は<a href="http://docs.busterjs.org/en/latest/overview/#custom-test-beds">こんな感じ</a>なんだけど、いまんところ<code>testbed</code>ってプロパティは設定できないので、<code>resources</code>から設定します。</p>

<p>```javascript
var config = module.exports;</p>

<p>config["test"] = {</p>

<pre><code>sources: ["lib/*.js"],
tests: ["test/*-test.js"],
resources : {
    path : "/",
    file : "hoge.html"
}
</code></pre>

<p>};
```</p>

<p>というわけでこんな感じに設定を追加します。こうすると<code>hoge.html</code>を使ってテストを走らせてくれます。
で、テスト用のファイルを読み込まなきゃいけないわけで(sourcesとかtestsに設定してるやつ)、それがどこに埋め込まれるのかなーというと、コードを見てみた感じ、</p>

<ol>
<li><code>{{scripts}}</code> という文字列を探して、あったらそこを置き換える</li>
<li><code>&lt;/body&gt;</code> を探して、あったらその直前に置く</li>
<li><code>&lt;/html&gt;</code> を探して、あったらその直前に置く</li>
<li>何も見つからなかったら、一番最後に連結する</li>
</ol>


<p>という順番になってた。(<code>resource-middleware</code>とか読めば分かる)
なので、例えばテストの時だけ <code>initialize</code> みたいな関数を、セットアップスクリプト走らせる前に置き換えたいんだけど的なときは、(↓みたいな感じの場合)</p>

<p>```html</p>

<script src="hoge.js"></script>


<!-- この中に initialize って関数があるとする -->


<script>
// この時点までにテストのときだけinitializeを置き換えてほしい ＞＜
initialize({
    hoge : fuga
});
</script>


<p>```</p>

<p><code>{{scripts}}</code> を使って、</p>

<p>```html</p>

<script src="hoge.js"></script>


<p>{{scripts}}</p>

<script>
initialize({
    hoge : fuga
});
</script>


<p>```</p>

<p>こういう感じにする。で、<code>bootstrap.js</code>みたいなのを用意してあげて、
<code>javascript
// bootstrap.js
initialize = function() { } // 何もしないでーーー＾ー＾
</code></p>

<p>これを<code>sources</code>に追加する。</p>

<p>```javascript
var config = module.exports;</p>

<p>config["test"] = {</p>

<pre><code>sources: ["lib/*.js", "bootstrap.js"],
tests: ["test/*-test.js"],
resources : {
    path : "/",
    file : "hoge.html"
}
</code></pre>

<p>};
```</p>

<p>とすると、実際にテストで使われるファイルは、</p>

<p>```html</p>

<script src="hoge.js"></script>


<script src="bootstrap.js"></script>


<script src="テストとか"></script>


<script>
initialize({ // なにも・・・なかった・・・
    hoge : fuga
});
</script>


<p>```</p>

<p>こんな感じになる。便利！</p>

<p>で、次にテストの実行開始タイミングをコントロールしたいと思うんだけど、割と簡単んで、<a href="http://docs.busterjs.org/en/latest/starting-testrun-manually/#starting-testrun-manually">この辺</a>にも書いてあるように、</p>

<p>```javascript
var config = module.exports;</p>

<p>config["test"] = {</p>

<pre><code>autoRun: false,
sources: ["lib/*.js"],
tests: ["test/*-test.js"],
resources : {
    path : "/",
    file : "hoge.html"
}
</code></pre>

<p>};
```</p>

<p><code>autoRun</code>を<code>false</code>にして、さっきの例だと、<code>initialize</code>まで呼ばれたら実行してほしい！とかなら、</p>

<p>```javascript
// bootstrap.js
initialize = function() {</p>

<pre><code>buster.run();
</code></pre>

<p>}
```</p>

<p>みたいな感じ</p>

<p>というわけでテストに使うHTMLも設定できましたし、ガンガンテストできますね！</p>

<p>そういや別にもう一個なんか書こうと思ってたんですが、忘れたので知ってる人いたら教えてください。</p>
]]></content>
  </entry>
  
</feed>
