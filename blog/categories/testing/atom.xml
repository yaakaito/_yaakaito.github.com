<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Testing | yaakaito.org]]></title>
  <link href="http://yaakaito.github.com/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://yaakaito.github.com/"/>
  <updated>2012-10-16T23:04:14+09:00</updated>
  <id>http://yaakaito.github.com/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Buster.JSについて少しLTした]]></title>
    <link href="http://yaakaito.github.com/blog/2012/10/16/busterjs-clientjs-testing/"/>
    <updated>2012-10-16T22:24:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/10/16/busterjs-clientjs-testing</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
突然LTすることになったので、最近気になってるBuster.JSネタで話してきました。
LTなのであんまり内容は濃くないです。iPhoneシュミレーターとかでも楽に動くし便利だね！というくらいです。</p>

<script async class="speakerdeck-embed" data-id="507b79def901500002026b02" data-ratio="1.3333333333333333" src="http://yaakaito.github.com//speakerdeck.com/assets/embed.js"></script>


<p>スライドにはほとんど情報がないので、どんな感じで話したかを箇条書きで。</p>

<ul>
<li>yaakaito.orgが変なところに飛ばされとる (今はなおったみたい)</li>
<li>みんなJSかきますよね！テストやってますか？？？</li>
<li>フレームワークいろいろありますが、最近はBuster.JSがアツい</li>
<li>JSTestDriverのようにブラウザ上での自動実行と、ヘッドレスでの実行がサポートされている</li>
<li>"Test-Driven JavaScript Development"でも言及されていますが、実際の環境で動かせることは大事</li>
<li>ちなみにこの本書いた人がBuster.JSの作者で、Buster.JSはこの本に書いてある理想を実際に行おうとしている</li>
<li>けど、ヘッドレスでも動くしNodeも扱えるので、使い分けがしやすくて便利</li>
<li>ヘッドレスはまだサポートされてると思った？残念、ベータちゃんでした！</li>
<li>ともあれ便利なので使ってみよう</li>
<li>npmで簡単インストール</li>
<li>buster.jsというコンフィグを書いて、テストを書く</li>
<li>サーバーを立ち上げてテスト対象になるブラウザでアクセス、対象として登録</li>
<li>ChromeやFirefoxはもちろんiOSシュミレーターなんかでもばっちり！(実機もいけるよ！)</li>
<li>RSpecみたいなBDDstyleの書き方もできるよ</li>
<li>sinon.jsとwhen.jsが内蔵されているのでこれ一つで結構いろいろできるよ！ (ちなみにsinon.jsも同じ作者だったはず)</li>
<li>クライアントサイドJSもテスト書こうね！</li>
</ul>


<p>みたいな感じです！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoffeeScriptでライトにBDDする]]></title>
    <link href="http://yaakaito.github.com/blog/2012/10/10/light-coffee-bdd/"/>
    <updated>2012-10-10T00:54:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/10/10/light-coffee-bdd</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
ちょろいCoffeeScript(単発ライブラリ程度)をBDDしながら書くとしたら、
どんな感じにするのが楽かなーと思ったのでちょっとやってみた。</p>

<p>選ぶ以前に、割と最初から何使うかなーってのは決めていて、
grunt+grunt-jasmine-taskの組み合わせです。</p>

<ul>
<li><a href="https://github.com/yaakaito/light-coffee-bdd">light-coffee-bdd</a></li>
</ul>


<h2>grunt-jasmine-task</h2>

<p>grunt-jasmine-taskをnpmから引っ張ってきます。
これはgruntに標準でついてくるtest-taskと同じでphantomjsを使ってテストを実行するタスクです。
requirejs使うといい感じに書けるっぽいです。
package.jsonを適当に作って取ってきます。ついでにcoffee-taskも取ってきます。</p>

<p>```javascript
{
  "name": "project"
  , "version": "0.0.1"
  , "private": true
  , "dependencies": {</p>

<pre><code>"grunt-coffee" : "*"
, "grunt-jasmine-task" : "*"
</code></pre>

<p>  }
}
```</p>

<h2>grunt.js</h2>

<p>grunt.jsにcoffeeのコンパイルとjasmineのタスクを追加します。</p>

<p>```javascript
coffee : {
  app : {</p>

<pre><code>src : [
  'lib/*.coffee'
]
, dest : 'build/'
</code></pre>

<p>  }</p>

<p>  , spec : {</p>

<pre><code>src : [
  'specs/*.coffee'
]
, dest : 'spec_runner/spec/'
</code></pre>

<p>  }</p>

<p>  , runner : {</p>

<pre><code>src : [
  'spec_runner/main.coffee'
]
, dest : 'spec_runner/' 
</code></pre>

<p>  }
}
, jasmine : {
  all : {</p>

<pre><code>src : ['spec_runner/index.html']
, tasks : 'coffee:all'
</code></pre>

<p>  }
}
```</p>

<h2>ランナー</h2>

<p>spec_runner/にランナーを用意します
libとかにjasmineとrequirejsを用意しておきます。
htmlはjasmineをブラウザで実行するときと一緒です。</p>

<p><code>html
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Jasmine Spec Runner&lt;/title&gt;
  &lt;link rel="shortcut icon" type="image/png" href="lib/jasmine-1.2.0/jasmine_favicon.png"&gt;
  &lt;link rel="stylesheet" type="text/css" href="lib/jasmine-1.2.0/jasmine.css"&gt;
  &lt;script type="text/javascript" data-main="main.js" src="lib/require-2.0.2.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>こんな感じ。
で、main.jsからspecを読み込んで実行してあげます。
main.js自体はgruntでcoffeeからコンパイルします。</p>

<p>```coffeescript
config =
  paths :</p>

<pre><code>'jasmine':       'lib/jasmine-1.2.0/jasmine'
'jasmine.html':   'lib/jasmine-1.2.0/jasmine-html'
'jasmine.helper': 'lib/jasmine-1.2.0/jasmine-helper'
</code></pre>

<p>  shim :</p>

<pre><code>'jasmine' :
  'exports' : 'jasmine'
'jasmine.html':   ['jasmine']
'jasmine.helper': ['jasmine']
</code></pre>

<p>require.config config</p>

<p>require ['jasmine', 'jasmine.html', 'jasmine.helper', 'spec/sample_spec'], (jasmine) ->
  jasmineEnv = jasmine.getEnv()
  jasmineEnv.updateInterval = 1000</p>

<p>  htmlReporter = new jasmine.HtmlReporter()</p>

<p>  jasmineEnv.addReporter htmlReporter</p>

<p>  jasmineEnv.specFilter = (spec) -></p>

<pre><code>htmlReporter.specFilter spec
</code></pre>

<p>  jasmineEnv.execute()
```</p>

<p>これで準備完了です。適当なspecを書いてみましょう。</p>

<h2>sample_spec</h2>

<p>gruntで一緒にコンパイルするので、specもcoffeeで書けばよかだと思います。今回は実装がないので何もdefineしてません。</p>

<p>```coffeescript
define [], ->
  describe 'A suite', -></p>

<pre><code>it 'sample spec', -&gt;
  expect(true).toBe true
</code></pre>

<p>```</p>

<p>あとはコンソールから</p>

<p><code>
$ grunt jasmine
</code></p>

<p>で動かします。watch-task書いて動かすのもよいと思います。</p>

<h2>まとめ</h2>

<p>jasmineの部分だけ抽出してますが、実際はこれ+coffeelint+cancat+minifyみたいな構成で書いています。
gruntと使うと簡単なものなら早くセットアップできて、ブラウザもイチイチリロードしなくていいような環境になるので、楽チンですね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ビューテストで便利なAlertNinjaを作りました]]></title>
    <link href="http://yaakaito.github.com/blog/2012/09/05/release-alert-ninja/"/>
    <updated>2012-09-05T19:45:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/09/05/release-alert-ninja</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！前回ふざけてましたが、今回は真面目にライブラリを作りました。
といっても、毎回書くのはめんどくさいのでまとめとくか程度です。</p>

<p>みなさん！iOSのテスト書いてますか？？？
ViewControllerなんかのテストを書いてるときに、例えばGHUnitなんかを使ってたりすると、
UIAlertViewがカジュアルに飛び出てきてウザイですよね＾ー＾ー＾ー＾</p>

<p>僕はUIAlertViewは、適当なラッパークラスを作って、そこを差し替えて出ないようにすることが多いんですが、
テストの為のクラスを作ってる様なものになってしまう上に、毎回書くのがだるポヨ・・・。</p>

<p>なのでついでだしテストも出来るようにしよう、ってことで、UIAlertViewを非表示にしつつ、スパイするライブラリを作りました。</p>

<ul>
<li><a href="https://github.com/yaakaito/AlertNinja">AlertNinja</a></li>
</ul>


<h2>AlertNinjaの機能</h2>

<p>さっきも書きましたが、UIAlertViewを非表示にする、とスパイするの２つの機能を持っています。
この二つの機能はほとんど同時に使う事が多くなると思います。</p>

<p>使い方はこんな感じ、適当なViewControllerがこんな感じでshowDialogというメソッドを持っていたとすると、
```objective-c
- (void)showDialog {<br/>
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Ninja"</p>

<pre><code>                                              message:@"doron"
                                             delegate:nil
                                    cancelButtonTitle:@"YES"
                                    otherButtonTitles:nil];
</code></pre>

<p>  [alert show];
}
```</p>

<p>テストを書くときにどこかからこれを読んでいると、アラートが表示されてしまいますね。
なのでAlertNinjaを使って、アラートがでる可能性のあるところを囲みます。</p>

<p>```objective-c
- (void)testDialog
{</p>

<pre><code>[[UIAlertView ninja] spy];
[viewController showDialog];
[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<p><code>spy</code>でスタートして、<code>complete</code>で終了です、なんか忍者っぽい感じにしたかったんです！！！
こうすると、まずアラートの表示をなかった事にできます。</p>

<p>次はどんなアラートか出たか知りたいですよね、出てないかもしれません。
これは<code>report</code>というものを取得することで検証できます。</p>

<p><code>objective-c
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];
STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
</code></p>

<p><code>showedAlerts</code>は<code>spy</code>されてから表示されたUIAlertViewのリストです。(今のところこの機能しかないです。)
なので、これの<code>count</code>が0だったらアラートはなかったことになりますし、そうでなければ、その中身を検証できます。
今回の例では<code>title</code>が<code>Ninja</code>なアラートが表示されるはず、というテストになっていますね。</p>

<p>つなげるとこんな感じです。</p>

<p>```objective-c
- (void)testDialog
{</p>

<pre><code>[[UIAlertView ninja] spy];
[viewController showDialog];
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];
STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<h3>confirmもできるよ！</h3>

<p>ボタンを何個か設定して、ここを押したい、みたいなテストにも対応できます。</p>

<p>```objective-c
- (void)showConfirm {</p>

<pre><code>UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Ninja"
                                                message:@"Are you Ninja ?"
                                               delegate:self
                                      cancelButtonTitle:@"NO"
                                      otherButtonTitles:@"YES", @"I'm Kunoichi", nil];
[alert show];
</code></pre>

<p>}</p>

<ul>
<li>(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex {
  self.calledClickedButtonAtIndex = YES;
  if(buttonIndex == 0) {

<pre><code>  self.result = @"NO";
</code></pre>

  }
  else if(buttonIndex == 1) {

<pre><code>  self.result = @"YES";
</code></pre>

  }
  else if(buttonIndex == 2) {

<pre><code>  self.result = @"Kunoichi";
</code></pre>

<p>  }
}
```</p></li>
</ul>


<p>こうなってるやつに・・・</p>

<p>```objective-c
- (void)testConfirm
{</p>

<pre><code>[[[UIAlertView ninja] spy] andSelectIndexAt:2];
[viewController showConfirm];
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];

STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
STAssertEqualObjects(@"Kunoichi", viewController.result, @"result is 'Kunoichi'");

[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<p>こんな感じで、<code>spy</code>に続けて<code>andSelectIndexAt</code>でどのインデックスのボタンを押すかを指定することができます。何も設定しないとキャンセルボタン扱いになります。
もちろんDelegateも呼ばれていて、さっきのViewControllerにはさらにこんなのが続いていて、</p>

<p>```objective-c
- (void)willPresentAlertView:(UIAlertView *)alertView {</p>

<pre><code>self.calledWillPresent = YES;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)didPresentAlertView:(UIAlertView *)alertView {
  self.calledDidPresent = YES;
}</p></li>
<li><p>(void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex {
  self.calledWillDismiss = YES;
}</p></li>
<li><p>(void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex {
  self.calledDidDismiss = YES;
}
```</p></li>
</ul>


<p>全体でこんなテストが通るようになっています。
```objective-c
- (void)testConfirm
{</p>

<pre><code>[[[UIAlertView ninja] spy] andSelectIndexAt:2];
[viewController showConfirm];
UIAlertView *alert = [[[[UIAlertView ninja] report] showedAlerts] lastObject];

STAssertEqualObjects(@"Ninja", alert.title, @"alert title is Ninja");
STAssertTrue(viewController.calledWillPresent, @"called will present delegate method");
STAssertTrue(viewController.calledDidPresent, @"called did present delegate method");
STAssertTrue(viewController.calledWillDismiss, @"called will dismiss delegate method");
STAssertTrue(viewController.calledDidDismiss, @"called did dismiss delegate method");
STAssertTrue(viewController.calledClickedButtonAtIndex, @"called did clicked button at Index");
STAssertEqualObjects(@"Kunoichi", viewController.result, @"result is 'Kunoichi'");

[[UIAlertView ninja] complete];
</code></pre>

<p>}
```</p>

<h2>流れがテストできる</h2>

<p>UIAlertViewを含んだテストができるようになったので、全体としてフィーチャーのテストがし易くなりました。
例えば <a href="https://github.com/yaakaito/NLTHTTPStubServer">NLTHTTPStubServer</a> と組み合わせると、
「APIにアクセスしたけど、404だったから"そんなものはない"というアラートだす」みたいなテストを結構スマートに書く事ができますね！！！(宣伝)
テストの為の何かをほとんどプロダクトコードに埋め込まなくとも良いのも特徴です。</p>

<h2>TODO</h2>

<p>今はこれだけで、以下には対応してない＆やろうと思っているので乞うご期待！</p>

<ul>
<li>UIActionSheetも使えるようになる</li>
<li>UIAlertViewStyleのサポート</li>
</ul>


<p>他にもこれ必要じゃね、というのがあればIssueなどに投げてください！！！</p>

<h2>というわけで</h2>

<p>よろしくお願いします！</p>

<ul>
<li><a href="https://github.com/yaakaito/AlertNinja">AlertNinja</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dequeueReusable~の実装とテスト]]></title>
    <link href="http://yaakaito.github.com/blog/2012/08/19/dequeue-reusable-making/"/>
    <updated>2012-08-19T02:35:00+09:00</updated>
    <id>http://yaakaito.github.com/blog/2012/08/19/dequeue-reusable-making</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。UITableViewに実装されている<code>dequeueReusableCellWithIdentifier</code>と同等の機能を持ったものを開発したいんだけど的な話です。
dataSourceに似たのインターフェイスを持ってビューを実装するときに、不特定個数のものに対してインスタンスをすべて生成するわけにも行かないので、ある程度制御してあげる必要があります。
今回はUIScrollView上に構築していく前提になっています。シンタックスハイライターを作ろうとしているので、使い回して描画される対象になるのは、行数表示とコード一行分の表示です。</p>

<p>コードはいつも通りgithubにあります。</p>

<ul>
<li><a href="https://github.com/yaakaito/BGSyntaxHighlighter">BGSyntaxHighlighter</a>

<ul>
<li>注)ライブラリとしては未完成です</li>
</ul>
</li>
</ul>


<h2>実装方法を考える</h2>

<p>さらっと思いつくところではリングバッファのようにしておけばよい気がしますね。
ATPagingViewが似たような機能を実装していたのでコード読んでみたのですが、こちらはページング終了時にリサイクル用のSetに取っておいて、
次の表示タイミングでそこから適当な物をもっていく、という方式でした。微妙にリングバッファと違う・・・。
リングバッファっぽい感じでいけそう？と考えていたのですが、リングバッファにしてしまうと、画面の大きさに合わせてバッファの数を調整しなおさければいけなかったり、
今回は中で簡潔している構造になっているのでよいのですが、APIを外に向けたときに、identifier関連でめんどくなりそうだなーという気がしたので、ATPagingViewがやっているような方法を採用しました。
やることとしては、</p>

<ul>
<li>初回時に必要な分のビューを作る</li>
<li>スクロールにあわせて必要なビューの差分を取って作る</li>
<li>必要なビューを使い回す対象にする</li>
</ul>


<p>案外、簡単そうに見えますね。</p>

<h2>UIScrollViewベースで実装するときの注意点</h2>

<p>UIScrollViewで実装する場合には、UITableViewほど正確にスクロールの位置がとれる訳ではないのがポイントというか、気をつけるところです。
今回はめんどくさいのでやらなかったのですが、ある程度余裕を持って描画してあげないと、下の方のビューが欠けてしまったりします。
適当な余裕をもって描画してあげるといい感じになると思います。</p>

<h2>実装していこう！</h2>

<p>というわけで実装していきましょう。</p>

<h4>下準備</h4>

<p>まずはdequeueReusableのインターフェイスを作ります。今回は行数表示とコード一行分の表示を分けているので、2つ分必要です。
が、実装としては両方同じなので、行数表示だけの例を出していきます。全文を確認したい方はgithubからどうぞ！</p>

<p>```objective-c
- (BGSyntaxHighlightLineNumberView*)dequeueReusableLineNumberView {</p>

<pre><code>if(self.recycleLineNumberViews &amp;&amp; [self.recycleLineNumberViews count] &gt; 0) {
    BGSyntaxHighlightLineNumberView *view = [self.recycleLineNumberViews anyObject];
    [self.recycleLineNumberViews removeObject:view];
    return view;
}
return nil;
</code></pre>

<p>}
```</p>

<p><code>recycleLineNumberViews</code>は<code>NSMutableSet</code>で、ここに再利用可能なビューを入れて行きます。
このメソッドは利用可能なビューが存在すれば、そこから適当なビューを抜き出してきて返す、という具合です。
実際にビューに対しての描画処理をここでやってしまうと残念な感じになってしまうので、依存しないように気をつけましょう。
次のここからビューの取得を試みて、なければ新しいものを作って、描画を行うメソッドです。
UITableViewで言えば、<code>cellForRowAtIndexPath:</code>にあたる部分で、iOSエンジニアなら見覚えのある感じだと思います。</p>

<p>```objective-c
- (BGSyntaxHighlightLineNumberView*)lineNumberViewAtRow:(NSInteger)row {</p>

<pre><code>BGSyntaxHighlightLineNumberView *view = [self dequeueReusableLineNumberView];
if(!view) {
    view = [[BGSyntaxHighlightLineNumberView alloc] initWithFrame:CGRectZero];
}
view.lineNumber = row;
return view;
</code></pre>

<p>}
```</p>

<p>これで大体の準備ができました。<code>BGSyntaxHighlightLineNumberView</code>が必要なときは、このメソッド経由で取得すれば、
再利用できるときは再利用を、ビューが足りずに新しく作る必要があるときは新しくビューを作ってくれます。</p>

<h3>UIScrollViewへ表示する</h3>

<p>では、これを使って実際に<code>UIScrollView</code>へ行数を表示してみましょう。
初回のタイミングというか、最初に必要なものが決まるタイミングで必要な分だけビューを作ります。
(今回は<code>layoutSubViews</code>なんですが、レイアウト以外をここでやるの微妙な感じがするので、こっちの方がよくね？というのがあれば教えてください。)</p>

<p>```objective-c
- (void)layoutSubviews {</p>

<pre><code>// ...     

for(NSInteger i = 0; i &lt; [self.codeObject numberOfCodeLines]; i++) {
    [self makeAndLayoutLineAtRow:i + 1];

    if((i + 1) * kLineHeight &gt;= self.frame.size.height) {
        self.viewingLinesRange = NSMakeRange(0U, i);
        break;
    }
}

// ...
</code></pre>

<p>}
```</p>

<p>必要な分だけビューを作って、初期表示に必要ない部分になったらどこまで描画したかを記録しbreakします。
<code>makeAndLayoutLineAtRow:</code>は指定した行のビューを生成してくれるメソッドで、中身はこんな感じです。</p>

<p>```objective-c
(void)makeAndLayoutLineAtRow:(NSInteger)row {</p>

<pre><code>BGSyntaxHighlightLineNumberView *lineNumberView = [self lineNumberViewAtRow:row];
[self.lineNumberViews addObject:lineNumberView];
[self.lineNumberScrollView addSubview:lineNumberView];
lineNumberView.frame = CGRectMake(0, kLineHeight * (row-1), kLineNumberWidth, kLineHeight);
</code></pre>

<p>}
```</p>

<p>ここまでで、とりあえず最初の表示が作れました、スクロールにあわせて必要な分を生成するようにしましょう。
<code>UIScrollViewDelegate</code>の<code>scrollViewDidScroll:</code>で、</p>

<p>```objective-c
- (void)scrollViewDidScroll:(UIScrollView *)scrollView {</p>

<pre><code>// ...

CGFloat y = scrollView.contentOffset.y;
if(y &lt;= 0 || y + scrollView.frame.size.height &gt; [self.codeObject numberOfCodeLines] * kLineHeight) {
    return;
}

// いらないビューを再利用対象にする
[self recycleLinesOfOutsideFromRangeY:NSMakeRange(scrollView.contentOffset.y, scrollView.frame.size.height)];

/*
  差分を計算して必要なビューをmakeAndLayoutLineAtRow:で描画
*/  
</code></pre>

<p>```</p>

<p>差分の計算ロジックなんかは長くなってしまうので、省略しています。表示範囲内にはいっているけれど、まだ表示されてないビューがある場合に表示するロジックです。
<code>recycleLinesOfOutsideFromRangeY:</code>は、名前がよくわからなかったので微妙なのですが、スクロール後に必要なくなったものを<code>removeFromSuperView</code>して、再利用対象にするメソッドです。
一見作ってから削除、でもそんなに変わらない気がしますが、先に削除しておくと、削除されたものをそのまま使い回すことができるので、少しメモリが節約できます。
<code>recycleLinesOfOutsideFromRangeY:</code>を省略して簡単に乗せておくと、</p>

<p>```objective-c
- (void)recycleLinesOfOutsideFromRangeY:(NSRange)range {</p>

<pre><code>NSMutableArray *addingRecycleLineNumberViews = [NSMutableArray array];
for (NSUInteger i = 0, length = [self.lineNumberViews count]; i &lt; length; i++) {
   /*
      範囲外のものを抽出
    */ 
}
[self.recycleLineNumberViews addObjectsFromArray:addingRecycleLineNumberViews];
[self.lineNumberViews removeObjectsInArray:addingRecycleLineNumberViews];
</code></pre>

<p>}
```
という具合です。</p>

<h3>実際どれくらいのビューを必要とするのか</h3>

<p>ここまでで大体実装ができた訳ですが、実際にどれくらいのビューが必要になるのでしょうか。
今回の例では一行の高さが20pxなので、縦を460px確保したとすると、初期状態で460/20で23個必要になります。
スクロールにあわせて描画を行って行くと、初回で何個かallocされれ、あとは大抵24~27個程度のビューのみで構成することがきでています。</p>

<h2>テストを書く</h2>

<p>さて、次はテストを書きましょう。<code>dequeueReusable~</code>のテストとして必要な項目は、</p>

<ul>
<li>あるスクロール位置でのビューが想定した通りにレンダリングされているか</li>
<li>適当なところにスクロールしたときにビューを使い回しているか</li>
</ul>


<p>の2つでしょうか。まずは1つ目の方からテストしてみましょう。
説明を分かり易くするために、ここからビューの高さを100px(ぴったりの場合ビューは5個)で統一していきます。</p>

<h3>想定したレンダリングになっているかテスト</h3>

<p>キチンとレイアウトが出来ているかは別のテスト(<code>dequeueReusable~</code>を無視したテスト)に任せるとして、スクロールした位置によってビューの枚数がキチンとあっているかを確認しましょう。
まずは、ぴったりと高さの倍数で移動したケース。</p>

<p>```objective-c
- (void)testRenderingViews {</p>

<pre><code>view.frame = CGRectMake(0, 0, 320, 100);
[view layoutSubviews];
GHAssertEquals(5U, [view.lineNumberViews count], @"100/20=5で初期段階で5個ある");
GHAssertEquals(5U, [view.lineViews count], @"100/20=5で初期段階で5個ある");

[view.lineNumberScrollView scrollRectToVisible:CGRectMake(0, 180, 320, 100) animated:NO];
GHAssertEquals(5U, [view.lineNumberViews count], @"ぴったりで移動するのでやっぱり5個ある");
GHAssertEquals(5U, [view.lineViews count], @"ぴったりで移動するのでやっぱり5個ある");
</code></pre>

<p>}
```</p>

<p>こっちは簡単ですね。次に10pxくらいずれた場合、この場合は一番上と下に半分づつのビューが必要なので、全体で6個になります、</p>

<p>```objective-c
- (void)testMisalignRenderingVies {</p>

<pre><code>view.frame = CGRectMake(0, 0, 320, 100);
[view layoutSubviews];

[view.lineNumberScrollView scrollRectToVisible:CGRectMake(0, 190, 320, 100) animated:NO];
GHAssertEquals(6U, [view.lineNumberViews count], @"すこしずれて移動するので下に1個余分に追加されて6個になる");
GHAssertEquals(6U, [view.lineViews count], @"すこしずれて移動するので下に1個余分に追加されて6個になる");
</code></pre>

<p>}
```</p>

<p>こんな感じです。</p>

<h3>適当なところにスクロールした場合でのビューの個数をテスト</h3>

<p>どこにスクロールしたときも、ビューを使い回して一定以上の数のビューを生成しないのが今回の目的なので、これをテストします。
自分でたくさんいろんなところにスクロールするテストケースを書いてもいいですが、こういう時はQuickCheckが適用できます。
Objective-CのQuickCheckライブラリは、NLTQuickCheckをご利用ください。(宣伝)</p>

<ul>
<li><a href="https://github.com/yaakaito/NLTQuickCheck">NLTQuickCheck</a></li>
</ul>


<p>標準のdoubleArbitraryでは少し大きいので、doubleArbitaryの<code>quadraticGenWithA:B:C:</code>へ渡す数値を調整して、大体+-0~600pxくらいの範囲の値を作ってくれるArbitraryを定義します。</p>

<p>```objective-c
@implementation NSNumber (BGArbitrary)
+ (id)scrollYArbitrary {</p>

<pre><code>NLTQGen *quadratic = [NLTQGen quadraticGenWithA:1&lt;&lt;16 b:1 c:1];
NLTQGen *doubleGen = [NLTQGen genWithGenerateBlock:^id(double progress, int random) {
    NLTQGen *chooser = [NLTQGen randomGen];
    [chooser resizeWithMinimumSeed:-random maximumSeed:+random];
    random = [[chooser valueWithProgress:progress] intValue];
    int place = [[NSString stringWithFormat:@"%d",random] length] - 2;
    int l = [[NLTQStandardGen standardGenWithMinimumSeed:2 maximumSeed:place] currentGeneratedValue];
    int base = 10;
    for (int i = 1; i &lt; l; i++) {
        base *= 10;
    }
    return [NSNumber numberWithDouble:(double)random/(double)base];

}];
[doubleGen bindingGen:quadratic];
return doubleGen;    
</code></pre>

<p>}
@end
```</p>

<p>このArbitraryを使って、さっきのテストと同じ要領で適当な場所へスクロールさせます。</p>

<p>```objective-c
- (BOOL)propRecycleLogic:(NSNumber*)y {</p>

<pre><code>view = [[BGSyntaxHighlightView alloc] initWithFrame:CGRectZero];
codeObject = [[BGCodeObject alloc] initWithCodeString:[NSBundle codeStringForResouce:@"mockLongObjective-C" ofType:@"txt"]];
view.codeObject = codeObject;
view.frame = CGRectMake(0, 500, 320, 100);
[view layoutSubviews];
[view.lineNumberScrollView scrollRectToVisible:CGRectMake(0, [y floatValue], 320, 100) animated:NO];
GHTestLog(@"%d", [view.lineNumberViews count]);
return [view.lineNumberViews count] &lt; 8; // 3つくらいは許容できる
</code></pre>

<p>}</p>

<ul>
<li>(void)testRecycle {
  NLTQTestable *testable = [NLTQTestable testableWithPropertySelector:@selector(propRecycleLogic:)

<pre><code>                                                           target:self
                                                      arbitraries:[NSNumber scrollYArbitrary], nil];
</code></pre>

<p>  [testable verboseCheck];
  GHAssertTrue([testable success], @"%@", [testable prettyReport]);
}
```</p></li>
</ul>


<p>アサーションは<code>return [view.lineNumberViews count] &lt; 8;</code>で、ピッタリが5個なので大体8個あれば十分使い回しきれるだろう、という風に書きます。</p>

<h2>まとめ</h2>

<p>これで<code>dequeueReusable~</code>っぽいものが実装できました。
ビューが多くなってしまうが、不可視なビューが存在する、という状況では実装しておいて損はない機能です。
ただやってみて実装コストは少し高めだなーと感じたので、その辺は相談、という感じでしょうか。</p>
]]></content>
  </entry>
  
</feed>
