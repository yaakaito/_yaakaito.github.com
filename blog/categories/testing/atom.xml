<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Testing | yaakaito.org]]></title>
  <link href="http://yaakaito.org/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://yaakaito.org/"/>
  <updated>2013-04-26T05:19:23+09:00</updated>
  <id>http://yaakaito.org/</id>
  <author>
    <name><![CDATA[yaakaito]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最近TypeScript書くときに使うGrunt+Testem+αのテンプレ]]></title>
    <link href="http://yaakaito.org/blog/2013/04/26/typescript-proj-template/"/>
    <updated>2013-04-26T03:50:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/04/26/typescript-proj-template</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
TypeScript0.9のpreviewがリリースされましたね！最近はもうJavaScriptもCoffeeScriptも自発的には書ていないです。
仕事とかでも結構TypeScriptでプロト作っては捨て、みたいなことをやってるんですが、
そうしてるうちにプロジェクトのテンプレ大体決まってきたなーという感じがしたのでまとめた。</p>

<p><a href="https://github.com/yaakaito/typescript-proj">typescript-proj</a></p>

<h2>搭載しているもの</h2>

<ul>
<li>Gruntのカスタムタスク</li>
<li>Testem Mocha+chai でのテスト環境</li>
<li>jQuery.d.ts 1.9</li>
<li>.gitignoreとか.gitattributes</li>
<li>package.jsonとcomponents.json入り</li>
</ul>


<p>中核はGrunt+Testem+Bowerな感じ。yoでよくね感すごい。</p>

<h2>使い方</h2>

<p>完全に個人用にまとめてるだけなので、cloneして<code>.git</code>消して使ってる。</p>

<p><code>
$ git clone https://github.com/yaakaito/typescript-proj.git proj
$ rm -rf proj/.git
</code></p>

<p>npmとbowerを使ってるので、とりあえずテンプレ分を取ってくる</p>

<p><code>
$ npm install
$ bower install
</code></p>

<h2>プロジェクト構成</h2>

<p>セットアップしてから、とりあえず <code>grunt generate</code> するとこんな感じになる。</p>

<p><code>
tree -L 2 --dirsfirst
.
├── build
│   ├── index.js
│   └── index.min.js
├── compiled
│   ├── src
│   └── test
├── components
│   └── jquery
├── d.ts
│   ├── chai.d.ts
│   ├── jquery.d.ts
│   └── mocha.d.ts
├── node_modules
│   ├── grunt
│   ├── grunt-contrib-clean
│   ├── grunt-contrib-concat
│   ├── grunt-contrib-connect
│   ├── grunt-contrib-copy
│   ├── grunt-contrib-uglify
│   ├── grunt-regarde
│   └── grunt-typescript
├── public
│   ├── javascript
│   └── index.html
├── res
│   └── index.html
├── src
│   └── index.ts
├── test
│   └── index.ts
├── Gruntfile.coffee
├── README.md
├── component.json
├── package.json
└── testem.json
</code></p>

<p>上から説明していくと</p>

<h3>build</h3>

<p>連結済み + minify済みのJSが置かれるところ。
これはリリースの配布にも使うことを前提にしているので、gitignoreはされてない。</p>

<h3>compiled</h3>

<p>単純にコンパイルした状態のJSが置かれるところ。
中間ファイルみたいなものなので、gitignoreの対象。</p>

<h3>components</h3>

<p>bowerで入るモジュール。gitginore。</p>

<h3>d.ts</h3>

<p>TypeScript用のd.tsを置くところ。コードとほぼ同じ扱い。
微妙に違うけど、vendorみたいなもの。ドットは好みだと思うのでご自由に。</p>

<p>デフォルトでは jQueryと mocha、chaiを入れてある。
jQueryはまあなんだかんだで使う(使わされる)のでデフォで入れてある感じ。
mochaとchaiはテスト用、testemはそこまでは面倒みてくれないので自分で置く。</p>

<h3>node_modules</h3>

<p>npm。主にgrunt系がインストールされる。特に書く事ない。</p>

<h3>public</h3>

<p>プレビューモードでルートにするところ。gh-pagesとか作りたいときはここに入るように作るんだけど、<code>index.html</code>の元ファイルとかは<code>res</code>にある。</p>

<h3>res</h3>

<p>TypeScript以外のものを置くところ。上の<code>index.html</code>とか、cssとか置いたりする。
compassとかをデフォルトで入れてないんだけど、作るならここに入れる事になると思う。</p>

<h3>src</h3>

<p>TypeScript、特に言う事ない。</p>

<h3>test</h3>

<p>テスト、特に言う事ない。</p>

<h3>Gruntfile.coffee</h3>

<p>Gruntの設定ファイル。詳しくは後で。</p>

<h3>README.md</h3>

<p>とりあえずデフォルトでテンプレートのREADME入れてる。</p>

<h3>component.json package.json</h3>

<p>bowerとnpm。特に言う事ない。</p>

<h3>testem.json</h3>

<p>Testemの設定ファイル。詳しくは後で。</p>

<h2>Gruntのタスク</h2>

<p>ビルド系は微妙に分かり難いんだけど、基本的に<code>compile</code> <code>build</code> <code>generate</code>の3種類を定義して使ってる。
それにプラスして<code>preview</code>というのを作っていて、配信サーバーを立てて、ファイル更新されたらビルドしなおす感じ。
LiveReloadとかはなくともよいかなーと思ってるので作ってない。</p>

<h3>compile</h3>

<p>単純にTypeScriptをコンパイルするだけ。<code>src</code> <code>test</code> 共にコンパイルして <code>compiled</code> へ。
TypeScriptだと<code>index.ts</code>だけコンパイルするようにして、<code>index.ts</code>で全部referenceでもいいと思うので使い分ける。</p>

<p>```coffeescript
typescript:</p>

<pre><code>compile:
    src: ['src/**/*.ts']
    dest: 'compiled'
    # src: ['src/index.ts']
    # dest: 'compiled/src/index.ts'
    options:
        module: 'commonjs'
        target: 'es5'
        # sourcemap: true
        # declaration: true
test:
    src: ['test/**/*.ts']
    dest: 'compiled'
    options:
        module: 'commonjs'
        target: 'es5'
</code></pre>

<p>grunt.registerTask 'compile', ['typescript']
```</p>

<h3>build</h3>

<p>concat + uglifyでminify作ったりする。作ったのは <code>build</code> に入る。</p>

<p>```coffeescript
concat:</p>

<pre><code>dist:
    src: ['compiled/src/**/*.js']
    dest: 'build/index.js'
options:
    separator: ';'
</code></pre>

<p>uglify:</p>

<pre><code>min:
    files:
        'build/index.min.js': ['build/index.js']
###
options:
    mangle:
        expect: ['jQuery']
    sourceMap: 'build/source-map.js'
###
</code></pre>

<p>grunt.registerTask 'build', ['concat', 'uglify']
```</p>

<h3>generete</h3>

<p><code>public</code>を作る為のコマンド、用途に合わせて書き足していく。(インデントきもい)</p>

<p>```coffeescript
copy:</p>

<pre><code>public:
    files: [
            expand: true
            cwd: 'build'
            src: '**'
            dest: 'public/javascript'
        ,
            expand: true
            cwd: 'res'
            src: '**'
            dest: 'public/'
    ]
</code></pre>

<p>grunt.registerTask 'generate', ['compile', 'build', 'copy:public']
```</p>

<h3>preview</h3>

<p>connect + regarde。regardeでgenerateするようにしてる。</p>

<p>```coffeescript
connect:</p>

<pre><code>preview:
    options:
        port: 9000
        base: 'public'
</code></pre>

<p>regarde:</p>

<pre><code>src:
    files: ['src/**/*.*']
    tasks: ['generate']
</code></pre>

<p>grunt.registerTask 'preview', ['generate', 'connect:preview', 'regarde']
```</p>

<p>Gruntfileは状況に合わせて柔軟に変えていく感じにしたいので、デフォルトは<code>*</code>指定が多め。</p>

<h2>Testem</h2>

<p>テストは最近は全部Testemでやってる。BusterJS派だったけど、BusterJSはちょっとトロい感じがする・・・。</p>

<p>```javascript
{</p>

<pre><code>"framework" : "mocha+chai",
"before_tests" : "grunt compile",
"src_files" : [
    "src/**/*.ts",
    "test/**/*.ts"
],
"serve_files" : [
    "compiled/src/**/*.js",
    "compiled/test/**/*.js"
]
</code></pre>

<p>}
```</p>

<p>基本は <code>src</code> <code>test</code> を監視して、あとはGruntに任せてる。</p>

<h2>その他</h2>

<p>適当に<code>index.ts</code>を<code>src</code> <code>test</code> 共に吐いているので、忘れかけたら参考にするなどして書く。
<code>.js</code>は最初からバイナリ扱いしているので安心してください！！！</p>

<h2>まとめ</h2>

<p>CoffeeScriptとかも大体同じ感じで出来ると思うので、それなりに汎用性ある感じだと思う。(やろうとしたけど書かない事に気づいてやってない)
<a href="https://github.com/yaakaito/Gruntfile">Gruntfileだけ個別</a>にまとめたりもしてるので、適当に組み合わせるとよいのでは。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS用テスティングサーバー NLTHTTPStubServer 0.4 を公開しました]]></title>
    <link href="http://yaakaito.org/blog/2013/04/22/release-nlt-http-stub-server-0-4-0/"/>
    <updated>2013-04-22T00:51:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/04/22/release-nlt-http-stub-server-0-4-0</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！
<a href="https://github.com/yaakaito/NLTHTTPStubServer">NLTHTTPStubServer</a> を0.4にアップデートしました。</p>

<p>最初にごめんなさいしておかなければいけないことがあります。</p>

<h2>0.2.x 系との互換性がありません</h2>

<p>ごめんなさい。0.1.x 0.2.x 系でのバグフィックスなどは、半年くらいは受け付けようと思っていますので、気軽にご連絡ください。</p>

<h2>NLTHTTPStubServerって何</h2>

<p>簡単に言えば、レスポンス登録を動的にできるHTTPサーバー for iOSです。
HTTP通信をするiOSアプリはたくさんあると思うのですが、これのテストを書く為に開発されました。</p>

<p>仕組みとしては結構単純で、ローカルにHTTPサーバーを立てて、そこにレスポンスを登録し、アプリ(HTTPClient)でそこへアクセスする、という感じです。
例えば <code>/api/v1/fake</code> は <code>fake.json</code> を返してほしい、というケースであれば、</p>

<p><code>objective-c
[[[server expect] forPath:@"/api/v1/fake"] andJSONResponseResource:@"fake" ofType:@"json"];
</code></p>

<p>という風に記述すると、クライアントからここにアクセスしたときに、<code>fake.json</code>が返されます。
NSURLConnectionを使って書くと、</p>

<p>```objective-c
NSURL *api = [NSURL URLWithString:@"http://localhost:12345/api/v1/fake"];
[NSURLConnection sendAsynchronousRequest:[NSURLRequest requestWithURL:api]</p>

<pre><code>                               queue:[[NSOperationQueue alloc] init]
                   completionHandler:^(NSURLResponse *res, NSData *data, NSError *err) {
                     // dataに fake.json が返ってくる
                   }];
</code></pre>

<p>```</p>

<p>このように<code>http://localhost:12345/api/v1/fake</code>へアクセスすると、<code>fake.json</code>が返ってきます。</p>

<p>カテゴリを使ってレスポンスを入れ替えたりするライブラリなんかもありますが、それと比べて、副作用が起こりにくいのが特徴です。
またモックを差し込む、という行為を必要とせず、APIのエンドポイントを入れ替えるだけでよいので、実装自体に手をいれる必要もほとんどありません。</p>

<h2>セットアップ</h2>

<p>Cocoapodsでのセットアップが簡単です。</p>

<p><code>
pod 'NLTHTTPStubServer'
</code></p>

<p><code>NLTHTTPStubServer.h</code>をインポートして使います。</p>

<p>```objective-c</p>

<h1>import "NLTHTTPStubServer"</h1>

<p>```</p>

<h2>機能</h2>

<h3>サーバーの取得</h3>

<p>テスト用サーバーは <code>sharedServer</code> でインスタンスを取得することができます。</p>

<p><code>objective-c
NLTHTTPStubServer *server = [NLTHTTPStubServer sharedServer];
</code></p>

<p><code>clear</code>で登録されているレスポンスをすべて削除し、綺麗な状態にすることができます。</p>

<p><code>objective-c
[server clear];
</code></p>

<p><code>tearDown</code>などでお使いください。</p>

<h3>expect / stub /verify</h3>

<p>0.2.x まででサポートされていた<code>stub</code>が廃止されました。<code>stub</code>というAPIは存在しますが、動作が異なっています。</p>

<h4>expect</h4>

<p><code>expect</code>はレスポンスを登録する一般的な方法です。</p>

<p><code>objective-c
[[server expect] forPath:@"/path"];
</code></p>

<p>このように記述すると、<code>/path</code>へレスポンスが登録されます。
これに対して、メソッドチェインの形式で、必要なものを付加していきます。</p>

<p><code>objective-c
[[[server expect] forPath:@"/api/v1/fake"] andJSONResponseResource:@"fake" ofType:@"json"];
</code></p>

<p><code>expect</code>で登録されたレスポンスは、一度アクセスを受けてそれが返されると、自動的に消化さた状態になります。
<code>/path</code>へ二度アクセスしても、レスポンスは返されません。(例外が投げられます。)</p>

<h4>verify</h4>

<p><code>expect</code>されたものは、<code>verify</code>によって、それが利用されたかを検証することができます。</p>

<p>```objective-c
[[server expect] forPath:@"/path"];</p>

<p>// http://localhost:12345/path へアクセスするコード</p>

<p>[server verify]; // /path へきちんとアクセスされているかを検証
```</p>

<h4>stub</h4>

<p><code>stub</code>は<code>expect</code>と同じインターフェイスを持ちますが、永続的に登録されるレスポンスです。</p>

<p><code>objective-c
[[server stub] forPath:@"/path"];
</code></p>

<p>これは <code>http://localhost:12345/path</code> へアクセスを受けそれが返されても、<strong>消化された状態になりません</strong>。
また、<code>verify</code>による検証では、<code>stub</code>で登録されたものは<strong>無視されます</strong>。</p>

<h3>NLTPath</h3>

<p><code>NLTPath</code>は複雑なURLを表現するために使われる物で、現状では特にGETパラメーターに対応するための機能です。</p>

<p>```objective-c
[[server expect] forPath:[NLTPath pathWithPathString:@"/fake" andParameters:@{</p>

<pre><code>    @"k1" : @"v1",
    @"k2" : @"v2",
</code></pre>

<p>}]];
```</p>

<p>このような記述をした場合、このレスポンスは <code>/fake?k1=v1&amp;k2=v2</code> または <code>/fake?k2=v2&amp;k1=v1</code> にマッチします。</p>

<h4>anyValue</h4>

<p><code>[NLTPath anyValue]</code>を使う事で、値部分をワイルドカードにすることができます。</p>

<p>```objective-c
[[server expect] forPath:[NLTPath pathWithPathString:@"/fake" andParameters:@{</p>

<pre><code>    @"k1" : [NLTPAth anyValue]
</code></pre>

<p>}]];
```</p>

<p>これは、<code>/fake?k1=hogeeeeeeee</code> や <code>/fake?k1=fugaaaaaaaaaa</code> にマッチします。</p>

<h3>付加可能な項目</h3>

<p>メソッドチェインにより付加できる事ができる項目は以下です。</p>

<h4>HTTP Method</h4>

<p><code>objective-c
[[server stub] forPath:@"/fake" HTTPMethod:@"Post"];
</code></p>

<h4>Status code</h4>

<p><code>objective-c
[[[server stub] forPath:@"/fake"] andStatusCode:200];
</code></p>

<h4>Simulate waiting</h4>

<p>タイムアウトなどを再現することができます。</p>

<p><code>objective-c
[[[server stub] forPath:@"/fake"] andProcessingTime:10.0f];
</code></p>

<h4>Checking POST body</h4>

<p>POSTされた内容を調べる事が出来ます。</p>

<p>```objective-c
[[[server expect] forPath:@"/fake" HTTPMethod:@"POST"] andCheckPostBody:<sup>(NSData</sup> *postBody) {</p>

<pre><code>    NSString *postBodyString = [that toString:postBody];
    GHAssertEqualStrings(postBodyString, @"POST_BODY", nil);
}];
</code></pre>

<p>```</p>

<h4>Supporting Content-Types</h4>

<p>自動的にContentTypeを付加してくれるものは以下です。</p>

<p><code>objective-c
[[[server expect] forPath:@"/fake"] and{ContentType}Response...]
</code></p>

<ul>
<li>JSON</li>
<li>HTML</li>
<li>XML</li>
<li>Plain Text</li>
<li>Binary

<ul>
<li>application/octet-stream</li>
</ul>
</li>
</ul>


<p>カスタムのContent-Typeは、<code>andContentTypeHeader</code>によって付加することができます。</p>

<h2>バグなどの報告</h2>

<p><a href="https://github.com/yaakaito/NLTHTTPStubServer/issues">Github Issue</a>で受け付けています。(日本語可)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[テスト書きながらTypeScript書ける環境作る]]></title>
    <link href="http://yaakaito.org/blog/2013/03/24/test-driven-typescript/"/>
    <updated>2013-03-24T19:33:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/24/test-driven-typescript</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！TypeScriptを書いています。
というのもBackbone、というかJavaScriptでのMVCにガッツリと関わるような状況になってしまったので、
触ってるだけでもわからんとこ多いし、勉強がてらTypeScriptでクローンつくってみるかーという感じです。</p>

<p>そこで、テストを書きたいわけなんですが、TypeScriptのテスト環境の情報が少ないので、手探りでやったところまで記録しておきます。</p>

<p><a href="http://yaakaito.org/blog/2013/03/23/testing-mocha-testem-htmlcov/">前回、Mocha + Testem + HTMLCov</a> で基礎的な部分を作ったので、これをベースにします。
なのでこれにTypeScriptのコンパイルやらを乗せていく感じです。</p>

<p><a href="https://github.com/yaakaito/typebone">リポジトリはgithubにある</a>ので、見ながら読むと分かりやすいかもしれません。</p>

<h2>TypeScriptのコンパイル</h2>

<p>TypeScriptのコンパイルには <code>tsc</code> を使うので、npmで入れます。</p>

<p><code>
$ npm install -g tsc
</code></p>

<p><code>tsc</code> でコンパイルする時に、<code>--out</code> オプションを付けると <code>refrence</code> を解決しながらビルドしてくれます。
で、これは流儀的にどうなのかは分からないんですが、これを利用して、コンパイル対象は <code>reference</code> するだけにしました。</p>

<p><code>javascript
// src/backbone.ts
/// &lt;reference path="events.ts" /&gt;
/// &lt;reference path="model.ts" /&gt;
</code></p>

<p>とりあえず<code>Backbone.Events</code>と<code>Backbone.Model</code>だけ用意します。</p>

<p>```javascript
// src/events.ts
/// <reference path="../vendor/underscore.d.ts" /></p>

<p>module Backbone {
  export class Events {
  // ....
  }
}
```</p>

<p><code>javascript
// src/model.ts
module Backbone {
  export class Model {
  // ....
  }
}
</code></p>

<p>こういう感じにしておいて、以下のコマンドでビルドします。</p>

<p><code>
$ tsc --out backbone.js src/backbone.ts
</code></p>

<p>すると、<code>backbone.js</code>に <code>events.ts</code> と <code>models.ts</code> をコンパイルして、依存を解決したものが吐き出されます。
これには <code>underscore</code> は含まれません。</p>

<h2>テスト用のビルドとTestem</h2>

<p>テストもTypeScriptで書きます。といっても、Mochaを使うので、ほとんどJavaScriptになります。</p>

<h3>【追記】d.tsファイルについて</h3>

<p>TypeScriptからMocha(JavaScript)を利用する為に、<code>d.ts</code>というファイルが必要になります。
これは安全に既存のJavaScriptをTypeScriptから利用する為の仕組みです。</p>

<p><code>d.ts</code> ファイル自体はただのテキストで、コードと対して変わらないです。</p>

<p>入手方法としては自分で書く(ある程度自動生成できるっぽい？)、他の人が作ったものを使う、<a href="http://www.tsdpm.com/">tsd</a>を利用するの3つがあります。
tsdは<code>d.ts</code>のパッケージマネージャみたいなものなんですが、僕はそこまで大げさなものじゃないよなーと思っているので、適当に拾ってきて突っ込んでいます。(あんまりツール的なの増やしたくないのもある。)</p>

<p><a href="https://github.com/borisyankov/DefinitelyTyped">DefinitelyTyped</a> を見ると有名どころは大体揃ってるので、ほとんどの場合はここから取得すれば済むと思います。
mochaとchaiはこの中になかったので、僕は下のを使ってます。</p>

<p><a href="https://gist.github.com/muratg/4163650">mocha.d.ts</a> | <a href="https://github.com/TobiaszCudnik/asyncmachine/blob/master/headers/chai.d.ts">chai.d.ts</a></p>

<h3>テストを書く</h3>

<p>```javascript
// test/events-test.ts
/// <reference path="../src/events.ts" />
/// <reference path="../vendor/mocha.d.ts" />
/// <reference path="../vendor/chai.d.ts" /></p>

<p>describe('Backbone.Events', function(){
  it('test name', function(){</p>

<pre><code>// ....
</code></pre>

<p>  });
});
```</p>

<p><code>test/bootstrap.ts</code> みたいなのを作って、こっちも <code>reference</code> だけにします。(<code>expect</code>のexportだけ書いてます。)</p>

<p>```javascript
/// <reference path="events-tests.ts" />
/// <reference path="../vender/chai.d.ts" /></p>

<p>var expect = chai.expect;
```</p>

<p>これをビルドします。</p>

<p><code>javascript
$ tsc --out backbone.test.js test/bootstrap.ts
</code></p>

<p>これで、全部の<code>reference</code>が解決されると、さっきの<code>backbone.js</code>の下にテストが丸々ついたようなファイルが生成されます。
これをTestemに食わせます。</p>

<p>```javascript
// testem.json
{
  "framework" : "mocha",
  "src_files" : [</p>

<pre><code>"vendor/chai.js",
"vendor/underscore.js",
"backbone.test.js"
</code></pre>

<p>  ]
}
```</p>

<p>これでTestemでテストできるようになりました、<code>tsc</code> には <code>watch</code> があるので、これを使って 変更監視 -> 自動コンパイル -> テスト自動実行 というすてき環境を作ります。</p>

<p><code>
$ tsc --watch -out backbone.test.js test/bootstrap.js
</code></p>

<p>やったー！これでいける！
・・・と思ったんですが、どうもちゃんと <code>watch</code> が動いていなくて、うまくコンパイルできません。
なので<a href="https://github.com/yaakaito/typebone/blob/master/Guardfile">Guardで代用</a>しました。</p>

<p>ちょっと面倒ですが、すてき環境ができましたね！</p>

<h2>カバレッジ</h2>

<p>カバレッジをとるときは、<code>backbone.js</code>側に<code>jscoverage</code>をかける必要があるので、別々にコンパイルが必要です。
となると、さっきの <code>test/bootstrap.js</code> なんかで依存関係を解決しながらコンパイルできないので、個別にコンパイルします。
個別にコンパイルしたテストを全部 <code>cat</code>で繋げて、<code>all-tests.js</code> みたいなのを作ります。あとは前回を参考にしてください。</p>

<p>Makefileにするとこんな感じ</p>

<p>```
compile:
  tsc --out backbone.js src/backbone.ts</p>

<p>compile-test:
  tsc test/<em>.ts
  cat test/</em>.js > all-tests.js
  rm test/*.js</p>

<p>cover: compile compile-test
  jscoverage backbone.js backbone.cover.js
  mocha-phantomjs -R json-cov cover-runner.html | json2htmlcov > cover.html
```</p>

<h2>とりあえず</h2>

<p>こんな感じで一旦は不満なく開発できる環境ができました。</p>

<p>TypeScriptまだ勝手がよく分かってないので、コードはあんまり見ないでーーー＾ー＾</p>

<p>あと、Backboneの移植をやってるからか、テスト側がどうしてもほとんどJavaScriptっぽい感じになるんですが、
無駄にコンパイラに怒られてだるいなーと思う事も。(まあ当然なのだが)
なんでこういう場合は、テスト側は生のJavaScriptでも十分なのかなーと思った。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mocha + Testem + HTMLCov 出来るようにする]]></title>
    <link href="http://yaakaito.org/blog/2013/03/23/testing-mocha-testem-htmlcov/"/>
    <updated>2013-03-23T14:32:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/23/testing-mocha-testem-htmlcov</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです！だるくなくJavaScript開発できる環境を探しています。</p>

<p>というわけでタイトル通りなんですが、Mocha + Testem + HTML-Cov環境を試してみようと思うので、それの作り方です。
想定している使い方としては、普段はTestemを使ってChrome、Firefox、Safariあたりでテストを回しつつ、たまにカバレッジを確認して〜くらいの割と普通な感じです。
CIは今回はやりません。本当は同じランナーでやりたかったんですが、めんどいので分けました。
もっといいやり方知ってる人いたら教えてください！</p>

<p><a href="https://github.com/yaakaito/mocha-testem-htmlcov">作られたリポジトリはgithubにあります。</a></p>

<h2>必要な物の準備</h2>

<p>せっかくなので？ node 0.10.1 を使います。</p>

<p><code>
$ nvm install 0.10.1
</code></p>

<p>必要なモジュールをいれます。</p>

<ul>
<li>testem</li>
<li>mocha</li>
<li>jscoverage</li>
<li>json2htmlcov</li>
<li>mocha-phantomjs

<ul>
<li>phantomjs</li>
</ul>
</li>
</ul>


<p><code>
$ brew install phantomjs
</code></p>

<p><code>
$ npm install -g testem mocha mocha-phantomjs jscoverage json2htmlcov
</code></p>

<p>メンドーだったので僕は<code>Makefile</code>使ってますが、<code>grunt</code>とかがいいですって人はそれもいれるといいと思います。</p>

<h3>chaiとsinonをとってくる</h3>

<p>chaiとsinonを使いたいので、とってきます。sinon-chaiは別にいらないかなーと思ってる子なので入れてません。
<code>/test/vendor</code> みたいなところに配置しておきます。</p>

<p><code>
$ curl -O http://chaijs.com/chai.js
$ curl -O http://sinonjs.org/releases/sinon-1.6.0.js
</code></p>

<h2>適当にテスト用のjs書く</h2>

<p>サンプル用に適当に</p>

<p>```javascript
// /src/sample.js
var A = (function(){
  function A() {</p>

<p>  }
  A.prototype.method = function(v) {</p>

<pre><code>if (v) {
  return "YES";
}
else {
  return "NO";
}
</code></pre>

<p>  }
  return A;
})();
```</p>

<p>テストはこんな感じ、<code>NO</code>の方は通らないようにしてあります。</p>

<p>```javascript
// /test/tests/sample-tests.js
describe('Sample', function(){
  var a;
  beforeEach(function(){</p>

<pre><code>a = new A();
</code></pre>

<p>  });</p>

<p>  it('YES', function(){</p>

<pre><code>chai.expect(a.method(true)).to.equals('YES');
</code></pre>

<p>  })
});
```</p>

<h2>testem.jsonを書く</h2>

<p>chaiやsinonを一緒に混ぜるようにして、<code>testem.json</code>を作ります。</p>

<p>```javascript
{
  "framework" : "mocha",
  "src_files" : [</p>

<pre><code>"src/**/*.js",
"test/vendor/chai.js",
"test/vendor/sinon.js",
"test/tests/**/*-tests.js"
</code></pre>

<p>  ]
}
```</p>

<p>これでtestem側は終わりです。走らせてみましょう。</p>

<p><code>
$ testem
</code></p>

<p><img src="/images/testem-run.png"></p>

<p>テストしたいブラウザで <code>http://localhost:7357</code> を開きます。あとは開きっぱでよいです。</p>

<p><img src="/images/testem-browsers.png"></p>

<p><img src="/images/testem-result.png"></p>

<p>テストしてくれます、便利ですね。</p>

<h2>HTMLCovでカバレッジを出す</h2>

<p>こういう感じにカバレッジを出す事ができます。</p>

<p><img src="/images/htmlcov.png"></p>

<p>適当にいろいろなブラウザでテストした結果をマージできると理想だけど、面倒そうなのでphantomjsで・・・ 、というか<a href="https://github.com/visionmedia/mocha/issues/281">サポートされていない</a>のかな。
<a href="https://github.com/visionmedia/mocha/pull/506">こういうのもあったけど</a>今回はスルーで。</p>

<p>手順としては</p>

<ul>
<li><code>jscoverage</code> で対象のjsを変換</li>
<li><code>mocha-phantomjs</code> で実行して <code>jsoncov</code> の形で吐き出す</li>
<li><code>json2htmlcov</code> を通して HTMLCov へ変換</li>
</ul>


<p>と、ちょっと面倒くさい。</p>

<h3>ランナーを用意する</h3>

<p><code>mocha</code> のランナーを用意します。</p>

<p><code>
$ mocha init [dir]
</code></p>

<p>吐き出されたのを適当に <code>coverage-runner.html</code> みたいなのにリネームして、必要なファイルを読み込むようにする。</p>

<p>```html</p>

<script src="../cover/sample.js"></script>


<script src="./vendor/mocha.js"></script>


<script src="./vendor/chai.js"></script>


<script src="./vendor/sinon.js"></script>


<script>mocha.setup('bdd')</script>


<script src="./tests/sample-tests.js"></script>


<p>```</p>

<p>僕はカバレッジに使うjsを<code>cover</code>というディレクトリに吐き出すようにしたので、こんな感じで。</p>

<p><code>mocha-phantomjs</code> を使えるようにブートを置き換えます。</p>

<p>```javascript</p>

<script>
  if (window.mochaPhantomJS) {
    mochaPhantomJS.run()
  }
  else {
    mocha.run();
  }
</script>


<p>```</p>

<h3>カバレッジを出すコマンド</h3>

<p>さっきの手順に従ったコマンドで実行します。</p>

<p><code>
$ jscoverage src/sample.js ./cover/
$ mocha-phantomjs -R json-cov test/cover-runner.html | json2htmlcov &gt; cover.html
</code></p>

<p>こんな感じで <code>cover.html</code> が作られるので、あとはそれを<code>open</code>すればよいです。</p>

<p>ちょっと面倒ですが、簡単な部類でしたね。</p>

<h2>ちなみに</h2>

<p>僕は Buster.JS 派です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hosted CIでiOSライブラリ(Overline)のテスト回してみた]]></title>
    <link href="http://yaakaito.org/blog/2013/03/15/hosted-ci-with-ocunit/"/>
    <updated>2013-03-15T02:05:00+09:00</updated>
    <id>http://yaakaito.org/blog/2013/03/15/hosted-ci-with-ocunit</id>
    <content type="html"><![CDATA[<p>こんにちは！うきょーです。
<a href="https://hosted-ci.com/">Hosted CI</a>という、なんとMac環境でのJenkinsをホスティングしてくれるという超絶便利サービスがあるのですが、
そこで<a href="https://github.com/yaakaito/overline">Overline</a>のテストを回してみました。(Hosted CIはまだベータ版みたいです。)</p>

<p>参考までに、というかいろいろありそうなので、書いた時点でのOverlineの開発環境を先に乗せておきます。</p>

<ul>
<li>OS 10.7.5</li>
<li>AppCode 1.6</li>
<li>Xcode 4.5</li>
<li>Cocoapods 0.15.2

<ul>
<li>OCHamcrest 1.9</li>
</ul>
</li>
</ul>


<p>コードはAppCodeで書いています。(Hosted CI関係ないけどAppCodeの問題もあったので下に書きます)
テストはSenTestingKit + OCHamcrest。
いろいろあってメインマシンでやらなかったので、ちょっと古いです。</p>

<h2>Hosted CI へ登録する</h2>

<p>OpenSourceだしfree planで登録しました。
ちょっと時間がかかったので、先にローカルでやれることをやっておきます。</p>

<h2>ローカルでテストをビルドする</h2>

<p>とりあえずローカルでテストがビルドできないと話にならないので、そっちを確認します。
Cocoapods込みで<code>xcodebuild</code>するのが思えば始めてだったので、ちょっと面倒でした。</p>

<p>まずテスト用のSchemeを作ります。
ビルドの設定へ<code>Jenkins</code>という名前のschemeを定義してあげます。</p>

<p><img src="/images/appcode-jenkins-scheme.png"></p>

<p>ところでこのschemeをjenkinsから使うのかと思ったんですが、実はいらなかったので、自身のある人はやらなくてよいかもしれません。
作ったら<code>xcodebuild</code>で<code>-list</code>してみましょう。</p>

<p>```
$ xcodebuild -workspace Overline.xcworkspace -list
Information about workspace "Overline":</p>

<pre><code>Schemes:
    ...
    Jenkins
</code></pre>

<p>```</p>

<p>こんな感じに出てきたら準備完了です。<code>xcodebuild</code>で<code>Jenkins</code>のshcemeをビルドします</p>

<p><code>
$ xcodebuild -workspace Overline.xcworkspace -scheme 'Jenkins' -configuration 'Debug' -sdk iphonesimulator clean build
</code></p>

<h2>Hosted CI へログイン</h2>

<p>登録できたっぽいメールがきたので、Hosted CI へログインしましょう！ログインするとDashboardが出てきます。何個かプロジェクトがありますね。</p>

<p><img src="/images/hosted-ci-dashboard.png"></p>

<p>下の方にある Create new project からプロジェクトを追加します。</p>

<p><img src="/images/hosted-ci-create.png"></p>

<h2>プロジェクトの作成</h2>

<p>新しいプロジェクトのセットアップを始めます。</p>

<p><img src="/images/hosted-ci-new-project.png"></p>

<p>おおーここから大まかな設定は出来るのかー。便利だなー。
けどスクリプトとかどうせ書くんだろうしだるいなぁ、とか思いながらセットアップして、 Create Project します。さて次はめんどうな・・・</p>

<p><img src="/images/hosted-ci-config-xcode.png"></p>

<p>なん・・・だと・・・</p>

<p><img src="/images/hosted-ci-selected-target.png"></p>

<p>こいつは・・・まさか・・・ 力強くUpdateします。</p>

<p><img src="/images/hosted-ci-created-project.png"></p>

<p>プロジェクトのページができます。ビルドします。</p>

<p><img src="/images/hosted-ci-jenkins-console.png"></p>

<p><img src="/images/hosted-ci-test-complete.png"></p>

<p>俺の知ってるJenkins+iOSと違う・・・。</p>

<p>という感じで拍子抜けするくらい簡単にセットアップが出来てしまいました。
(正確にはAppCodeの問題で2~3回ビルドしたんですが、それは後述します。)</p>

<p>なにげにPodfileのサポートとかも入っててすごい・・・。</p>

<h2>GithubにPushしたときにHookでテスト</h2>

<p>HookのURLが提供されているので、それを使います。プロジェクトのページにあります。</p>

<p><img src="/images/hosted-ci-github-hook.png"></p>

<p>あとはGithubからJenkins Hook URL を設定して終わりです。</p>

<p><img src="/images/github-jenkins-hook.png"></p>

<h2>と、というわけで</h2>

<p>あっさり動いてしまいましたね・・・？</p>

<p><img src="http://tiqav.com/et.jpg"></p>

<p>あ、いや本当に超絶素晴らしいサービスだと思いますし、フィードバックなどしつつ使わせて頂こうと思います、はい。</p>

<h2>【おまけ】AppCode使っててうまくいかなかった話</h2>

<p>Cocoapodsを使うときに、</p>

<p><blockquote><p>[!] Xcodeproj doesn't know about the following attributes lastKnownFileTypetext for the 'PBXGroup' isa.</p></blockquote></p>

<p>こういう感じになってしまったので、何かなーと思ったら、</p>

<p><blockquote><p>Overline これにはまってた  "Problematic attribute added to PBXGroup when renaming group using AppCode : OC-5881"  http://bit.ly/13XdHU8</p><footer><strong>@azu_re</strong> <cite><a href='https://twitter.com/azu_re/status/312065250436456448'>twitter.com/azu_re/status/&hellip;</a></cite></footer></blockquote></p>

<p>というのを見つけて、<a href="http://bit.ly/13XdHU8">リンク先</a>見てみたらどうもこれっぽい。
<code>lastKnownFileType = text;</code> というのが入ってしまうのだとか。</p>

<p>僕の場合はNSNumberのグループに入ってたので、<a href="https://github.com/yaakaito/Overline/commit/01fbeaf306a56319485e394d56b249bd502cab30">これ消したら</a>なおった。</p>

<p>ありがとうございます。</p>
]]></content>
  </entry>
  
</feed>
